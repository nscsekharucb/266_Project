,sentences,textblob_polarity,grammaticality,semisuper_polarity,readability
0, Create a new list.,1,1,1,1
1,"The created list can be freed with  AlFreeList(), but private value of every node need to be freed  by the user before to call AlFreeList().",1,0,1,1
2,"On error, NULL is returned.",0,1,0,1
3,Otherwise the pointer to the new list.,1,0,0,1
4, Remove all the elements from the list without destroying the list itself.,0,1,1,1
5, Free the whole list.,1,1,0,1
6,This function can't fail.,1,1,0,1
7," Add a new node to the list, to head, containing the specified 'value'  pointer as value.",1,0,1,1
8,"On error, NULL is returned and no operation is performed (i.e.",0,0,0,0
9,the  list remains unaltered).,0,0,0,0
10,On success the 'list' pointer you pass to the function is returned.,1,1,1,1
11," Add a new node to the list, to tail, containing the specified 'value'  pointer as value.",1,0,1,1
12,"On error, NULL is returned and no operation is performed (i.e.",0,0,0,0
13,the  list remains unaltered).,0,0,0,0
14,On success the 'list' pointer you pass to the function is returned.,1,1,1,1
15, Remove the specified node from the specified list.,0,1,1,1
16,It's up to the caller to free the private value of the node.,1,1,1,1
17,This function can't fail.,1,1,0,1
18, Returns a list iterator 'iter'.,0,0,0,0
19,After the initialization every  call to listNext() will return the next element of the list.,0,0,0,0
20,This function can't fail.,1,1,0,1
21, Release the iterator memory,0,1,0,1
22, Create an iterator in the list private iterator structure,1,1,1,1
23, Return the next element of an iterator.,0,1,1,1
24,"It's valid to remove the currently returned element using  listDelNode(), but not to remove other elements.",1,0,1,1
25,"The function returns a pointer to the next element of the list,  or NULL if there are no more elements, so the classical usage patter  is:   iter = listGetIterator(list,<direction>);  while ((node = listNext(iter)) != NULL) {      doSomethingWith(listNodeValue(node));  }",1,0,1,1
26, Duplicate the whole list.,1,1,0,1
27,On out of memory NULL is returned.,0,1,0,1
28,On success a copy of the original list is returned.,1,1,1,1
29,The 'Dup' method set with listSetDupMethod() function is used  to copy the node value.,0,0,1,0
30,Otherwise the same pointer value of  the original node is used as value of the copied node.,1,0,1,1
31,The original list both on success or error is never modified.,1,1,1,1
32, Search the list for a node matching a given key.,1,1,1,1
33,The match is performed using the 'match' method  set with listSetMatchMethod().,0,0,1,0
34,"If no 'match' method  is set, the 'value' pointer of every node is directly  compared with the 'key' pointer.",1,0,1,1
35,On success the first matching node pointer is returned  (search starts from head).,1,0,1,1
36,If no matching node exists  NULL is returned.,0,0,1,0
37," Return the element at the specified zero-based index  where 0 is the head, 1 is the element next to head  and so on.",0,0,0,0
38,"Negative integers are used in order to count  from the tail, -1 is the last element, -2 the penultimate  and so on.",1,0,0,1
39,If the index is out of range NULL is returned.,0,0,1,0
40, Rotate the list removing the tail node and inserting it to the head.,0,1,1,1
41, Detach current tail,1,1,0,1
42, Move it as head,0,0,0,0
43, Add all the elements of the list 'o' at the end of the  list 'l'.,0,0,0,0
44,The list 'other' remains empty but otherwise valid.,1,1,0,1
45, Setup other as an empty list.,1,1,0,1
46, Include the best multiplexing layer supported by this system.,1,1,0,1
47,"The following should be ordered by performances, descending.",1,1,0,1
48, Events with mask == AE_NONE are not set.,0,1,0,1
49,So let's initialize the      vector with it.,0,0,0,0
50, Return the current set size.,1,1,1,1
51, Resize the maximum set size of the event loop.,0,0,1,0
52,"If the requested set size is smaller than the current set size, but  there is already a file descriptor in use that is >= the requested  set size minus one, AE_ERR is returned and the operation is not  performed at all.",1,0,1,1
53,Otherwise AE_OK is returned and the operation is successful.,1,0,1,1
54," Make sure that if we created new slots, they are initialized with      an AE_NONE mask.",1,0,1,1
55, We want to always remove AE_BARRIER if set when AE_WRITABLE      is removed.,0,0,0,0
56, Update the max fd,0,0,0,0
57, NO event with the specified ID found,0,1,0,1
58, Search the first timer to fire.,1,1,1,1
59,This operation is useful to know how many time the select can be  put in sleep without to delay any event.,1,0,0,1
60,If there are no timers NULL is returned.,0,0,0,0
61,Note that's O(N) since time events are unsorted.,0,1,0,1
62,"Possible optimizations (not needed by Redis so far, but...):  1) Insert the event in order, so that the nearest is just the head.",1,0,1,1
63,Much better but still insertion or deletion of timers is O(N).,1,1,1,1
64,2) Use a skiplist to have this operation as O(1) and insertion as O(log(N)).,0,0,1,0
65, Process time events,0,1,0,1
66," If the system clock is moved to the future, and then set back to the      right value, time events may be delayed in a random way.",1,0,1,1
67,Often this      means that scheduled operations will not be performed soon enough.,1,0,1,1
68,"Here we try to detect system clock skews, and force all the time      events to be processed ASAP when this happens: the idea is that      processing events earlier is less dangerous than delaying them      indefinitely, and practice suggests it is.",1,0,1,1
69, Remove events scheduled for deletion.,0,1,1,1
70, Make sure we don't process time events created by time events in          this iteration.,1,0,1,1
71,"Note that this check is currently useless: we always          add new timers on the head, however if we change the implementation          detail, this check may be useful again: we keep it here for future          defense.",1,0,1,1
72," Process every pending time event, then every pending file event  (that may be registered by time event callbacks just processed).",0,0,1,0
73,"Without special flags the function sleeps until some file event  fires, or when the next time event occurs (if any).",1,0,1,1
74,"If flags is 0, the function does nothing and returns.",0,1,0,1
75,"if flags has AE_ALL_EVENTS set, all the kind of events are processed.",1,0,1,1
76,"if flags has AE_FILE_EVENTS set, file events are processed.",0,0,1,0
77,"if flags has AE_TIME_EVENTS set, time events are processed.",0,0,1,0
78,"if flags has AE_DONT_WAIT set the function returns ASAP until all  if flags has AE_CALL_AFTER_SLEEP set, the aftersleep callback is called.",0,0,0,0
79,the events that's possible to process without to wait are processed.,1,0,0,1
80,The function returns the number of events processed.,0,1,1,1
81, Nothing to do?,0,1,0,1
82,return ASAP,0,0,0,0
83," Note that we want call select() even if there are no      file events to process as long as we want to process time      events, in order to sleep until the next time event is ready      to fire.",1,0,0,1
84, How many milliseconds we need to wait for the next              time event to fire?,1,0,0,1
85, If we have to check for events but need to return              ASAP because of AE_DONT_WAIT we need to set the timeout              to zero,0,0,0,0
86, Otherwise we can block,0,0,0,0
87, wait forever,0,0,0,0
88," Call the multiplexing API, will return only on timeout or when          some event fires.",1,0,1,1
89, After sleep callback.,0,0,0,0
90, Number of events fired for current fd.,1,0,1,1
91," Normally we execute the readable event first, and the writable              event laster.",1,0,0,1
92,This is useful as sometimes we may be able              to serve the reply of a query immediately after processing the              query.,1,0,1,1
93,"However if AE_BARRIER is set in the mask, our application is              asking us to do the reverse: never fire the writable event              after the readable.",0,0,0,0
94,"In such a case, we invert the calls.",1,1,0,1
95,"This is useful when, for instance, we want to do things              in the beforeSleep() hook, like fsynching a file to disk,              before replying to a client.",1,0,0,1
96," Note the ""fe->mask & mask & ..."" code: maybe an already              processed event removed an element that fired and we still              didn't processed, so we check if the event is still valid.",0,0,0,0
97,Fire the readable event if the call sequence is not              inverted.,0,0,0,0
98, Fire the writable event.,0,1,0,1
99," If we have to invert the call, fire the readable event now              after the writable one.",0,0,0,0
100, Check time events,0,1,0,1
101, return the number of processed file or time events,0,0,0,0
102, Wait for milliseconds until the given file descriptor becomes  writable or readable or exception,0,0,1,0
103, 1024 is just a hint for the kernel,0,1,0,1
104, avoid valgrind warning,0,0,0,0
105," If the fd was already monitored for some event, we need a MOD      operation.",1,0,0,1
106,Otherwise we need an ADD operation.,0,0,0,0
107, Merge old events,1,1,0,1
108, avoid valgrind warning,0,0,0,0
109," Note, Kernel < 2.6.9 requires a non null event pointer even for          EPOLL_CTL_DEL.",0,0,0,0
110,"  This file implements the ae API using event ports, present on Solaris-based  systems since Solaris 10.",0,0,0,0
111,"Using the event port interface, we associate file  descriptors with the port.",0,0,1,0
112,"Each association also includes the set of poll(2)  events that the consumer is interested in (e.g., POLLIN and POLLOUT).",1,0,1,1
113,"There's one tricky piece to this implementation: when we return events via  aeApiPoll, the corresponding file descriptors become dissociated from the  port.",0,0,1,0
114,"This is necessary because poll events are level-triggered, so if the  fd didn't become dissociated, it would immediately fire another event since  the underlying state hasn't changed yet.",1,0,1,1
115,"We must re-associate the file  descriptor, but only after we know that our caller has actually read from it.",1,0,1,1
116,"The ae API does not tell us exactly when that happens, but we do know that  it must happen by the time aeApiPoll is called again.",1,0,1,1
117,Our solution is to  keep track of the last fds returned by aeApiPoll and re-associate them next  time aeApiPoll is invoked.,1,0,1,1
118,"To summarize, in this module, each fd association is EITHER (a) represented  only via the in-kernel association OR (b) represented by pending_fds and  pending_masks.",1,0,1,1
119,"(b) is only true for the last fds we returned from aeApiPoll,  and only until we enter aeApiPoll again (at which point we restore the  in-kernel association).",1,0,1,1
120, event port,0,0,0,0
121, # of pending fds,0,0,0,0
122, pending fds,0,0,0,0
123, pending fds' masks,0,0,0,0
124, Nothing to resize here.,0,0,0,0
125,  Helper function to invoke port_associate for the given fd and mask.,0,0,0,0
126,"      Since port_associate's ""events"" argument replaces any existing events, we      must be sure to include whatever events are already associated when      we call port_associate() again.",1,0,0,1
127,          This fd was recently returned from aeApiPoll.,1,0,0,1
128,"It should be safe to          assume that the consumer has processed that poll event, but we play          it safer by simply updating pending_mask.",1,0,1,1
129,The fd will be          re-associated as usual when aeApiPoll is called again.,1,0,1,1
130,"          This fd was just returned from aeApiPoll, so it's not currently          associated with the port.",1,0,1,1
131,All we need to do is update          pending_mask appropriately.,1,0,1,1
132,      The fd is currently associated with the port.,1,0,1,1
133,"Like with the add case      above, we must look at the full mask for the file descriptor before      updating that association.",1,0,1,1
134,We don't have a good way of knowing what the      events are without looking into the eventLoop state directly.,1,0,1,1
135,We rely on      the fact that our caller has already updated the mask in the eventLoop.,0,0,1,0
136,"          We're removing all events, so use port_dissociate to remove the          association completely.",1,0,1,1
137,Failure here indicates a bug.,1,1,1,1
138, will not return,0,0,0,0
139,"          ENOMEM is a potentially transient condition, but the kernel won't          generally return it unless things are really bad.",1,0,1,1
140,"EAGAIN indicates          we've reached an resource limit, for which it doesn't make sense to          retry (counter-intuitively).",0,0,1,0
141,All other errors indicate a bug.,1,1,1,1
142,"In any          of these cases, the best we can do is to abort.",1,0,1,1
143, will not return,0,0,0,0
144,"      If we've returned fd events before, we must re-associate them with the      port now, before calling port_get().",0,0,0,0
145,See the block comment at the top of      this file for an explanation of why.,1,0,0,1
146, This fd has since been deleted.,0,0,0,0
147, See aeApiDelEvent for why this case is fatal.,0,0,1,0
148,      port_getn can return with errno == ETIME having returned some events (!).,1,0,0,1
149,"So if we get ETIME, we check nevents, too.",0,0,0,0
150, Any other error indicates a bug.,1,1,1,1
151, We need to have a copy of the fd sets as it's not safe to reuse      FD sets after select().,1,0,0,1
152, Just ensure we have enough room in the fd_set type.,1,0,0,1
153, Set the socket blocking (if non_block is zero) or non-blocking.,0,0,0,0
154,Note that fcntl(2) for F_GETFL and F_SETFL can't be      interrupted by a signal.,0,0,0,0
155, Set TCP keep alive option to detect dead peers.,1,1,1,1
156,"The interval option  is only used for Linux as we are using Linux-specific APIs to set  the probe send time, interval, and count.",1,0,1,1
157," Default settings are more or less garbage, with the keepalive time      set to 7200 by default on Linux.",1,0,0,1
158,Modify settings to make the feature      actually useful.,1,0,0,1
159, Send first probe after interval.,1,1,1,1
160, Send next probes after the specified interval.,0,1,1,1
161,"Note that we set the      delay as interval  or  3, as we send three probes before detecting      an error (see the next setsockopt call).",0,0,0,0
162, Consider the socket in error state after three we send three ACK      probes without getting a reply.,0,0,0,0
163, Avoid unused var warning for non Linux systems.,0,1,0,1
164," Set the socket send timeout (SO_SNDTIMEO socket option) to the specified  number of milliseconds, or disable it if the 'ms' argument is zero.",0,0,0,0
165, anetGenericResolve() is called by anetResolve() and anetResolveIP() to  do the actual work.,1,0,1,1
166,"It resolves the hostname ""host"" and set the string  representation of the IP address into the buffer pointed by ""ipbuf"".",0,0,1,0
167,If flags is set to ANET_IP_ONLY the function only resolves hostnames  that are actually already IPv4 or IPv6 addresses.,1,0,0,1
168,This turns the function  into a validating  or  normalizing function.,0,0,1,0
169, specify socktype to avoid dups,0,0,0,0
170, Make sure connection-intensive things like the redis benchmark      will be able to close or open sockets a zillion of times,1,0,0,1
171, Make sure connection-intensive things like the redis benchmark      will be able to close or open sockets a zillion of times,1,0,0,1
172, Best effort binding.,1,0,0,1
173," strlen(""65535"") + 1;",0,0,0,0
174, Try to create the socket and to connect it.,0,1,1,1
175,"If we fail in the socket() call, or on connect(), we retry with          the next entry in servinfo.",1,0,1,1
176, Using getaddrinfo saves us from self-determining IPv4 vs IPv6,0,0,1,0
177," If the socket is non-blocking, it is ok for connect() to              return an EINPROGRESS error here.",1,0,1,1
178," If we ended an iteration of the for loop without errors, we          have a connected socket.",0,0,0,0
179,Let's return to the caller.,0,1,1,1
180," Handle best effort binding: if a binding address was used, but it is      not possible to create a socket, try again without a binding address.",1,0,1,1
181, Like read(2) but make sure 'count' is read before to return  (unless error or EOF condition is encountered),1,0,0,1
182, Like write(2) but make sure 'count' is written before to return  (unless error is encountered),1,0,0,1
183," strlen(""65535"")",0,0,0,0
184, No effect if bindaddr != NULL,0,0,0,0
185," Format an IP,port pair into something easy to parse.",1,0,0,1
186,"If IP is IPv6  (matches for "":""), the ip is surrounded by [].",0,0,1,0
187,IP and port are just  separated by colons.,0,0,1,0
188,This the standard to display addresses within Redis.,0,0,1,0
189, Like anetFormatAddr() but extract ip and port from the socket's peer.,0,0,1,0
190, ----------------------------------------------------------------------------  AOF rewrite buffer implementation.,0,0,0,0
191,The following code implement a simple buffer used in order to accumulate  changes while the background process is rewriting the AOF file.,1,0,1,1
192,"We only need to append, but can't just use realloc with a large block  because 'huge' reallocs are not always handled as one could expect  (via remapping of pages at OS level) but may involve copying data.",1,0,1,1
193,"For this reason we use a list of blocks, every block is  AOF_RW_BUF_BLOCK_SIZE bytes.",0,0,0,0
194, 10 MB per block,0,1,0,1
195," This function free the old AOF rewrite buffer if needed, and initialize  a fresh new one.",1,0,0,1
196,It tests for server.aof_rewrite_buf_blocks equal to NULL  so can be used for the first initialization as well.,1,0,0,1
197, Return the current size of the AOF rewrite buffer.,1,1,1,1
198, Event handler used to send data to the child process doing the AOF  rewrite.,0,0,1,0
199,We send pieces of our AOF differences buffer so that the final  write when the child finishes the rewrite will be small.,1,0,1,1
200," Append data to the AOF rewrite buffer, allocating new blocks if needed.",1,1,1,1
201," If we already got at least an allocated block, try appending          at least some piece into it.",1,0,0,1
202, The current block is not already full.,1,1,0,1
203," First block to allocate, or need another block.",1,1,0,1
204," Log every time we cross more 10 or 100 blocks, respectively              as a notice or warning.",1,0,0,1
205, Install a file event to send data to the rewrite child if there is      not one already.,0,0,0,0
206, Write the buffer (possibly composed of multiple blocks) into the specified  fd.,1,0,0,1
207,"If a short write or any other error happens -1 is returned,  otherwise the number of bytes written is returned.",1,0,0,1
208, ----------------------------------------------------------------------------  AOF file implementation  -------------------------------------------------------------------------,0,0,0,0
209, Starts a background task that performs fsync() against the specified  file descriptor (the one of the AOF file) in another thread.,0,0,0,0
210, Kills an AOFRW child process if exists,0,1,0,1
211, No AOFRW child?,0,1,0,1
212,return.,0,0,0,0
213," Kill AOFRW child, wait for child exit.",0,1,0,1
214, Reset the buffer accumulating changes while the child saves.,0,1,0,1
215, Close pipes used for IPC between the two processes.,0,1,0,1
216," Called when the user switches from ""appendonly yes"" to ""appendonly no""  at runtime using the CONFIG command.",0,0,0,0
217," Called when the user switches from ""appendonly no"" to ""appendonly yes""  at runtime using the CONFIG command.",0,0,0,0
218, Current working dir path for error messages.,1,0,0,1
219," If there is a pending AOF rewrite, we need to switch it off and          start a new one: the old one cannot be reused becuase it is not          accumulating the AOF buffer.",1,0,0,1
220," We correctly switched on AOF, now wait for the rewrite to be complete      in order to append data on disk.",1,0,0,1
221, This is a wrapper to the write syscall in order to retry on short writes  or if the syscall gets interrupted.,1,0,0,1
222,"It could look strange that we retry  on short writes given that we are writing to a block device: normally if  the first call is short, there is a end-of-space condition, so the next  is likely to fail.",1,0,0,1
223,"However apparently in modern systems this is no longer  true, and in general it looks just more resilient to retry the write.",1,0,0,1
224,If  there is an actual error condition we'll get it at the next try.,1,0,0,1
225, Write the append only file buffer on disk.,1,0,0,1
226,"Since we are required to write the AOF before replying to the client,  and the only way the client socket can get a write is entering when the  the event loop, we accumulate all the AOF writes in a memory  buffer and write it on disk using this function just before entering  the event loop again.",1,0,0,1
227,"About the 'force' argument:   When the fsync policy is set to 'everysec' we may delay the flush if there  is still an fsync() going on in the background thread, since for instance  on Linux write(2) will be blocked by the background fsync anyway.",0,0,0,0
228,"When this happens we remember that there is some aof buffer to be  flushed ASAP, and will try to do that in the serverCron() function.",0,0,0,0
229,However if force is set to 1 we'll write regardless of the background  fsync.,0,0,0,0
230, Seconds between errors logging.,0,1,0,1
231, With this append fsync policy we do background fsyncing.,0,0,0,0
232,If the fsync is still in progress we can try to delay          the write for a couple of seconds.,0,0,0,0
233," No previous write postponing, remember that we are                  postponing the flush and return.",1,0,0,1
234," We were already waiting for fsync to finish, but for less                  than two seconds this is still ok.",1,0,0,1
235,Postpone again.,0,1,0,1
236," Otherwise fall trough, and go write since we can't wait              over two seconds.",0,0,0,0
237, We want to perform a single write.,1,1,0,1
238,This should be guaranteed atomic      at least if the filesystem we are writing is a real physical one.,1,0,0,1
239,While this will save us against the server being killed I don't think      there is much to do about the whole server stopping for power problems      or alike,1,0,0,1
240," We want to capture different events for delayed writes:      when the delay happens with a pending fsync, or with a saving child      active, and when the above two conditions are missing.",1,0,0,1
241,We also use an additional event name to save all samples which is      useful for graphing  or  monitoring purposes.,1,0,0,1
242, We performed the write so reset the postponed flush sentinel to zero.,0,0,0,0
243, Limit logging rate to 1 line per AOF_WRITE_LOG_ERROR_RATE seconds.,0,1,0,1
244, Log the AOF write error and record the error code.,0,1,0,1
245, If the ftruncate() succeeded we can set nwritten to                  -1 since there is no longer partial data into the AOF.,1,0,0,1
246, Handle the AOF write error.,0,1,0,1
247," We can't recover when the fsync policy is ALWAYS since the              reply for the client is already in the output buffers, and we              have the contract with the user that on acknowledged write data              is synced on disk.",0,0,0,0
248, Recover from failed write leaving data into the buffer.,1,1,0,1
249,However              set an error to stop accepting writes as long as the error              condition is not cleared.,1,0,0,1
250," Trim the sds buffer if there was a partial write, and there              was no way to undo it with ftruncate(2).",1,0,0,1
251, We'll try again on the next call...,0,1,0,1
252, Successful write(2).,1,1,0,1
253,"If AOF was in error state, restore the          OK state and log the event.",1,0,0,1
254, Re-use AOF buffer when it is small enough.,1,1,0,1
255,The maximum comes from the      arena size of 4k minus some overhead (but is otherwise arbitrary).,1,0,0,1
256, Don't fsync if no-appendfsync-on-rewrite is set to yes and there are      children doing I or O in the background.,0,0,0,0
257, Perform the fsync if needed.,0,0,0,0
258, aof_fsync is defined as fdatasync() for Linux in order to avoid          flushing metadata.,0,0,0,0
259, Let's try to get this data on the disk,0,1,0,1
260," Create the sds representation of an PEXPIREAT command, using  'seconds' as time to live and 'cmd' to understand what command  we are translating into a PEXPIREAT.",1,0,0,1
261,"This command is used in order to translate EXPIRE and PEXPIRE commands  into PEXPIREAT command so that we retain precision in the append only  file, and the time is always absolute and not relative.",1,0,0,1
262, Make sure we can use strtoll,1,0,0,1
263," Convert argument into milliseconds for EXPIRE, SETEX, EXPIREAT",0,1,0,1
264," Convert into absolute time for EXPIRE, PEXPIRE, SETEX, PSETEX",1,1,0,1
265, The DB this command was targeting is not the same as the last command      we appended.,1,0,0,1
266,To issue a SELECT command is needed.,0,1,0,1
267, Translate EXPIRE or PEXPIRE or EXPIREAT into PEXPIREAT,0,1,0,1
268, Translate SETEX or PSETEX to SET and PEXPIREAT,0,1,0,1
269, Translate SET [EX seconds][PX milliseconds] to SET and PEXPIREAT,0,1,0,1
270, All the other commands don't need translation or need the          same translation already operated in the command vector          for the replication itself.,1,0,0,1
271, Append to the AOF buffer.,0,1,0,1
272,"This will be flushed on disk just before      of re-entering the event loop, so before the client will get a      positive reply about the operation performed.",1,0,0,1
273," If a background append only file rewriting is in progress we want to      accumulate the differences between the child DB and the current one      in a buffer, so that when the child process will do its work we      can append the differences to the new append only file.",1,0,0,1
274, ----------------------------------------------------------------------------  AOF loading  -------------------------------------------------------------------------,0,0,0,0
275," In Redis commands are always executed in the context of a client, so in  order to load the append only file we need to create a fake client.",1,0,0,1
276, We set the fake client as a slave waiting for the synchronization      so that Redis will not try to send replies to this client.,1,0,0,1
277, Replay the append log file.,0,0,0,0
278,On success C_OK is returned.,1,1,0,1
279,On non fatal  error (the append only file is zero-length) C_ERR is returned.,1,0,0,1
280,On  fatal error an error message is logged and the program exists.,0,0,0,0
281, Offset of latest well-formed command loaded.,1,0,0,1
282, Handle a zero-length AOF file as a special case.,1,1,0,1
283,"An emtpy AOF file      is a valid AOF because an empty server with AOF enabled will create      a zero length file at startup, that will remain like that if no write      operation is received.",1,0,0,1
284," Temporarily disable AOF, to prevent EXEC from feeding a MULTI      to the same file we're about to read.",1,0,0,1
285, Check if this AOF file has an RDB preamble.,0,1,0,1
286,In that case we need to      load the RDB file and later continue loading the AOF tail.,0,0,0,0
287," ""REDIS""",0,0,0,0
288," No RDB preamble, seek back at 0 offset.",0,1,0,1
289, RDB preamble.,0,1,0,1
290,Pass loading the RDB functions.,0,1,0,1
291," Read the actual AOF file, in REPL format, command by command.",1,1,0,1
292, Serve the clients from time to time,0,1,0,1
293, Free up to j-1.,1,1,0,1
294, Free up to j-1.,1,1,0,1
295, Free up to j.,1,1,0,1
296, discard CRLF,0,0,0,0
297, Command lookup,0,0,0,0
298, Run the command in the context of a fake client,1,1,0,1
299, The fake client should not have a reply,1,1,0,1
300, The fake client should never get blocked,1,1,0,1
301, Clean up.,1,1,0,1
302,Command code may have changed argv or argc so we use the          argv or argc of the client instead of the local variables.,0,0,0,0
303, This point can only be reached when EOF is reached without errors.,1,1,0,1
304,"If the client is in the middle of a MULTI or EXEC, log error and quit.",0,1,0,1
305," DB loaded, cleanup and return C_OK to the caller.",0,1,0,1
306, Read error.,0,1,0,1
307,"If feof(fp) is true, fall through to unexpected EOF.",1,0,0,1
308, avoid valgrind warning,0,0,0,0
309, Unexpected AOF end of file.,1,1,0,1
310, Make sure the AOF file descriptor points to the end of the              file after the truncate call.,1,0,0,1
311, avoid valgrind warning,0,0,0,0
312, Format error.,0,1,0,1
313, avoid valgrind warning,0,0,0,0
314, ----------------------------------------------------------------------------  AOF rewrite  -------------------------------------------------------------------------,0,0,0,0
315, Delegate writing an object to writing a bulk string or bulk long long.,1,0,0,1
316,This is not placed in rio.c since that adds the server.h dependency.,0,0,0,0
317, Avoid using getDecodedObject to help copy-on-write (we are often      in a child process when this function is called).,0,0,0,0
318, Emit the commands needed to rebuild a list object.,0,1,0,1
319,"The function returns 0 on error, 1 on success.",1,1,0,1
320, Emit the commands needed to rebuild a set object.,0,1,0,1
321,"The function returns 0 on error, 1 on success.",1,1,0,1
322, Emit the commands needed to rebuild a sorted set object.,0,1,0,1
323,"The function returns 0 on error, 1 on success.",1,1,0,1
324, Write either the key or the value of the currently selected item of a hash.,1,1,0,1
325,The 'hi' argument passes a valid Redis hash iterator.,0,0,0,0
326,The 'what' filed specifies if to write a key or a value and can be  either OBJ_HASH_KEY or OBJ_HASH_VALUE.,1,0,0,1
327,"The function returns 0 on error, non-zero on success.",1,1,0,1
328, Emit the commands needed to rebuild a hash object.,0,1,0,1
329,"The function returns 0 on error, 1 on success.",1,1,0,1
330, Helper for rewriteStreamObject() that generates a bulk string into the  AOF representing the ID 'id'.,0,0,0,0
331," Helper for rewriteStreamObject(): emit the XCLAIM needed in order to  add the message described by 'nack' having the id 'rawid', into the pending  list of the specified consumer.",0,0,0,0
332,All this in the context of the specified  key and group.,1,0,0,1
333, XCLAIM <key> <group> <consumer> 0 <id> TIME <milliseconds-unix-time>               RETRYCOUNT <count> JUSTID FORCE.,0,0,0,0
334, Emit the commands needed to rebuild a stream object.,0,1,0,1
335,"The function returns 0 on error, 1 on success.",1,1,0,1
336, Reconstruct the stream data using XADD commands.,0,1,0,1
337, Emit a two elements array for each item.,0,1,0,1
338,"The first is          the ID, the second is an array of field-value pairs.",1,0,0,1
339, Emit the XADD <key> <id> ...fields... command.,0,1,0,1
340, Create all the stream consumer groups.,0,1,0,1
341, Emit the XGROUP CREATE in order to create the group.,0,1,0,1
342, Generate XCLAIMs for each consumer that happens to              have pending entries.,0,0,0,0
343,Empty consumers have no semantical              value so they are discarded.,1,0,0,1
344," For the current consumer, iterate all the PEL entries                  to emit the XCLAIM protocol.",1,0,0,1
345, Call the module type callback in order to rewrite a data type  that is exported by a module and is not handled by Redis itself.,0,0,0,0
346,"The function returns 0 on error, 1 on success.",1,1,0,1
347," This function is called by the child rewriting the AOF file to read  the difference accumulated from the parent into a buffer, that is  concatenated at the end of the rewrite.",0,0,0,0
348, Default pipe buffer size on most Linux systems.,1,1,0,1
349, SELECT the new DB,1,1,0,1
350, Iterate this DB writing every entry,0,1,0,1
351, If this key is already expired skip it,1,0,0,1
352, Save the key and associated value,1,1,0,1
353, Emit a SET command,0,1,0,1
354, Key and value,1,1,0,1
355, Save the expire time,0,0,0,0
356, Read some diff from the parent process from time to time.,0,1,0,1
357," Write a sequence of commands able to fully rebuild the dataset into  ""filename"".",1,0,0,1
358,Used both by REWRITEAOF and BGREWRITEAOF.,0,1,0,1
359,"In order to minimize the number of commands needed in the rewritten  log Redis uses variadic commands when possible, such as RPUSH, SADD  and ZADD.",1,0,0,1
360,However at max AOF_REWRITE_ITEMS_PER_CMD items per time  are inserted using a single command.,1,0,0,1
361, Note that we have to use a different temp name here compared to the      one used by rewriteAppendOnlyFileBackground() function.,1,0,0,1
362," Do an initial slow fsync here while the parent is still sending      data, in order to make the next final fsync faster.",1,0,0,1
363, Read again a few times to get more data from the parent.,1,1,0,1
364,"We can't read forever (the server may receive data from clients      faster than it is able to send data to the child), so we try to read      some more data in a loop as soon as there is a good chance more data      will come.",1,0,0,1
365,"If it looks like we are wasting time, we abort (this      happens after 20 ms without new data).",1,0,0,1
366," Start counting from zero, we stop on N contiguous                       timeouts.",0,0,0,0
367, Ask the master to stop sending diffs.,0,1,0,1
368, We read the ACK from the server using a 10 seconds timeout.,0,1,0,1
369,"Normally      it should reply ASAP, but just in case we lose its reply, we are sure      the child will eventually get terminated.",1,0,0,1
370, Read the final diff if any.,1,1,0,1
371, Write the received diff to the file.,0,1,0,1
372, Make sure data will not remain on the OS's output buffers,1,1,0,1
373, Use RENAME to make sure the DB file is changed atomically only      if the generate DB file is ok.,1,0,0,1
374, ----------------------------------------------------------------------------  AOF rewrite pipes for IPC  --------------------------------------------------------------------------,0,0,0,0
375, This event handler is called when the AOF rewriting child sends us a  single '!',1,0,0,1
376,char to signal we should stop sending buffer diffs.,0,0,0,0
377,The  parent sends a '!',0,0,0,0
378,as well to acknowledge.,0,0,0,0
379," If we can't send the ack, inform the user, but don't try again              since in the other side the children will use a timeout if the              kernel can't buffer our write, or, the children was              terminated.",1,0,0,1
380, Remove the handler since this can be called only one time during a      rewrite.,1,0,0,1
381, Create the pipes used for parent - child process IPC during rewrite.,0,1,0,1
382,"We have a data pipe used to send AOF incremental diffs to the child,  and two other pipes used by the children to signal it finished with  the rewrite so no more data should be written, and another for the  parent to acknowledge it understood this new condition.",1,0,0,1
383, parent -> children data.,0,0,0,0
384, children -> parent ack.,0,0,0,0
385, parent -> children ack.,0,0,0,0
386, Parent -> children data is non blocking.,0,1,0,1
387, ----------------------------------------------------------------------------  AOF background rewrite  -------------------------------------------------------------------------,0,0,0,0
388," This is how rewriting of the append only file in background works:   1) The user calls BGREWRITEAOF  2) Redis calls this function, that forks():     2a) the child rewrite the append only file in a temp file.",1,0,0,1
389,2b) the parent accumulates differences in server.aof_rewrite_buf.,0,0,0,0
390,3) When the child finished '2a' exists.,0,1,0,1
391,"4) The parent will trap the exit code, if it's OK, will append the     data accumulated into server.aof_rewrite_buf into the temp file, and     finally will rename(2) the temp file in the actual file name.",1,0,0,1
392,The the new file is reopened as the new append only file.,1,0,0,1
393,Profit!,0,1,0,1
394, Child,0,1,0,1
395, Parent,0,1,0,1
396, GB per second.,0,1,0,1
397," We set appendseldb to -1 in order to force the next call to the          feedAppendOnlyFile() to issue a SELECT command, so the differences          accumulated by the parent into server.aof_rewrite_buf will start          with a SELECT statement and it will be safe to merge.",1,0,0,1
398, unreached,0,0,0,0
399, Update the server.aof_current_size field explicitly using stat(2)  to check the size of the file.,0,0,0,0
400,"This is useful after a rewrite or after  a restart, normally the size is updated just adding the write length  to the current length, that is much faster.",1,0,0,1
401, A background append only file rewriting (BGREWRITEAOF) terminated its work.,1,1,0,1
402,Handle this.,0,1,0,1
403, Flush the differences accumulated by the parent to the          rewritten AOF.,0,0,0,0
404, The only remaining thing to do is to rename the temporary file to          the configured file and switch the file descriptor used to do AOF          writes.,1,0,0,1
405,We don't want close(2) or rename(2) calls to block the          server on old file deletion.,1,0,0,1
406,There are two possible scenarios:                   1) AOF is DISABLED and this was a one time rewrite.,1,0,0,1
407,The temporary          file will be renamed to the configured file.,0,0,0,0
408,"When this file already          exists, it will be unlinked, which may block the server.",0,0,0,0
409,2) AOF is ENABLED and the rewritten AOF will immediately start          receiving writes.,0,0,0,0
410,"After the temporary file is renamed to the          configured file, the original AOF file descriptor will be closed.",1,0,0,1
411,"Since this will be the last reference to that file, closing it          causes the underlying file to be unlinked, which may block the          server.",1,0,0,1
412,"To mitigate the blocking effect of the unlink operation (either          caused by rename(2) in scenario 1, or by close(2) in scenario 2), we          use a background thread to take care of this.",0,0,0,0
413,"First, we          make scenario 1 identical to scenario 2 by opening the target file          when it exists.",1,0,0,1
414,The unlink operation after the rename(2) will then          be executed upon calling close(2) for its descriptor.,0,0,0,0
415,"Everything to          guarantee atomicity for this switch has already happened by then, so          we don't care what the outcome or duration of that close operation          is, as long as the file descriptor is released again.",1,0,0,1
416, AOF disabled,1,1,0,1
417, Don't care if this fails: oldfd will be -1 and we handle that.,1,0,0,1
418,One notable case of -1 return is if the old file does              not exist.,1,0,0,1
419, AOF enabled,0,1,0,1
420, We'll set this to the current AOF filedes later.,1,0,0,1
421, Rename the temporary file.,0,1,0,1
422,"This will not unlink the target file if          it exists, because we reference it with ""oldfd"".",0,0,0,0
423," AOF disabled, we don't need to set the AOF file descriptor              to this new file, so we can close it.",1,0,0,1
424," AOF enabled, replace the old fd with the new one.",1,0,0,1
425, Make sure SELECT is re-issued,1,1,0,1
426, Clear regular AOF buffer since its contents was just written to              the new AOF from the background rewrite buffer.,1,0,0,1
427, Change state from WAIT_REWRITE to ON if needed,0,1,0,1
428, Asynchronously close the overwritten AOF.,0,1,0,1
429," SIGUSR1 is whitelisted, so we have a way to kill a child without          tirggering an error conditon.",0,0,0,0
430, Schedule a new rewrite if we are waiting for it to switch the AOF ON.,1,1,0,1
431, The following array is used to hold the number of pending jobs for every  OP type.,1,0,0,1
432,This allows us to export the bioPendingJobsOfType() API that is  useful when the main thread wants to perform some operation that may involve  objects shared with the background thread.,1,0,0,1
433,The main thread will just wait  that there are no longer jobs of this type to be executed before performing  the sensible operation.,1,0,0,1
434,This data is also useful for reporting.,1,1,0,1
435, This structure represents a background Job.,0,1,0,1
436,It is only used locally to this  file as the API does not expose the internals at all.,1,0,0,1
437, Time at which the job was created.,0,1,0,1
438, Job specific arguments pointers.,1,1,0,1
439,If we need to pass more than three      arguments we can just pass a pointer to a structure or alike.,1,0,0,1
440, Make sure we have enough stack to perform all the things we do in the  main thread.,1,0,0,1
441," Initialize the background system, spawning the thread.",0,1,0,1
442, Initialization of state vars and objects,0,1,0,1
443, Set the stack size as by default it may be small in some system,1,1,0,1
444, The world is full of Solaris Fixes,1,0,0,1
445, Ready to spawn our threads.,1,1,0,1
446,We use the single argument the thread      function accepts in order to pass the job ID the thread is      responsible of.,1,0,0,1
447, Check that the type is within the right interval.,1,1,0,1
448," Make the thread killable at any time, so that bioKillThreads()      can work reliably.",0,0,0,0
449, Block SIGALRM so we are sure that only the main thread will      receive the watchdog signal.,1,0,0,1
450, The loop always starts with the lock hold.,0,1,0,1
451, Pop the job from the queue.,0,1,0,1
452, It is now possible to unlock the background system as we know have          a stand alone job structure to process.,1,0,0,1
453, Process the job accordingly to its type.,0,1,0,1
454, What we free changes depending on what arguments are set:              arg1 -> free the object at pointer.,1,0,0,1
455,arg2 & arg3 -> free two dictionaries (a Redis DB).,1,0,0,1
456,only arg3 -> free the skiplist.,1,0,0,1
457, Unblock threads blocked on bioWaitStepOfType() if any.,0,0,0,0
458," Lock again before reiterating the loop, if there are no longer          jobs to process we'll block again in pthread_cond_wait().",0,0,0,0
459, Return the number of pending jobs of the specified type.,0,1,0,1
460," If there are pending jobs for the specified type, the function blocks  and waits that the next job was processed.",0,0,0,0
461,Otherwise the function  does not block and returns ASAP.,0,0,0,0
462,The function returns the number of jobs still to process of the  requested type.,0,0,0,0
463,"This function is useful when from another thread, we want to wait  a bio.c thread to do more work in a blocking way.",1,0,0,1
464, Kill the running bio threads in an unclean way.,0,0,0,0
465,This function should be  used only when it's critical to stop the threads for some reason.,1,0,0,1
466,Currently Redis does this only on crash (for instance on SIGSEGV) in order  to perform a fast memory check without other threads messing with memory.,1,0,0,1
467, -----------------------------------------------------------------------------  Helpers and low level bit functions.,1,0,0,1
468, Count number of bits set in the binary array pointed by 's' and long  'count' bytes.,1,0,0,1
469,The implementation of this function is required to  work with a input string length up to 512 MB.,0,0,0,0
470, Count initial bytes not aligned to 32 bit.,0,0,0,0
471, Count bits 28 bytes at a time,0,1,0,1
472, Count the remaining bytes.,0,1,0,1
473, Return the position of the first bit set to one (if 'bit' is 1) or  zero (if 'bit' is 0) in the bitmap starting at 's' and long 'count' bytes.,1,0,0,1
474,"The function is guaranteed to return a value >= 0 if 'bit' is 0 since if  no zero bit is found, it returns count8 assuming the string is zero  padded on the right.",1,0,0,1
475,However if 'bit' is 1 it is possible that there is  not a single set bit in the bitmap.,1,0,0,1
476,In this special case -1 is returned.,1,1,0,1
477," Position of bit, to return to the caller.",0,1,0,1
478," Process whole words first, seeking for first word that is not      all ones or all zeros respectively if we are lookig for zeros      or ones.",1,0,0,1
479,This is much faster with large strings having contiguous      blocks of 1 or 0 bits compared to the vanilla bit per bit processing.,1,0,0,1
480,Note that if we start from an address that is not aligned      to sizeof(unsigned long) we consume it byte by byte until it is      aligned.,1,0,0,1
481, Skip initial bits not aligned to sizeof(unsigned long) byte by byte.,1,0,0,1
482, Skip bits with full word step.,1,1,0,1
483," Load bytes into ""word"" considering the first byte as the most significant      (we basically consider it as written in big endian, since we consider the      string as a set of bits from left to right, with the first bit at position      zero.",1,0,0,1
484,Note that the loading is designed to work even when the bytes left      (count) are less than a full word.,1,0,0,1
485,We pad it with zero on the right.,1,1,0,1
486," Special case:      If bits in the string are all zero and we are looking for one,      return -1 to signal that there is not a single ""1"" in the whole      string.",1,0,0,1
487,"This can't happen when we are looking for ""0"" as we assume      that the right of the string is zero padded.",1,0,0,1
488," Last word left, scan bit by bit.",1,1,0,1
489,"The first thing we need is to      have a single ""1"" set in the most significant position in an      unsigned long.",1,0,0,1
490,We don't know the size of the long so we use a      simple trick.,1,0,0,1
491, All bits set to 1.,0,1,0,1
492, All bits set to 1 but the MSB.,0,1,0,1
493, All bits set to 0 but the MSB.,0,1,0,1
494," If we reached this point, there is a bug in the algorithm, since      the case of no match is handled as a special case before.",1,0,0,1
495, Just to avoid warnings.,0,1,0,1
496, The following set.Bitfield and get.Bitfield functions implement setting  and getting arbitrary size (up to 64 bits) signed and unsigned integers  at arbitrary positions into a bitmap.,1,0,0,1
497,"The representation considers the bitmap as having the bit number 0 to be  the most significant bit of the first byte, and so forth, so for example  setting a 5 bits unsigned integer to value 23 at offset 7 into a bitmap  previously set to all zeroes, will produce the following representation:   +--------+--------+  |00000001|01110000|  +--------+--------+   When offsets and integer sizes are aligned to bytes boundaries, this is the  same as big endian, however when such alignment does not exist, its important  to also understand how the bits inside a byte are ordered.",1,0,0,1
498,Note that this format follows the same convention as SETBIT and related  commands.,1,0,0,1
499, Casting will add UINT64_MAX + 1 if v is negative.,1,1,0,1
500," Converting from unsigned to signed is undefined when the value does      not fit, however here we assume two's complement and the original value      was obtained from signed -> unsigned conversion, so we'll find the      most significant bit set if the original value was negative.",1,0,0,1
501,Note that two's complement is mandatory for exact-width types      according to the C99 standard.,0,0,0,0
502," If the top significant bit is 1, propagate it to all the      higher bits for two's complement representation of signed      integers.",1,0,0,1
503, The following two functions detect overflow of a value in the context  of storing it as an unsigned or signed integer with the specified  number of bits.,1,0,0,1
504,The functions both take the value and a possible increment.,1,1,0,1
505,"If no overflow could happen and the value+increment fit inside the limits,  then zero is returned, otherwise in case of overflow, 1 is returned,  otherwise in case of underflow, -1 is returned.",1,0,0,1
506,"When non-zero is returned (oferflow or underflow), if not NULL, limit is  set to the value the operation should result when an overflow happens,  depending on the specified overflow semantics:   For BFOVERFLOW_SAT if 1 is returned, limit it is set maximum value that  you can store in that integer.",0,0,0,0
507,"when -1 is returned, limit is set to the  minimum value that an integer of that size can represent.",0,0,0,0
508,"For BFOVERFLOW_WRAP limit is set by performing the operation in order to  ""wrap"" around towards zero for unsigned integers, or towards the most  negative number that is possible to represent for signed integers.",1,0,0,1
509, Used by the BITFIELD command implementation.,0,1,0,1
510," Note that maxincr and minincr could overflow, but we use the values      only after checking 'value' range, so when we use it no overflow      happens.",1,0,0,1
511, Perform addition as unsigned so that's defined.,0,1,0,1
512," If the sign bit is set, propagate to all the higher order          bits, to cap the negative value.",1,0,0,1
513,"If it's clear, mask to          the positive integer limit.",1,0,0,1
514, Debugging function.,0,1,0,1
515,Just show bits in the specified bitmap.,0,1,0,1
516,Not used  but here for not having to rewrite it when debugging is needed.,0,0,0,0
517," -----------------------------------------------------------------------------  Bits related string commands: GETBIT, SETBIT, BITCOUNT, BITOP.",1,0,0,1
518, This helper function used by GETBIT  or  SETBIT parses the bit offset argument  making sure an error is returned if it is negative or if it overflows  Redis 512 MB limit for the string value.,1,0,0,1
519,"If the 'hash' argument is true, and 'bits is positive, then the command  will also parse bit offsets prefixed by ""#"".",1,0,0,1
520,In such a case the offset  is multiplied by 'bits'.,1,0,0,1
521,This is useful for the BITFIELD command.,1,1,0,1
522, Handle #<offset> form.,0,1,0,1
523, Adjust the offset by 'bits' for #<offset> form.,0,1,0,1
524, Limit offset to 512MB in bytes,0,1,0,1
525," This helper function for BITFIELD parses a bitfield type in the form  <sign><bits> where sign is 'u' or 'i' for unsigned and signed, and  the bits is a value between 1 and 64.",0,0,0,0
526,However 64 bits unsigned integers  are reported as an error because of current limitations of Redis protocol  to return unsigned integer values greater than INT64_MAX.,1,0,0,1
527,On error C_ERR is returned and an error is sent to the client.,0,1,0,1
528, This is an helper function for commands implementations that need to write  bits to a string object.,0,0,0,0
529,The command creates or pad with zeroes the string  so that the 'maxbit' bit can be addressed.,0,0,0,0
530,The object is finally  returned.,1,0,0,1
531,Otherwise if the key holds a wrong type NULL is returned and  an error is sent to the client.,1,0,0,1
532," Return a pointer to the string object content, and stores its length  in 'len'.",0,0,0,0
533,The user is required to pass (likely stack allocated) buffer  'llbuf' of at least LONG_STR_SIZE bytes.,1,0,0,1
534,Such a buffer is used in the case  the object is integer encoded in order to provide the representation  without usign heap allocation.,1,0,0,1
535,"The function returns the pointer to the object array of bytes representing  the string it contains, that may be a pointer to 'llbuf' or to the  internal object representation.",0,0,0,0
536,As a side effect 'len' is filled with  the length of such buffer.,1,0,0,1
537,If the source object is NULL the function is guaranteed to return NULL  and set 'len' to 0.,0,0,0,0
538," Set the 'p' pointer to the string, that can be just a stack allocated      array if our string was integer encoded.",0,0,0,0
539, SETBIT key offset bitvalue,1,0,0,1
540, Bits can only be set or cleared...,1,1,0,1
541, Get current values,1,1,0,1
542, Update byte with new bit value and return original value,1,1,0,1
543, GETBIT key offset,1,1,0,1
544, BITOP op_name target_key src_key1 src_key2 src_key3 ... src_keyN,0,0,0,0
545, Array of source objects.,0,1,0,1
546, Array of source strings pointers.,0,1,0,1
547," Array of length of src strings,                                       and max len.",0,0,0,0
548, Min len among the input keys.,0,0,0,0
549, Resulting string.,0,1,0,1
550, Parse the operation name.,0,1,0,1
551, Sanity check: NOT accepts only a single key argument.,1,1,0,1
552," Lookup keys, and store pointers to the string objects into an array.",0,0,0,0
553, Handle non-existing keys as empty strings.,1,1,0,1
554, Return an error if one of the keys is not a string.,0,1,0,1
555," Compute the bit operation, if at least one string is not empty.",1,1,0,1
556, Fast path: as far as we have data for all the input bitmaps we          can take a fast path that performs much better than the          vanilla algorithm.,1,0,0,1
557,On ARM we skip the fast path since it will          result in GCC compiling the code using multiple-words load or store          operations that are not supported even in ARM >= v6.,1,0,0,1
558, Note: sds pointer is always aligned to 8 byte boundary.,0,0,0,0
559, Different branches per different operations for speed (sorry).,1,1,0,1
560, j is set to the next byte to process by the previous loop.,1,0,0,1
561, Store the computed value into the target key,1,1,0,1
562, Return the output string length in bytes.,0,1,0,1
563, BITCOUNT key [start end],1,1,0,1
564," Lookup, check for type, and return 0 for non existing keys.",0,0,0,0
565, Parse start or end range if any.,0,1,0,1
566, Convert negative indexes,1,1,0,1
567, The whole string.,1,1,0,1
568, Syntax error.,0,1,0,1
569," Precondition: end >= 0 && end < strlen, so the only condition where      zero can be returned is: start > end.",1,0,0,1
570, BITPOS key bit [start [end]],1,1,0,1
571," Parse the bit argument to understand what we are looking for, set      or clear bits.",1,0,0,1
572," If the key does not exist, from our point of view it is an infinite      array of 0 bits.",1,0,0,1
573,"If the user is looking for the fist clear bit return 0,      If the user is looking for the first set bit, return -1.",1,0,0,1
574, Parse start or end range if any.,0,1,0,1
575, Convert negative indexes,1,1,0,1
576, The whole string.,1,1,0,1
577, Syntax error.,0,1,0,1
578, For empty ranges (start > end) we return -1 as an empty range does      not contain a 0 nor a 1.,1,0,0,1
579," If we are looking for clear bits, and the user specified an exact          range with start-end, we can't consider the right of the range as          zero padded (as we do when no explicit end is given).",1,0,0,1
580,"So if redisBitpos() returns the first bit outside the range,          we return -1 to the caller, to mean, in the specified range there          is not a single ""0"" bit.",1,0,0,1
581, Adjust for the bytes we skipped.,0,1,0,1
582, BITFIELD key subcommmand-1 arg ... subcommand-2 arg ... subcommand-N ...,1,0,0,1
583,Supported subcommands:   GET <type> <offset>  SET <type> <offset> <value>  INCRBY <type> <offset> <increment>  OVERFLOW [WRAP|SAT|FAIL],0,0,0,0
584, Bitfield offset.,0,0,0,0
585, Increment amount (INCRBY) or SET value,0,1,0,1
586, Operation id.,0,1,0,1
587, Overflow type to use.,0,1,0,1
588, Integer bitfield bits width.,0,0,0,0
589," True if signed, otherwise unsigned op.",1,1,0,1
590, Array of ops to execute at end.,0,1,0,1
591, Overflow type.,0,1,0,1
592, Remaining args other than current.,1,0,0,1
593, Current command name.,1,1,0,1
594, Current operation code.,1,1,0,1
595, Signed SET value.,0,1,0,1
596, Signed or unsigned type?,0,1,0,1
597, Bitfield width in bits.,0,0,0,0
598," Get the type and offset arguments, common to all the ops.",1,1,0,1
599, INCRBY and SET require another argument.,0,1,0,1
600, Populate the array of operations we'll process.,0,1,0,1
601," Lookup for read is ok if key doesn't exit, but errors          if it's not a string.",1,0,0,1
602, Lookup by making room up to the farest bit reached by          this operation.,0,0,0,0
603, Actually process the operations.,1,1,0,1
604, Execute the operation.,0,1,0,1
605, SET and INCRBY: We handle both with the same code path              for simplicity.,1,0,0,1
606,SET return value is the previous value so              we need fetch & store as well.,1,0,0,1
607," We need two different but very similar code paths for signed              and unsigned operations, since the set of functions to get or set              the integers and the used variables types are different.",1,0,0,1
608," On overflow of type is ""FAIL"", don't write and return                  NULL to signal the condition.",1,0,0,1
609," On overflow of type is ""FAIL"", don't write and return                  NULL to signal the condition.",1,0,0,1
610, GET,0,1,0,1
611," For GET we use a trick: before executing the operation              copy up to 9 bytes to a local buffer, so that we can easily              execute up to 64 bit operations that are at actual string              object boundaries.",1,0,0,1
612, Now operate on the copied buffer which is guaranteed              to be zero-padded.,0,0,0,0
613, Get a timeout value from an object and store it into 'timeout'.,0,1,0,1
614,"The final timeout is always stored as milliseconds as a time where the  timeout will expire, however the parsing is performed according to  the 'unit' that can be seconds or milliseconds.",1,0,0,1
615,Note that if the timeout is zero (usually from the point of view of  commands API this means no timeout) the value stored into 'timeout'  is zero.,1,0,0,1
616, Block a client for the specific operation type.,1,1,0,1
617,"Once the CLIENT_BLOCKED  flag is set client query buffer is not longer processed, but accumulated,  and will be processed when the client is unblocked.",0,0,0,0
618, This function is called in the beforeSleep() function of the event loop  in order to process the pending input buffer of clients that were  unblocked after a blocking operation.,0,0,0,0
619," Process remaining data in the input buffer, unless the client          is blocked again.",0,0,0,0
620,"Actually processInputBuffer() checks that the          client is not blocked before to proceed, but things may change and          the code is conceptually more correct this way.",1,0,0,1
621, Unblock a client calling the right function depending on the kind  of operation the client is blocking for.,1,0,0,1
622," Clear the flags, and put the client in the unblocked list so that      we'll process new commands in its query buffer ASAP.",1,0,0,1
623," The client may already be into the unblocked list because of a previous      blocking operation, don't add back it into the list multiple times.",1,0,0,1
624, This function gets called when a blocked client timed out in order to  send it a reply of some kind.,1,0,0,1
625,"After this function is called,  unblockClient() will be called with the same client as argument.",1,0,0,1
626, Mass-unblock clients because something changed in the instance that makes  blocking no longer safe.,1,0,0,1
627,"For example clients blocked in list operations  in an instance which turns from master to slave is unsafe, so this function  is called when a master turns into a slave.",0,0,0,0
628,"The semantics is to send an -UNBLOCKED error to the client, disconnecting  it at the same time.",1,0,0,1
629," This function should be called by Redis every time a single command,  a MULTI or EXEC block, or a Lua script, terminated its execution after  being called by a client.",1,0,0,1
630,All the keys with at least one client blocked that received at least  one new element via some PUSH or XADD operation are accumulated into  the server.ready_keys list.,1,0,0,1
631,This function will run the list and will  serve clients accordingly.,0,0,0,0
632,Note that the function will iterate again and  again as a result of serving BRPOPLPUSH we can have new blocking clients  to serve because of the PUSH side of BRPOPLPUSH.,1,0,0,1
633, Point server.ready_keys to a fresh list and save the current one          locally.,1,0,0,1
634,This way as we run the old list we are free to call          signalKeyAsReady() that may push new elements in server.ready_keys          when handling clients blocked into BRPOPLPUSH.,1,0,0,1
635, First of all remove this key from db->ready_keys so that              we can safely call signalKeyAsReady() against this key.,1,0,0,1
636, Serve clients blocked on list key.,1,1,0,1
637," We serve clients in the same order they blocked for                  this key, from the first blocked to the last.",1,0,0,1
638," Put on the tail, so that at the next call                              we'll not run into it again.",0,0,0,0
639," Protect receiver->bpop.target, that will be                              freed by the next unblockClient()                              call.",0,0,0,0
640, If we failed serving the client we need                                  to also undo the POP operation.,1,0,0,1
641, We don't call signalModifiedKey() as it was already called                  when an element was pushed on the list.,0,0,0,0
642, Serve clients blocked on stream key.,1,1,0,1
643, We need to provide the new data arrived on the stream                  to all the clients that are waiting for an offset smaller                  than the current top item.,1,0,0,1
644," Can't overflow, it's an uint64_t",0,1,0,1
645," If we blocked in the context of a consumer                              group, we need to resolve the group and                              consumer here.",0,0,0,0
646," In theory if the group is not found we                                  just perform the read without the group,                                  but actually when the group, or the key                                  itself is deleted (triggering the removal                                  of the group), we check for blocked clients                                  and send them an error.",1,0,0,1
647," Note that after we unblock the client, 'gt'                              and other receiver->bpop stuff are no longer                              valid, so we must do the setup above before                              this call.",1,0,0,1
648, Emit the two elements sub-array consisting of                              the name of the stream and the data we                              extracted from it.,0,0,0,0
649,"Wrapped in a single-item                              array, since we have just one key.",1,0,0,1
650, Free this item.,1,1,0,1
651, We have the new list on place at this point.,1,1,0,1
652," This is how the current blocking lists or streams work, we use BLPOP as  example, but the concept is the same for other list ops and XREAD.",1,0,0,1
653,#NAME?,1,0,0,1
654,So BLPOP is semantically the same as LPOP    if blocking is not required.,1,0,0,1
655,#NAME?,1,0,0,1
656,In order to do so we remove the notification for    new data to read in the client socket (so that we'll not serve new    requests if the blocking request is not served).,1,0,0,1
657,Also we put the client    in a dictionary (db->blocking_keys) mapping keys to a list of clients    blocking for this keys.,0,0,0,0
658,"- If a PUSH operation against a key with blocked clients waiting is    performed, we mark this key as ""ready"", and after the current command,    MULTI or EXEC block, or script, is executed, we serve all the clients waiting    for this list, from the one that blocked first, to the last, accordingly    to the number of elements we have in the ready list.",1,0,0,1
659," Set a client in blocking mode for the specified key (list or stream), with  the specified timeout.",1,0,0,1
660,The 'type' argument is BLOCKED_LIST or BLOCKED_STREAM  depending on the kind of operation we are waiting for an empty key in  order to awake the client.,1,0,0,1
661,The client is blocked for all the 'numkeys'  keys as in the 'keys' argument.,0,0,0,0
662,"When we block for stream keys, we also  provide an array of streamID structures: clients will be unblocked only  when items with an ID greater or equal to the specified one is appended  to the stream.",1,0,0,1
663," The value associated with the key name in the bpop.keys dictionary          is NULL for lists, or the stream ID for streams.",1,0,0,1
664, If the key already exists in the dictionary ignore it.,1,0,0,1
665," And in the other ""side"", to map keys -> clients",1,0,0,1
666, For every key we take a list of clients blocked for it,1,1,0,1
667, Unblock a client that's waiting in a blocking operation such as BLPOP.,1,1,0,1
668,"You should never call this function directly, but unblockClient() instead.",1,0,0,1
669," The client may wait for multiple keys, so unblock it for every key.",1,1,0,1
670, Remove this client from the list of clients waiting for this key.,1,1,0,1
671, If the list is empty we need to remove it to avoid wasting memory,1,0,0,1
672, Cleanup the client structure,0,1,0,1
673," If the specified key has clients blocked waiting for list pushes, this  function will put the key reference into the server.ready_keys list.",1,0,0,1
674,Note that db->ready_keys is a hash table that allows us to avoid putting  the same key again and again in the list in case of multiple pushes  made by a script or in the context of MULTI or EXEC.,1,0,0,1
675,The list will be finally processed by handleClientsBlockedOnLists(),1,0,0,1
676, No clients blocking for this key?,1,1,0,1
677,No need to queue it.,0,1,0,1
678, Key was already signaled?,1,1,0,1
679,No need to queue it again.,0,1,0,1
680," Ok, we need to queue this key into server.ready_keys.",1,0,0,1
681, We also add the key in the db->ready_keys dictionary in order      to avoid adding it multiple times into a list with a simple O(1)      check.,1,0,0,1
682, Open a child-parent channel used in order to move information about the  RDB  or  AOF saving process from the child to the parent (for instance  the amount of copy on write memory used),1,0,0,1
683," On error our two file descriptors should be still set to -1,          but we call anyway cloesChildInfoPipe() since can't hurt.",0,0,0,0
684, Close the pipes opened with openChildInfoPipe().,0,0,0,0
685, Send COW data to parent.,1,1,0,1
686,The child should call this function after populating  the corresponding fields it want to sent (according to the process type).,0,0,0,0
687," Nothing to do on error, this will be detected by the other side.",1,1,0,1
688, Receive COW data from parent.,1,1,0,1
689, A global reference to myself is handy to make code more clear.,1,1,0,1
690,"Myself always points to server.cluster->myself, that is, the clusterNode  that represents this node.",0,0,0,0
691, -----------------------------------------------------------------------------  Initialization  --------------------------------------------------------------------------,0,0,0,0
692, Load the cluster config from 'filename'.,0,0,0,0
693,"If the file does not exist or is zero-length (this may happen because  when we lock the nodes.conf file, we create a zero-length one for the  sake of locking if it does not already exist), C_ERR is returned.",0,0,0,0
694,"If the configuration was loaded from the file, C_OK is returned.",0,1,0,1
695, Check if the file is zero-length: if so return C_ERR to signal      we have to write the config.,0,0,0,0
696, Parse the file.,0,1,0,1
697,Note that single lines of the cluster config file can      be really long as they include all the hash slots of the node.,1,0,0,1
698,"This means in the worst possible case, half of the Redis slots will be      present in a single line, possibly in importing or migrating state, so      together with the node ID of the sender or receiver.",1,0,0,1
699,To simplify we allocate 1024+CLUSTER_SLOTS128 bytes per line.,0,1,0,1
700," Skip blank lines, they can be created either by users manually          editing nodes.conf or by the config writing process if stopped          before the truncate() call.",0,0,0,0
701, Split the line into arguments for processing.,0,1,0,1
702," Handle the special ""vars"" line.",1,0,0,1
703,Don't pretend it is the last          line even if it actually is when generated by Redis.,1,0,0,1
704, Regular config lines have at least eight fields,1,0,0,1
705, Create this node if it does not exist,0,1,0,1
706, Address and port,0,1,0,1
707," In older versions of nodes.conf the ""@busport"" part is missing.",1,0,0,1
708,In this case we set it to the default offset of 10000 from the          base port.,1,0,0,1
709, Parse flags,0,1,0,1
710, nothing to do,0,0,0,0
711, Get master if any.,0,1,0,1
712,Set the master and populate master's          slave list.,0,0,0,0
713, Set ping sent  or  pong received timestamps,0,0,0,0
714, Set configEpoch for this node.,0,0,0,0
715, Populate hash slots served by this instance.,0,1,0,1
716, Here we handle migrating  or  importing slots,0,0,0,0
717, Either '>' or '<',0,1,0,1
718, Config sanity check,0,0,0,0
719, Something that should never happen: currentEpoch smaller than      the max epoch found in the nodes configuration.,1,0,0,1
720,However we handle this      as some form of protection against manual editing of critical files.,1,0,0,1
721, Cluster node configuration is exactly the same as CLUSTER NODES output.,1,1,0,1
722,"This function writes the node config and returns 0, on error -1  is returned.",0,0,0,0
723,"Note: we need to write the file in an atomic way from the point of view  of the POSIX filesystem semantics, so that if the server is stopped  or crashes during the write, we'll end with either the old file or the  new one.",1,0,0,1
724,Since we have the full payload to write available we can use  a single write to write the whole file.,1,0,0,1
725,If the pre-existing file was  bigger we pad our payload with newlines that are anyway ignored and truncate  the file afterward.,1,0,0,1
726," Get the nodes description and concatenate our ""vars"" directive to      save currentEpoch and lastVoteEpoch.",0,0,0,0
727, Pad the new payload if the existing file length is greater.,1,1,0,1
728, Truncate the file if needed to remove the final \n padding that      is just garbage.,1,0,0,1
729, ftruncate() failing is not a critical error.,1,0,0,1
730," Lock the cluster config using flock(), and leaks the file descritor used to  acquire the lock so that the file will be locked forever.",0,0,0,0
731,"This works because we always update nodes.conf with a new version  in-place, reopening the file, and writing to it in place (later adjusting  the length with ftruncate()).",1,0,0,1
732,"On success C_OK is returned, otherwise an error is logged and  the function returns C_ERR to signal a lock was not acquired.",1,0,0,1
733," flock() does not exist on Solaris  and a fcntl-based solution won't help, as we constantly re-open that file,  which will release _all_ locks anyway",1,0,0,1
734," To lock it, we need to open the file in a way it is created if      it does not exist, otherwise there is a race condition with other      processes.",1,0,0,1
735," Lock acquired: leak the 'fd' by not closing it, so that we'll retain the      lock to the file as long as the process exists.",1,0,0,1
736, __sun,0,0,0,0
737," Some flags (currently just the NOFAILOVER flag) may need to be updated  in the ""myself"" node based on the current configuration of the node,  that may change at runtime via CONFIG SET.",1,0,0,1
738,This function changes the  set of flags in myself->flags accordingly.,0,0,0,0
739, Lock the cluster config file to make sure every node uses      its own nodes.conf.,1,0,0,1
740, Load or create a new nodes configuration.,1,0,0,1
741, No configuration found.,0,1,0,1
742,We will just use the random name provided          by the createClusterNode() function.,1,0,0,1
743, We need a listening TCP port for our cluster messaging needs.,0,1,0,1
744, Port sanity check II      The other handshake port check is triggered too late to stop      us from trying to use a too-high cluster port number.,1,0,0,1
745, The slots -> keys map is a radix tree.,0,0,0,0
746,Initialize it here.,0,1,0,1
747," Set myself->port  or  cport to my listening ports, we'll just need to      discover the IP address via MEET messages.",0,0,0,0
748, Reset a node performing a soft or hard reset:   1) All other nodes are forget.,1,0,0,1
749,2) All the assigned  or  open slots are released.,1,0,0,1
750,"3) If the node is a slave, it turns into a master.",0,1,0,1
751,5) Only for hard reset: a new Node ID is generated.,1,1,0,1
752,6) Only for hard reset: currentEpoch and configEpoch are set to 0.,1,0,0,1
753,7) The new configuration is saved and the cluster state updated.,1,1,0,1
754,"8) If the node was a slave, the whole data set is flushed away.",1,1,0,1
755, Turn into master.,0,1,0,1
756," Close slots, reset manual failover state.",0,0,0,0
757, Unassign all the slots.,0,0,0,0
758," Forget all the nodes, but myself.",0,1,0,1
759," Hard reset only: set epochs to 0, change node ID.",1,1,0,1
760," To change the Node ID we need to remove the old name from the          nodes table, change the ID, and re-add back with new name.",1,0,0,1
761, Make sure to persist the new config and update the state.,1,0,0,1
762, -----------------------------------------------------------------------------  CLUSTER communication link  --------------------------------------------------------------------------,0,0,0,0
763," Free a cluster link, but does not free the associated node of course.",1,1,0,1
764,This function will just make sure that the original node associated  with this link will have the 'link' field set to NULL.,1,0,0,1
765," If the server is starting up, don't accept cluster connections:      UPDATE messages may interact with the database content.",1,0,0,1
766, Use non-blocking I or O for cluster messages.,0,1,0,1
767, Create a link object we use to handle the connection.,0,0,0,0
768,It gets passed to the readable handler when data is available.,1,1,0,1
769,"Initiallly the link->node pointer is set to NULL as we don't know          which node is, but the right node is references once we know the          node identity.",1,0,0,1
770, -----------------------------------------------------------------------------  Key space handling  --------------------------------------------------------------------------,1,0,0,1
771, We have 16384 hash slots.,0,1,0,1
772,The hash slot of a given key is obtained  as the least significant 14 bits of the crc16 of the key.,1,0,0,1
773,"However if the key contains the {...} pattern, only the part between  { and } is hashed.",1,0,0,1
774,This may be useful in the future to force certain  keys to be in the same node (assuming no resharding is in progress).,1,0,0,1
775, start-end indexes of { and },0,0,0,0
776, No '{' ?,0,0,0,0
777,Hash the whole key.,1,1,0,1
778,This is the base case.,1,1,0,1
779, '{' found?,0,0,0,0
780,Check if we have the corresponding '}'.,0,0,0,0
781, No '}' or nothing between {} ?,0,0,0,0
782,Hash the whole key.,1,1,0,1
783, If we are here there is both a { and a } on its right.,1,0,0,1
784,Hash      what is in the middle between { and }.,0,0,0,0
785, -----------------------------------------------------------------------------  CLUSTER node API  --------------------------------------------------------------------------,0,0,0,0
786," Create a new cluster node, with the specified flags.",1,1,0,1
787,"If ""nodename"" is NULL this is considered a first handshake and a random  node name is assigned to this node (it will be fixed later when we'll  receive the first pong).",1,0,0,1
788,"The node is created and returned to the user, but it is not automatically  added to the nodes hash table.",0,0,0,0
789, This function is called every time we get a failure report from a node.,1,1,0,1
790,The side effect is to populate the fail_reports list (or to update  the timestamp of an existing report).,0,0,0,0
791,'failing' is the node that is in failure state according to the  'sender' node.,1,0,0,1
792,The function returns 0 if it just updates a timestamp of an existing  failure report from the same sender.,1,0,0,1
793,1 is returned if a new failure  report is created.,1,0,0,1
794," If a failure report from the same sender already exists, just update      the timestamp.",1,0,0,1
795, Otherwise create a new report.,1,0,0,1
796," Remove failure reports that are too old, where too old means reasonably  older than the global node timeout.",1,0,0,1
797,"Note that anyway for a node to be  flagged as FAIL we need to have a local PFAIL state that is at least  older than the global node timeout, so we don't just trust the number  of failure reports from other nodes.",1,0,0,1
798, Remove the failing report for 'node' if it was previously considered  failing by 'sender'.,1,0,0,1
799,This function is called when a node informs us via  gossip that a node is OK from its point of view (no FAIL or PFAIL flags).,1,0,0,1
800,"Note that this function is called relatively often as it gets called even  when there are no nodes failing, and is O(N), however when the cluster is  fine the failure reports list is empty so the function runs in constant  time.",1,0,0,1
801,The function returns 1 if the failure report was found and removed.,1,1,0,1
802,Otherwise 0 is returned.,0,0,0,0
803, Search for a failure report from this sender.,1,1,0,1
804, No failure report from this sender.,1,1,0,1
805, Remove the failure report.,1,1,0,1
806," Return the number of external nodes that believe 'node' is failing,  not including this node, that may have a PFAIL or FAIL state for this  node as well.",1,0,0,1
807," If it's already a slave, don't add it again.",0,1,0,1
808, Low level cleanup of the node structure.,1,1,0,1
809,Only called by clusterDelNode().,1,0,0,1
810," If the node has associated slaves, we have to set      all the slaves->slaveof fields to NULL (unknown).",1,0,0,1
811, Remove this node from the list of slaves of its master.,0,1,0,1
812, Unlink from the set of nodes.,0,0,0,0
813, Release link and associated data structures.,0,1,0,1
814, Add a node to the nodes hash table,0,1,0,1
815, Remove a node from the cluster.,0,1,0,1
816,"The functio performs the high level  cleanup, calling freeClusterNode() for the low level cleanup.",1,0,0,1
817,Here we do the following:   1) Mark all the slots handled by it as unassigned.,1,0,0,1
818,2) Remove all the failure reports sent by this node and referenced by     other nodes.,1,0,0,1
819,"3) Free the node with freeClusterNode() that will in turn remove it     from the hash table and from the list of slaves of its master, if     it is a slave node.",1,0,0,1
820, 1) Mark slots as unassigned.,0,1,0,1
821, 2) Remove failure reports.,1,1,0,1
822," 3) Free the node, unlinking it from the cluster.",1,0,0,1
823, Node lookup by name,0,0,0,0
824, This is only used after the handshake.,1,1,0,1
825,"When we connect a given IP or PORT  as a result of CLUSTER MEET we don't have the node name yet, so we  pick a random one, and will fix it when we receive the PONG request using  this function.",1,0,0,1
826, -----------------------------------------------------------------------------  CLUSTER config epoch handling  --------------------------------------------------------------------------,0,0,0,0
827," Return the greatest configEpoch found in the cluster, or the current  epoch if greater than any node configEpoch.",1,0,0,1
828," If this node epoch is zero or is not already the greatest across the  cluster (from the POV of the local configuration), this function will:   1) Generate a new config epoch, incrementing the current epoch.",1,0,0,1
829,"2) Assign the new epoch to this node, WITHOUT any consensus.",1,1,0,1
830,3) Persist the configuration on disk before sending packets with the     new configuration.,1,0,0,1
831,"If the new config epoch is generated and assigend, C_OK is returned,  otherwise C_ERR is returned (since the node has already the greatest  configuration around) and no operation is performed.",1,0,0,1
832,Important note: this function violates the principle that config epochs  should be generated with consensus and should be unique across the cluster.,1,0,0,1
833,However Redis Cluster uses this auto-generated new config epochs in two  cases:   1) When slots are closed after importing.,1,0,0,1
834,Otherwise resharding would be     too expensive.,1,0,0,1
835,2) When CLUSTER FAILOVER is called with options that force a slave to     failover its master even if there is not master majority able to     create a new configuration epoch.,1,0,0,1
836,"Redis Cluster will not explode using this function, even in the case of  a collision between this node and another node, generating the same  configuration epoch unilaterally, because the config epoch conflict  resolution algorithm will eventually move colliding nodes to different  config epochs.",1,0,0,1
837,"However using this function may violate the ""last failover  wins"" rule, so should only be used with care.",1,0,0,1
838," This function is called when this node is a master, and we receive from  another master a configuration epoch that is equal to our configuration  epoch.",1,0,0,1
839,"BACKGROUND   It is not possible that different slaves get the same config  epoch during a failover election, because the slaves need to get voted  by a majority.",1,0,0,1
840,However when we perform a manual resharding of the cluster  the node will assign a configuration epoch to itself without to ask  for agreement.,0,0,0,0
841,"Usually resharding happens when the cluster is working well  and is supervised by the sysadmin, however it is possible for a failover  to happen exactly while the node we are resharding a slot to assigns itself  a new configuration epoch, but before it is able to propagate it.",1,0,0,1
842,So technically it is possible in this condition that two nodes end with  the same configuration epoch.,1,0,0,1
843,Another possibility is that there are bugs in the implementation causing  this to happen.,0,0,0,0
844,"Moreover when a new cluster is created, all the nodes start with the same  configEpoch.",1,0,0,1
845,This collision resolution code allows nodes to automatically  end with a different configEpoch at startup automatically.,1,0,0,1
846,"In all the cases, we want a mechanism that resolves this issue automatically  as a safeguard.",0,0,0,0
847,"The same configuration epoch for masters serving different  set of slots is not harmful, but it is if the nodes end serving the same  slots for some reason (manual errors or software bugs) without a proper  failover procedure.",1,0,0,1
848,"In general we want a system that eventually always ends with different  masters having different configuration epochs whatever happened, since  nothign is worse than a split-brain condition in a distributed system.",1,0,0,1
849,"BEHAVIOR   When this function gets called, what happens is that if this node  has the lexicographically smaller Node ID compared to the other node  with the conflicting epoch (the 'sender' node), it will assign itself  the greatest configuration epoch currently detected among nodes plus 1.",1,0,0,1
850,"This means that even if there are multiple nodes colliding, the node  with the greatest Node ID never moves forward, so eventually all the nodes  end with a different configuration epoch.",1,0,0,1
851, Prerequisites: nodes have the same configEpoch and are both masters.,1,0,0,1
852, Don't act if the colliding node has a smaller Node ID.,1,1,0,1
853, Get the next ID available at the best of this node knowledge.,1,1,0,1
854, -----------------------------------------------------------------------------  CLUSTER nodes blacklist   The nodes blacklist is just a way to ensure that a given node with a given  Node ID is not readded before some time elapsed (this time is specified  in seconds in CLUSTER_BLACKLIST_TTL).,0,0,0,0
855,"This is useful when we want to remove a node from the cluster completely:  when CLUSTER FORGET is called, it also puts the node into the blacklist so  that even if we receive gossip messages from other nodes that still remember  about the node we want to remove, we don't re-add it before some time.",1,0,0,1
856,"Currently the CLUSTER_BLACKLIST_TTL is set to 1 minute, this means  that redis-trib has 60 seconds to send CLUSTER FORGET messages to nodes  in the cluster without dealing with the problem of other nodes re-adding  back the node to nodes we already sent the FORGET command to.",1,0,0,1
857,"The data structure used is a hash table with an sds string representing  the node ID as key, and the time when it is ok to re-add the node as  value.",1,0,0,1
858, 1 minute.,0,1,0,1
859, Before of the addNode() or Exists() operations we always remove expired  entries from the black list.,1,0,0,1
860,This is an O(N) operation but it is not a  problem since add  or  exists operations are called very infrequently and  the hash table is supposed to contain very little elements at max.,1,0,0,1
861,"However without the cleanup during long uptimes and with some automated  node add or removal procedures, entries could accumulate.",1,0,0,1
862, Cleanup the blacklist and add a new node ID to the black list.,1,1,0,1
863," If the key was added, duplicate the sds string representation of          the key for the next lookup.",1,0,0,1
864,We'll free it at the end.,1,1,0,1
865, Return non-zero if the specified node ID exists in the blacklist.,0,1,0,1
866,"You don't need to pass an sds string here, any pointer to 40 bytes  will work.",0,0,0,0
867, -----------------------------------------------------------------------------  CLUSTER messages exchange - PING or PONG and gossip  --------------------------------------------------------------------------,0,0,0,0
868, This function checks if a given node should be marked as FAIL.,1,1,0,1
869,It happens if the following conditions are met:   1) We received enough failure reports from other master nodes via gossip.,1,0,0,1
870,Enough means that the majority of the masters signaled the node is     down recently.,1,0,0,1
871,2) We believe this node is in PFAIL state.,0,1,0,1
872,If a failure is detected we also inform the whole cluster about this  event trying to force every other node to set the FAIL flag for the node.,1,0,0,1
873,"Note that the form of agreement used here is weak, as we collect the majority  of masters state during some time, and even if we force agreement by  propagating the FAIL message, because of partitions we may not reach every  node.",1,0,0,1
874,However:   1) Either we reach the majority and eventually the FAIL state will propagate     to all the cluster.,1,0,0,1
875,2) Or there is no majority so no slave promotion will be authorized and the     FAIL flag will be cleared after some time.,1,0,0,1
876, We can reach it.,0,1,0,1
877, Already FAILing.,0,0,0,0
878, Also count myself as a voter if I'm a master.,0,0,0,0
879, No weak agreement from masters.,1,1,0,1
880, Mark the node as failing.,0,1,0,1
881," Broadcast the failing node name to everybody, forcing all the other      reachable nodes to flag the node as FAIL.",1,0,0,1
882," This function is called only if a node is marked as FAIL, but we are able  to reach it again.",1,0,0,1
883,It checks if there are the conditions to undo the FAIL  state.,1,0,0,1
884, For slaves we always clear the FAIL flag if we can contact the      node again.,1,0,0,1
885, If it is a master and...      1) The FAIL state is old enough.,1,0,0,1
886,2) It is yet serving slots from our point of view (not failed over).,1,1,0,1
887,"Apparently no one is going to fix these slots, clear the FAIL flag.",1,1,0,1
888, Return true if we already have a node in HANDSHAKE state matching the  specified ip address and port number.,1,0,0,1
889,This function is used in order to  avoid adding a new handshake node for the same address multiple times.,1,0,0,1
890, Start an handshake with the specified address if there is not one  already in progress.,0,0,0,0
891,Returns non-zero if the handshake was actually  started.,1,0,0,1
892,On error zero is returned and errno is set to one of the  following values:   EAGAIN - There is already an handshake in progress for this address.,1,0,0,1
893,EINVAL - IP or port are not valid.,0,1,0,1
894, IP sanity check,0,1,0,1
895, Port sanity check,0,1,0,1
896, Set norm_ip as the normalized string representation of the node      IP address.,0,0,0,0
897, Add the node with a random address (NULL as first argument to      createClusterNode()).,1,0,0,1
898,Everything will be fixed during the      handshake.,1,0,0,1
899, Process the gossip section of PING or PONG packets.,0,1,0,1
900,"Note that this function assumes that the packet is already sanity-checked  by the caller, not in the content of the gossip section, but in the  length.",0,0,0,0
901, Update our state accordingly to the gossip sections,0,1,0,1
902, We already know this node.,0,1,0,1
903,"Handle failure reports, only when the sender is a master.",1,1,0,1
904," If from our POV the node is up (no failure flags are set),              we have no pending ping for the node, nor we have failure              reports for this node, update the last pong time with the              one we see from the other nodes.",1,0,0,1
905, Convert back to milliseconds.,0,1,0,1
906, Replace the pong time with the received one only if                  it's greater than our view but is not in the future                  (with 500 milliseconds tolerance) from the POV of our                  clock.,1,0,0,1
907," If we already know this node, but it is not reachable, and              we see a different address in the gossip section of a node that              can talk with this other node, update the address, disconnect              the old link if any, so that we'll attempt to connect with the              new address.",1,0,0,1
908," If it's not in NOADDR state and we don't have it, we              start a handshake process against this IP or PORT pairs.",0,0,0,0
909,"Note that we require that the sender of this gossip message              is a well known node in our cluster, otherwise we risk              joining another cluster.",0,0,0,0
910, Next node,0,1,0,1
911, IP -> string conversion.,0,1,0,1
912,'buf' is supposed to at least be 46 bytes.,1,0,0,1
913,"If 'announced_ip' length is non-zero, it is used instead of extracting  the IP from the socket peer address.",0,0,0,0
914, We are not sure the input is sane.,1,1,0,1
915," Update the node address to the IP address that can be extracted  from link->fd, or if hdr->myip is non empty, to the address the node  is announcing us.",1,0,0,1
916,The port is taken from the packet header as well.,0,0,0,0
917,"If the address or port changed, disconnect the node link so that we'll  connect again to the new address.",1,0,0,1
918,If the ip or port pair are already correct no operation is performed at  all.,0,0,0,0
919,"The function returns 0 if the node address is still the same,  otherwise 1 is returned.",1,0,0,1
920," We don't proceed if the link is the same as the sender link, as this      function is designed to see if the node link is consistent with the      symmetric link that is used to receive PINGs from the node.",1,0,0,1
921,"As a side effect this function never frees the passed 'link', so      it is safe to call during packet processing.",1,0,0,1
922," IP  or  port is different, update it.",1,0,0,1
923, Check if this is our master and we have to change the      replication target as well.,0,0,0,0
924, Reconfigure the specified node 'n' as a master.,0,1,0,1
925,This function is called when  a node that we believed to be a slave is now acting as master in order to  update the state of the node.,0,0,0,0
926, Update config and state.,0,0,0,0
927," This function is called when we receive a master configuration via a  PING, PONG or UPDATE packet.",0,0,0,0
928,"What we receive is a node, a configEpoch of the  node, and the set of slots claimed under this configEpoch.",0,0,0,0
929,"What we do is to rebind the slots with newer configuration compared to our  local configuration, and if needed, we turn ourself into a replica of the  node (see the function comments for more info).",1,0,0,1
930,The 'sender' is the node for which we received a configuration update.,0,1,0,1
931,"Sometimes it is not actually the ""Sender"" of the information, like in the  case we receive the info via an UPDATE packet.",1,0,0,1
932, The dirty slots list is a list of slots for which we lose the ownership      while having still keys inside.,1,0,0,1
933,This usually happens after a failover      or after a manual cluster reconfiguration operated by the admin.,1,0,0,1
934,"If the update message is not able to demote a master to slave (in this      case we'll resync with the master updating the whole key space), we      need to delete all the keys in the slots we lost ownership.",1,0,0,1
935, Here we set curmaster to this node or the node this node      replicates to if it's a slave.,0,0,0,0
936,In the for loop we are      interested to check if slots are taken away from curmaster.,1,0,0,1
937, The slot is already bound to the sender of this message.,0,1,0,1
938," The slot is in importing state, it should be modified only              manually via redis-trib (example: a resharding is in progress              and the migrating side slot was already closed and is advertising              a new config.",1,0,0,1
939,We still want the slot to be closed manually).,1,0,0,1
940, We rebind the slot to the new node claiming it if:              1) The slot was unassigned or the new node claims it with a                 greater configEpoch.,1,0,0,1
941,2) We are not currently importing the slot.,1,1,0,1
942," Was this slot mine, and still contains keys?",0,1,0,1
943,Mark it as                  a dirty slot.,1,0,0,1
944," If at least one slot was reassigned from a node to another node      with a greater configEpoch, it is possible that:      1) We are a master left without slots.",1,0,0,1
945,This means that we were         failed over and we should turn into a replica of the new         master.,1,0,0,1
946,2) We are a slave and our master is left without slots.,0,1,0,1
947,We need         to replicate to the new slots owner.,1,0,0,1
948," If we are here, we received an update message which removed          ownership for certain slots we still have keys about, but still          we are serving some slots, so this master node was not demoted to          a slave.",1,0,0,1
949,In order to maintain a consistent state between keys and slots          we need to remove all the keys from the slots we lost.,1,0,0,1
950," When this function is called, there is a packet to process starting  at node->rcvbuf.",1,0,0,1
951,"Releasing the buffer is up to the caller, so this  function should just handle the higher level stuff of processing the  packet, modifying the cluster state if needed.",1,0,0,1
952,"The function returns 1 if the link is still valid after the packet  was processed, otherwise 0 if the link was freed since the packet  processing lead to some inconsistency error (for instance a PONG  received from the wrong sender ID).",1,0,0,1
953, Perform sanity checks,0,1,0,1
954," At least signature, version, totlen, count.",1,0,0,1
955, Can't handle messages of different versions.,1,1,0,1
956, expected length of this packet,1,0,0,1
957, Check if the sender is a known node.,0,1,0,1
958, Update our curretEpoch if we see a newer epoch in the cluster.,0,0,0,0
959, Update the sender configEpoch if it is publishing a newer one.,0,0,0,0
960, Update the replication offset info for this node.,0,1,0,1
961," If we are a slave performing a manual failover and our master          sent its offset while already paused, populate the MF state.",0,0,0,0
962, Initial processing of PING and MEET requests replying with a PONG.,0,1,0,1
963," We use incoming MEET messages in order to set the address          for 'myself', since only other cluster nodes will send us          MEET messages on handshakes, when the cluster joins, or          later if we changed address, and those nodes will use our          official address to connect to us.",1,0,0,1
964,So by obtaining this address          from the socket is a simple way to discover  or  update our own          address in the cluster without it being hardcoded in the config.,1,0,0,1
965,"However if we don't have an address at all, we update the address          even with a normal PING packet.",1,0,0,1
966,If it's wrong it will be fixed          by MEET later.,1,0,0,1
967, Add this node if it is new for us and the msg type is MEET.,1,0,0,1
968,"In this stage we don't try to add the node with the right          flags, slaveof pointer, and so forth, as this details will be          resolved when we'll receive PONGs from the node.",1,0,0,1
969," If this is a MEET packet from an unknown node, we still process          the gossip section here since we have to trust the sender because          of the message type.",1,0,0,1
970, Anyway reply with a PONG,0,1,0,1
971," PING, PONG, MEET: process config information.",0,0,0,0
972," If we already have this node, try to change the                  IP or port of the node with the new one.",1,0,0,1
973, Free this node as we already have it.,1,1,0,1
974,This will                      cause the link to be freed as well.,0,0,0,0
975, First thing to do is replacing the random name with the                  right node name if this was a handshake stage.,1,0,0,1
976, If the reply has a non matching node ID we                  disconnect this node and set it as not having an associated                  address.,0,0,0,0
977, Copy the CLUSTER_NODE_NOFAILOVER flag from what the sender          announced.,0,0,0,0
978,"This is a dynamic flag that we receive from the          sender, and the latest status must be trusted.",1,0,0,1
979,"We need it to          be propagated because the slave ranking used to understand the          delay of each slave in the voting process, needs to know          what are the instances really competing.",1,0,0,1
980, Update the node address if it changed.,0,1,0,1
981, Update our info about the node,0,1,0,1
982," The PFAIL condition can be reversed without external              help if it is momentary (that is, if it does not              turn into a FAIL state).",1,0,0,1
983,The FAIL condition is also reversible under specific              conditions detected by clearNodeFailureIfNeeded().,1,0,0,1
984, Check for role switch: slave -> master or master -> slave.,0,1,0,1
985, Node is a master.,0,1,0,1
986, Node is a slave.,0,1,0,1
987, Master turned into a slave!,0,1,0,1
988,Reconfigure the node.,0,1,0,1
989, Update config and state.,0,0,0,0
990, Master node changed for this slave?,0,1,0,1
991, Update config.,0,0,0,0
992, Update our info about served slots.,0,1,0,1
993,Note: this MUST happen after we update the master or slave state          so that CLUSTER_NODE_MASTER flag will be set.,0,0,0,0
994, Many checks are only needed if the set of served slots this          instance claims is different compared to the set of slots we have          for it.,1,0,0,1
995,Check this ASAP to avoid other computational expansive          checks later.,1,0,0,1
996, Sender or its master if slave.,0,1,0,1
997, Sender claimed slots don't match my view?,0,1,0,1
998," 1) If the sender of the message is a master, and we detected that             the set of slots it claims changed, scan the slots to see if we             need to update our configuration.",0,0,0,0
999," 2) We also check for the reverse condition, that is, the sender             claims to serve slots we know are served by a master with a             greater configEpoch.",1,0,0,1
1000,If this happens we inform the sender.,0,0,0,0
1001,"This is useful because sometimes after a partition heals, a          reappearing master may be the last one to claim a given set of          hash slots, but with a configuration that other instances know to          be deprecated.",1,0,0,1
1002,"Example:                   A and B are master and slave for slots 1,2,3.",0,0,0,0
1003,"A is partitioned away, B gets promoted.",0,1,0,1
1004,"B is partitioned away, and A returns available.",1,0,0,1
1005,"Usually B would PING A publishing its set of served slots and its          configEpoch, but because of the partition B can't inform A of the          new configuration, so other nodes that have an updated table must          do it.",1,0,0,1
1006,In this way A will stop to act as a master (or can try to          failover if there are the conditions to win the election).,1,0,0,1
1007, TODO: instead of exiting the loop send every other                          UPDATE packet for other nodes that are the new owner                          of sender's slots.,1,0,0,1
1008, If our config epoch collides with the sender's try to fix          the problem.,0,0,0,0
1009, Get info from the gossip section,0,1,0,1
1010, Don't bother creating useless objects if there are no          Pub or Sub subscribers.,1,0,0,1
1011, We don't know that node.,0,1,0,1
1012, We don't know that node.,0,1,0,1
1013," We consider this vote only if the sender is a master serving          a non zero number of slots, and its currentEpoch is greater or          equal to epoch where this node started the election.",1,0,0,1
1014," Maybe we reached a quorum here, set a flag to make sure              we check ASAP.",1,0,0,1
1015, This message is acceptable only if I'm a master and the sender          is one of my slaves.,1,0,0,1
1016, Manual failover requested from slaves.,0,0,0,0
1017,Initialize the state          accordingly.,0,0,0,0
1018, The node the update is about.,0,1,0,1
1019, We don't know the sender.,0,1,0,1
1020, We don't know the reported node.,0,1,0,1
1021, Nothing new.,1,1,0,1
1022," If in our current config the node is a slave, set it as a master.",1,0,0,1
1023, Update the node's configEpoch.,0,0,0,0
1024, Check the bitmap of served slots and update our          config accordingly.,0,0,0,0
1025, Protect the module from unknown nodes.,1,1,0,1
1026, We need to route this message back to the right module subscribed          for the right message type.,1,0,0,1
1027, Endian-safe ID,0,0,0,0
1028, This function is called when we detect the link with this node is lost.,0,1,0,1
1029,We set the node as no longer connected.,0,1,0,1
1030,The Cluster Cron will detect   this connection and will try to get it connected again.,0,0,0,0
1031,"Instead if the node is a temporary node used to accept a query, we   completely free the node on error.",1,0,0,1
1032, Send data.,0,1,0,1
1033,This is handled using a trivial send buffer that gets  consumed by write().,0,0,0,0
1034,We don't try to optimize this for speed too much  as this is a very low traffic channel.,1,0,0,1
1035, Read data.,0,1,0,1
1036,Try to read the first field of the header first to check the  full length of the packet.,1,0,0,1
1037,When a whole packet is in memory this function  will call the function to process the packet.,1,0,0,1
1038,And so forth.,0,1,0,1
1039, Read as long as there is data to read.,1,1,0,1
1040," First, obtain the first 8 bytes to get the full message              length.",1,0,0,1
1041, Finally read the full message.,1,0,0,1
1042, Perform some sanity check on the message signature                  and length.,0,0,0,0
1043, No more data ready.,1,1,0,1
1044, I or O error...,0,1,0,1
1045, Read data and recast the pointer to the new buffer.,1,1,0,1
1046, Total length obtained?,1,1,0,1
1047,Process this packet.,0,1,0,1
1048, Link no longer valid.,0,1,0,1
1049, Put stuff into the send buffer.,0,0,0,0
1050,"It is guaranteed that this function will never have as a side effect  the link to be invalidated, so it is safe to call this function  from event handlers that will do stuff with the same link later.",1,0,0,1
1051, Populate sent messages stats.,0,1,0,1
1052, Send a message to all the nodes that are part of the cluster having  a connected link.,0,0,0,0
1053,"It is guaranteed that this function will never have as a side effect  some node->link to be invalidated, so it is safe to call this function  from event handlers that will do stuff with node links later.",1,0,0,1
1054, Build the message header.,0,1,0,1
1055,hdr must point to a buffer at least  sizeof(clusterMsg) in bytes.,1,0,0,1
1056," If this node is a master, we send its slots bitmap and configEpoch.",0,0,0,0
1057,If this node is a slave we send the master's information instead (the      node is flagged as slave so the receiver knows that it is NOT really      in charge for this slots.,1,0,0,1
1058," If cluster-announce-ip option is enabled, force the receivers of our      packets to use the specified address for this node.",0,0,0,0
1059,"Otherwise if the      first byte is zero, they'll do auto discovery.",1,0,0,1
1060, Handle cluster-announce-port as well.,0,1,0,1
1061, Set the currentEpoch and configEpochs.,0,0,0,0
1062, Set the replication offset.,0,1,0,1
1063, Set the message flags.,0,1,0,1
1064, Compute the message length for certain messages.,1,1,0,1
1065,For other messages      this is up to the caller.,1,0,0,1
1066," For PING, PONG, and MEET, fixing the totlen field is up to the caller.",0,0,0,0
1067, Return non zero if the node is already present in the gossip section of the  message pointed by 'hdr' and having 'count' gossip entries.,0,0,0,0
1068,Otherwise  zero is returned.,0,0,0,0
1069,Helper for clusterSendPing().,0,0,0,0
1070, Set the i-th entry of the gossip section in the message pointed by 'hdr'  to the info of the specified node 'n'.,0,0,0,0
1071," Send a PING or PONG packet to the specified node, making sure to add enough  gossip informations.",1,0,0,1
1072, Number of gossip sections added so far.,1,1,0,1
1073, Number of gossip sections we want to append if possible.,1,1,0,1
1074, Total packet length.,1,1,0,1
1075, freshnodes is the max number of nodes we can hope to append at all:      nodes available minus two (ourself and the node we are sending the      message to).,1,0,0,1
1076,"However practically there may be less valid nodes since      nodes in handshake state, disconnected, are not considered.",1,0,0,1
1077, How many gossip sections we want to add?,1,1,0,1
1078,1 or 10 of the number of nodes      and anyway at least 3.,1,0,0,1
1079,Why 1 or 10?,0,1,0,1
1080,"If we have N masters, with N or 10 entries, and we consider that in      node_timeout we exchange with each other node at least 4 packets      (we ping in the worst case in node_timeout or 2 time, and we also      receive two pings from the host), we have a total of 8 packets      in the node_timeout2 falure reports validity time.",1,0,0,1
1081,"So we have      that, for a single PFAIL node, we can expect to receive the following      number of failure reports (in the specified window of time):           PROB  GOSSIP_ENTRIES_PER_PACKET  TOTAL_PACKETS:           PROB = probability of being featured in a single gossip entry,             which is 1  or  NUM_OF_NODES.",1,0,0,1
1082,ENTRIES = 10.,0,1,0,1
1083,TOTAL_PACKETS = 2  4  NUM_OF_MASTERS.,0,0,0,0
1084,"If we assume we have just masters (so num of nodes and num of masters      is the same), with 1 or 10 we always get over the majority, and specifically      80% of the number of nodes, to account for many masters failing at the      same time.",1,0,0,1
1085,"Since we have non-voting slaves that lower the probability of an entry      to feature our node, we set the number of entires per packet as      10% of the total nodes we have.",1,0,0,1
1086," Include all the nodes in PFAIL state, so that failure reports are      faster to propagate to go from PFAIL to FAIL state.",1,0,0,1
1087, Compute the maxium totlen to allocate our buffer.,0,0,0,0
1088,We'll fix the totlen      later according to the number of gossip sections we really were able      to put inside the packet.,1,0,0,1
1089, Note: clusterBuildMessageHdr() expects the buffer to be always at least      sizeof(clusterMsg) or more.,1,0,0,1
1090, Populate the header.,0,1,0,1
1091, Populate the gossip fields,0,1,0,1
1092," Don't include this node: the whole packet header is about us          already, so we just gossip about other nodes.",1,0,0,1
1093, PFAIL nodes will be added later.,0,1,0,1
1094, In the gossip section don't include:          1) Nodes in HANDSHAKE state.,0,0,0,0
1095,3) Nodes with the NOADDR flag set.,0,1,0,1
1096,4) Disconnected nodes if they don't have configured slots.,0,1,0,1
1097," Tecnically not correct, but saves CPU.",0,0,0,0
1098, Do not add a node we already have.,0,1,0,1
1099, Add it,0,1,0,1
1100," If there are PFAIL nodes, add them at the end.",0,1,0,1
1101," We take the count of the slots we allocated, since the              PFAIL stats may not match perfectly with the current number              of PFAIL nodes.",1,0,0,1
1102, Ready to send... fix the totlen fiend and queue the message in the      output buffer.,1,0,0,1
1103, Send a PONG packet to every connected node that's not in handshake state  and for which we have a valid link.,0,0,0,0
1104,"In Redis Cluster pongs are not used just for failure detection, but also  to carry important configuration information.",1,0,0,1
1105,So broadcasting a pong is  useful when something changes in the configuration and we want to make  the cluster aware ASAP (for instance after a slave promotion).,1,0,0,1
1106,The 'target' argument specifies the receiving instances using the  defines below:   CLUSTER_BROADCAST_ALL -> All known instances.,0,0,0,0
1107,CLUSTER_BROADCAST_LOCAL_SLAVES -> All slaves in my master-slaves ring.,0,1,0,1
1108, Send a PUBLISH message.,0,0,0,0
1109,"If link is NULL, then the message is broadcasted to the whole cluster.",1,0,0,1
1110, Try to use the local buffer if possible,1,1,0,1
1111, Send a FAIL message to all the nodes we are able to contact.,1,1,0,1
1112,The FAIL message is sent when we detect that a node is failing  (CLUSTER_NODE_PFAIL) and we also receive a gossip confirmation of this:  we switch the node state to CLUSTER_NODE_FAIL and ask all the other  nodes to do the same ASAP.,1,0,0,1
1113, Send an UPDATE message to the specified link carrying the specified 'node'  slots configuration.,0,0,0,0
1114,"The node name, slots bitmap, and configEpoch info  are included.",0,0,0,0
1115, Send a MODULE message.,0,1,0,1
1116,"If link is NULL, then the message is broadcasted to the whole cluster.",1,0,0,1
1117, Already endian adjusted.,0,0,0,0
1118, Try to use the local buffer if possible,1,1,0,1
1119," This function gets a cluster node ID string as target, the same way the nodes  addresses are represented in the modules side, resolves the node, and sends  the message.",1,0,0,1
1120,If the target is NULL the message is broadcasted.,0,0,0,0
1121,"The function returns C_OK if the target is valid, otherwise C_ERR is  returned.",0,0,0,0
1122," -----------------------------------------------------------------------------  CLUSTER Pub or Sub support   For now we do very little, just propagating PUBLISH messages across the whole  cluster.",1,0,0,1
1123,In the future we'll try to get smarter and avoiding propagating those  messages to hosts without receives for a given channel.,1,0,0,1
1124, -----------------------------------------------------------------------------  SLAVE node specific functions  --------------------------------------------------------------------------,1,0,0,1
1125, This function sends a FAILOVE_AUTH_REQUEST message to every node in order to  see if there is the quorum for this slave instance to failover its failing  master.,0,0,0,0
1126,"Note that we send the failover request to everybody, master and slave nodes,  but only the masters are supposed to reply to our query.",1,0,0,1
1127," If this is a manual failover, set the CLUSTERMSG_FLAG0_FORCEACK bit      in the header to communicate the nodes receiving the message that      they should authorized the failover even if the master is working.",0,0,0,0
1128, Send a FAILOVER_AUTH_ACK message to the specified node.,0,1,0,1
1129, Send a MFSTART message to the specified node.,0,1,0,1
1130, Vote for the node asking for our vote if there are the conditions.,0,1,0,1
1131," IF we are not a master serving at least 1 slot, we don't have the      right to vote, as the cluster size in Redis Cluster is the number      of masters serving at least one slot, and quorum is the cluster      size + 1",1,0,0,1
1132, Request epoch must be >= our currentEpoch.,0,0,0,0
1133,"Note that it is impossible for it to actually be greater since      our currentEpoch was updated as a side effect of receiving this      request, if the request epoch was greater.",1,0,0,1
1134, I already voted for this epoch?,0,1,0,1
1135,Return ASAP.,0,1,0,1
1136, Node must be a slave and its master down.,1,1,0,1
1137,The master can be non failing if the request is flagged      with CLUSTERMSG_FLAG0_FORCEACK (manual failover).,0,0,0,0
1138, We did not voted for a slave about this master for two      times the node timeout.,0,0,0,0
1139,This is not strictly needed for correctness      of the algorithm but makes the base case more linear.,1,0,0,1
1140, The slave requesting the vote must have a configEpoch for the claimed      slots that is >= the one of the masters currently serving the same      slots in the current configuration.,1,0,0,1
1141, If we reached this point we found a slot that in our current slots          is served by a master with a greater configEpoch than the one claimed          by the slave requesting our vote.,1,0,0,1
1142,Refuse to vote for this slave.,0,1,0,1
1143, We can vote for this slave.,0,1,0,1
1144," This function returns the ""rank"" of this instance, a slave, in the context  of its master-slaves ring.",1,0,0,1
1145,"The rank of the slave is given by the number of  other slaves for the same master that have a better replication offset  compared to the local one (better means, greater, so they claim more data).",1,0,0,1
1146,"A slave with rank 0 is the one with the greatest (most up to date)  replication offset, and so forth.",1,0,0,1
1147,"Note that because how the rank is computed  multiple slaves may have the same rank, in case they have the same offset.",1,0,0,1
1148,The slave rank is used to add a delay to start an election in order to  get voted and replace a failing master.,1,0,0,1
1149,Slaves with better replication  offsets are more likely to win.,1,0,0,1
1150, Never called by slaves without master.,0,1,0,1
1151, This function is called by clusterHandleSlaveFailover() in order to  let the slave log why it is not able to failover.,1,0,0,1
1152,"Sometimes there are  not the conditions, but since the failover function is called again and  again, we can't log the same things continuously.",1,0,0,1
1153,This function works by logging only if a given set of conditions are  true:   1) The reason for which the failover can't be initiated changed.,1,0,0,1
1154,The reasons also include a NONE reason we reset the state to     when the slave finds that its master is fine (no FAIL flag).,1,0,0,1
1155,"2) Also, the log is emitted again if the master is still down and     the reason for not failing over is still the same, but more than     CLUSTER_CANT_FAILOVER_RELOG_PERIOD seconds elapsed.",1,0,0,1
1156,"3) Finally, the function only logs if the slave is down for more than     five seconds + NODE_TIMEOUT.",1,0,0,1
1157,This way nothing is logged when a     failover starts in a reasonable time.,1,0,0,1
1158,The function is called with the reason why the slave can't failover  which is one of the integer macros CLUSTER_CANT_FAILOVER_.,0,0,0,0
1159,The function is guaranteed to be called only if 'myself' is a slave.,1,1,0,1
1160, Don't log if we have the same reason for some time.,1,1,0,1
1161," We also don't emit any log if the master failed no long ago, the      goal of this function is to log slaves in a stalled condition for      a long time.",1,0,0,1
1162," This function implements the final part of automatic and manual failovers,  where the slave grabs its master's hash slots, and propagates the new  configuration.",1,0,0,1
1163,Note that it's up to the caller to be sure that the node got a new  configuration epoch already.,1,0,0,1
1164, 1) Turn this node into a master.,0,1,0,1
1165, 2) Claim all the slots assigned to our master.,0,1,0,1
1166, 3) Update state and save config.,0,0,0,0
1167, 4) Pong all the other nodes so that they can update the state         accordingly and detect that we switched to master role.,1,0,0,1
1168," 5) If there was a manual failover in progress, clear the state.",1,0,0,1
1169, This function is called if we are a slave node and our master serving  a non-zero amount of hash slots is in FAIL state.,1,0,0,1
1170,"The gaol of this function is:  1) To check if we are able to perform a failover, is our data updated?",1,0,0,1
1171,2) Try to get elected by masters.,0,1,0,1
1172,3) Perform the failover informing all the other nodes.,1,0,0,1
1173," Compute the failover timeout (the max time we have to send votes      and wait for replies), and the failover retry time (the time to wait      before trying to get voted again).",0,0,0,0
1174,"Timeout is MAX(NODE_TIMEOUT2,2000) milliseconds.",0,1,0,1
1175,Retry is two times the Timeout.,0,1,0,1
1176," Pre conditions to run the function, that must be met both in case      of an automatic or manual failover:      1) We are a slave.",0,0,0,0
1177,"2) Our master is flagged as FAIL, or this is a manual failover.",1,0,0,1
1178,"3) We don't have the no failover configuration set, and this is         not a manual failover.",0,0,0,0
1179,4) It is serving slots.,0,1,0,1
1180," There are no reasons to failover, so we set the reason why we          are returning without failing over to NONE.",0,0,0,0
1181, Set data_age to the number of seconds we are disconnected from      the master.,0,0,0,0
1182," Remove the node timeout from the data age as it is fine that we are      disconnected from our master at least for the time it was down to be      flagged as FAIL, that's the baseline.",1,0,0,1
1183, Check if our data is recent enough according to the slave validity      factor configured by the user.,1,0,0,1
1184,Check bypassed for manual failovers.,0,0,0,0
1185," If the previous failover attempt timedout and the retry time has      elapsed, we can setup a new one.",1,0,0,1
1186," Fixed delay of 500 milliseconds, let FAIL msg propagate.",1,0,0,1
1187, Random delay between 0 and 500 milliseconds.,1,1,0,1
1188, We add another delay that is proportional to the slave rank.,1,1,0,1
1189,Specifically 1 second  rank.,1,0,0,1
1190,"This way slaves that have a probably          less updated replication offset, are penalized.",1,0,0,1
1191," However if this is a manual failover, no delay is needed.",0,0,0,0
1192," Now that we have a scheduled election, broadcast our offset          to all the other slaves so that they'll updated their offsets          if our offset is better.",1,0,0,1
1193, It is possible that we received more updated offsets from other      slaves for the same master since we computed our election delay.,1,0,0,1
1194,Update the delay if our rank changed.,1,1,0,1
1195,Not performed if this is a manual failover.,0,0,0,0
1196, Return ASAP if we can't still start the election.,0,1,0,1
1197, Return ASAP if the election is too old to be valid.,1,1,0,1
1198, Ask for votes if needed.,0,1,0,1
1199, Wait for replies.,0,1,0,1
1200, Check if we reached the quorum.,0,1,0,1
1201," We have the quorum, we can finally failover the master.",1,0,0,1
1202, Update my configEpoch to the epoch of the election.,0,0,0,0
1203, Take responsability for the cluster slots.,0,0,0,0
1204," -----------------------------------------------------------------------------  CLUSTER slave migration   Slave migration is the process that allows a slave of a master that is  already covered by at least another slave, to ""migrate"" to a master that  is orpaned, that is, left with no working slaves.",1,0,0,1
1205, This function is responsible to decide if this replica should be migrated  to a different (orphaned) master.,1,0,0,1
1206,It is called by the clusterCron() function  only if:   1) We are a slave node.,1,0,0,1
1207,2) It was detected that there is at least one orphaned master in     the cluster.,1,0,0,1
1208,3) We are a slave of one of the masters with the greatest number of     slaves.,1,0,0,1
1209,"This checks are performed by the caller since it requires to iterate  the nodes anyway, so we spend time into clusterHandleSlaveMigration()  if definitely needed.",1,0,0,1
1210,"The fuction is called with a pre-computed max_slaves, that is the max  number of working (not in FAIL state) slaves for a single master.",1,0,0,1
1211,Additional conditions for migration are examined inside the function.,0,1,0,1
1212, Step 1: Don't migrate if the cluster state is not ok.,1,0,0,1
1213, Step 2: Don't migrate if my master will not be left with at least              'migration-barrier' slaves after my migration.,1,0,0,1
1214," Step 3: Idenitfy a candidate for migration, and check if among the      masters with the greatest number of ok slaves, I'm the one with the      smallest node ID (the ""candidate slave"").",1,0,0,1
1215,"Note: this means that eventually a replica migration will occurr      since slaves that are reachable again always have their FAIL flag      cleared, so eventually there must be a candidate.",1,0,0,1
1216,"At the same time      this does not mean that there are no race conditions possible (two      slaves migrating at the same time), but this is unlikely to      happen, and harmless when happens.",1,0,0,1
1217," We want to migrate only if this master is working, orphaned, and          used to have slaves or if failed over a master that had slaves          (MIGRATE_TO flag).",1,0,0,1
1218,This way we only migrate to instances that were          supposed to have replicas.,1,0,0,1
1219, Check number of working slaves.,0,1,0,1
1220, Track the starting time of the orphaned condition for this              master.,1,0,0,1
1221, Check if I'm the slave candidate for the migration: attached          to a master with the maximum number of slaves and with the smallest          node ID.,0,0,0,0
1222," Step 4: perform the migration if there is a target, and if I'm the      candidate, but only if the master is continuously orphaned for a      couple of seconds, so that during failovers, we give some time to      the natural slaves of this instance to advertise their switch from      the old master to the new one.",1,0,0,1
1223, -----------------------------------------------------------------------------  CLUSTER manual failover   This are the important steps performed by slaves during a manual failover:  1) User send CLUSTER FAILOVER command.,1,0,0,1
1224,The failover state is initialized     setting mf_end to the millisecond unix time at which we'll abort the     attempt.,0,0,0,0
1225,2) Slave sends a MFSTART message to the master requesting to pause clients     for two times the manual failover timeout CLUSTER_MF_TIMEOUT.,0,0,0,0
1226,"When master is paused for manual failover, it also starts to flag     packets with CLUSTERMSG_FLAG0_PAUSED.",0,0,0,0
1227,3) Slave waits for master to send its replication offset flagged as PAUSED.,0,1,0,1
1228,"4) If slave received the offset from the master, and its offset matches,     mf_can_start is set to 1, and clusterHandleSlaveFailover() will perform     the failover as usually, with the difference that the vote request     will be modified to force masters to vote for a slave that has a     working master.",1,0,0,1
1229,From the point of view of the master things are simpler: when a  PAUSE_CLIENTS packet is received the master sets mf_end as well and  the sender in mf_slave.,0,0,0,0
1230,"During the time limit for the manual failover  the master will just send PINGs more often to this slave, flagged with  the PAUSED flag, so that the slave will set mf_master_offset when receiving  a packet from the master with this flag set.",1,0,0,1
1231,The gaol of the manual failover is to perform a fast failover without  data loss due to the asynchronous master-slave replication.,1,0,0,1
1232, Reset the manual failover state.,0,0,0,0
1233,This works for both masters and slavesa  as all the state about manual failover is cleared.,0,0,0,0
1234,The function can be used both to initialize the manual failover state at  startup or to abort a manual failover in progress.,0,0,0,0
1235, Just use the side effect of the function.,0,1,0,1
1236, No manual failover in progress.,0,0,0,0
1237," If a manual failover timed out, abort it.",0,0,0,0
1238, This function is called from the cluster cron function in order to go  forward with a manual failover state machine.,0,0,0,0
1239, Return ASAP if no manual failover is in progress.,0,0,0,0
1240," If mf_can_start is non-zero, the failover was already triggered so the      next steps are performed by clusterHandleSlaveFailover().",0,0,0,0
1241, Wait for offset...,0,1,0,1
1242, Our replication offset matches the master replication offset          announced after clients were paused.,0,0,0,0
1243,We can start the failover.,0,0,0,0
1244, -----------------------------------------------------------------------------  CLUSTER cron job  --------------------------------------------------------------------------,0,0,0,0
1245, This is executed 10 times every second,0,1,0,1
1246, How many masters there are without ok slaves.,1,0,0,1
1247, Max number of ok slaves for a single master.,1,0,0,1
1248, Number of ok slaves for our master (if we are slave).,1,0,0,1
1249, Number of times this function was called so far.,1,1,0,1
1250, We want to take myself->ip in sync with the cluster-announce-ip option.,0,0,0,0
1251,"The option can be set at runtime via CONFIG SET, so we periodically check      if the option changed to reflect this into myself->ip.",0,0,0,0
1252, Force autodetection.,0,0,0,0
1253, The handshake timeout is the time after which a handshake node that was      not turned into a normal node is removed from the nodes.,1,0,0,1
1254,"Usually it is      just the NODE_TIMEOUT value, but when NODE_TIMEOUT is too small we use      the value of 1 second.",1,0,0,1
1255, Update myself flags.,0,1,0,1
1256, Check if we have disconnected nodes and re-establish the connection.,0,1,0,1
1257,"Also update a few stats while we are here, that can be used to make      better decisions in other part of the code.",1,0,0,1
1258, Not interested in reconnecting the link with myself or nodes          for which we have no address.,1,0,0,1
1259, A Node in HANDSHAKE state has a limited lifespan equal to the          configured node timeout.,1,0,0,1
1260, We got a synchronous error from connect before                  clusterSendPing() had a chance to be called.,0,0,0,0
1261,"If node->ping_sent is zero, failure detection can't work,                  so we claim we actually sent a ping now (that will                  be really sent as soon as the link is obtained).",1,0,0,1
1262, Queue a PING in the new connection ASAP: this is crucial              to avoid false positives in failure detection.,1,0,0,1
1263,"If the node is flagged as MEET, we send a MEET message instead              of a PING one, to force the receiver to add us in its node              table.",0,0,0,0
1264," If there was an active ping before the link was                  disconnected, we want to restore the ping time, otherwise                  replaced by the clusterSendPing() call.",1,0,0,1
1265, We can clear the flag after the first packet is sent.,1,1,0,1
1266,"If we'll never receive a PONG, we'll never send new packets              to this node.",1,0,0,1
1267,"Instead after the PONG is received and we              are no longer in meet or handshake status, we want to send              normal PING packets.",1,0,0,1
1268," Ping some random node 1 time every 10 iterations, so that we usually ping      one random node every second.",1,0,0,1
1269, Check a few random nodes and ping the one with the oldest          pong_received time.,1,0,0,1
1270, Don't ping nodes disconnected or with a ping currently active.,1,1,0,1
1271, Iterate nodes to check if we need to flag something as failing.,0,1,0,1
1272,This loop is also responsible to:      1) Check if there are orphaned masters (masters without non failing         slaves).,1,0,0,1
1273,2) Count the max number of non failing slaves for a single master.,1,1,0,1
1274,"3) Count the number of slaves for our master, if we are a slave.",0,1,0,1
1275, Use an updated time at every iteration.,0,1,0,1
1276," Orphaned master check, useful only if the current instance          is a slave that may migrate to another master.",1,0,0,1
1277," A master is orphaned if it is serving a non-zero number of              slots, have no working slaves, but used to have at least one              slave, or failed over a master that used to have slaves.",1,0,0,1
1278," If we are waiting for the PONG more than half the cluster          timeout, reconnect the link: maybe there is a connection          issue even if the node is alive.",1,0,0,1
1279, is connected,0,0,0,0
1280, was not already reconnected,0,0,0,0
1281, we already sent a ping,0,0,0,0
1282, still waiting pong,0,0,0,0
1283, and we are waiting for the pong more than timeout or 2,1,0,0,1
1284," Disconnect the link, it will be reconnected automatically.",0,1,0,1
1285," If we have currently no active ping in this instance, and the          received PONG is older than half the cluster timeout, send          a new ping now, to ensure all the nodes are pinged without          a too big delay.",1,0,0,1
1286," If we are a master and one of the slaves requested a manual          failover, ping it continuously.",0,0,0,0
1287, Check only if we have an active ping for this instance.,1,1,0,1
1288, Compute the delay of the PONG.,0,1,0,1
1289,"Note that if we already received          the PONG, then node->ping_sent is zero, so can't reach this          code at all.",0,0,0,0
1290, Timeout reached.,0,1,0,1
1291,Set the node as possibly failing if it is              not already in this state.,1,0,0,1
1292," If we are a slave node but the replication is still turned off,      enable it if we know the address of our master and it appears to      be up.",0,0,0,0
1293, Abourt a manual failover if the timeout is reached.,0,0,0,0
1294," If there are orphaned slaves, and we are a slave among the masters          with the max number of non-failing slaves, consider migrating to          the orphaned masters.",0,0,0,0
1295,Note that it does not make sense to try          a migration if there is no master with at least two working          slaves.,1,0,0,1
1296, This function is called before the event handler returns to sleep for  events.,0,0,0,0
1297,"It is useful to perform operations that must be done ASAP in  reaction to events fired but that are not safe to perform inside event  handlers, or to perform potentially expansive tasks that we need to do  a single time before replying to clients.",1,0,0,1
1298," Handle failover, this is needed when it is likely that there is already      the quorum from masters in order to react fast.",1,0,0,1
1299, Update the cluster state.,0,1,0,1
1300," Save the config, possibly using fsync.",1,0,0,1
1301, Reset our flags (not strictly needed since every single function      called for flags set should be able to clear its flag).,1,0,0,1
1302, -----------------------------------------------------------------------------  Slots management  --------------------------------------------------------------------------,0,0,0,0
1303, Test bit 'pos' in a generic bitmap.,0,0,0,0
1304,"Return 1 if the bit is set,  otherwise 0.",0,0,0,0
1305, Set the bit at position 'pos' in a bitmap.,0,0,0,0
1306, Clear the bit at position 'pos' in a bitmap.,1,0,0,1
1307, Return non-zero if there is at least one master with slaves in the cluster.,1,1,0,1
1308,Otherwise zero is returned.,0,0,0,0
1309,Used by clusterNodeSetSlotBit() to set the  MIGRATE_TO flag the when a master gets the first slot.,1,0,0,1
1310, Set the slot bit and return the old value.,1,1,0,1
1311," When a master gets its first slot, even if it has no slaves,          it gets flagged with MIGRATE_TO, that is, the master is a valid          target for replicas migration, if and only if at least one of          the other masters has slaves right now.",1,0,0,1
1312,Normally masters are valid targerts of replica migration if:          1.,1,0,0,1
1313,The used to have slaves (but no longer have).,0,1,0,1
1314,They are slaves failing over a master that used to have slaves.,0,1,0,1
1315,However new masters with slots assigned are considered valid          migration tagets if the rest of the cluster is not a slave-less.,1,0,0,1
1316,See https: or  or github.com or antirez or redis or issues or 3043 for more info.,1,0,0,1
1317, Clear the slot bit and return the old value.,1,1,0,1
1318, Return the slot bit from the cluster node structure.,0,1,0,1
1319, Add the specified slot to the list of slots that node 'n' will  serve.,0,0,0,0
1320,Return C_OK if the operation ended with success.,1,1,0,1
1321,If the slot is already assigned to another instance this is considered  an error and C_ERR is returned.,0,0,0,0
1322, Delete the specified slot marking it as unassigned.,0,1,0,1
1323,"Returns C_OK if the slot was assigned, otherwise if the slot was  already unassigned C_ERR is returned.",0,0,0,0
1324, Delete all the slots associated with the specified node.,0,1,0,1
1325,The number of deleted slots is returned.,0,1,0,1
1326, Clear the migrating  or  importing state for all the slots.,1,0,0,1
1327,This is useful at initialization and when turning a master into slave.,1,1,0,1
1328, -----------------------------------------------------------------------------  Cluster state evaluation function  --------------------------------------------------------------------------,0,0,0,0
1329, The following are defines that are only used in the evaluation function  and are based on heuristics.,1,0,0,1
1330,Actaully the main point about the rejoin and  writable delay is that they should be a few orders of magnitude larger  than the network latency.,1,0,0,1
1331," If this is a master node, wait some time before turning the state      into OK, since it is not a good idea to rejoin the cluster as a writable      master, after a reboot, without giving the cluster a chance to      reconfigure this node.",1,0,0,1
1332,"Note that the delay is calculated starting from      the first call to this function and not since the server start, in order      to don't count the DB loading time.",1,0,0,1
1333, Start assuming the state is OK. We'll turn it into FAIL if there      are the right conditions.,1,0,0,1
1334, Check if all the slots are covered.,0,1,0,1
1335," Compute the cluster size, that is the number of master nodes      serving at least a single slot.",1,0,0,1
1336,At the same time count the number of reachable masters having      at least one slot.,1,0,0,1
1337," If we are in a minority partition, change the cluster state      to FAIL.",1,0,0,1
1338, Log a state change,0,1,0,1
1339," If the instance is a master and was partitioned away with the          minority, don't let it accept queries for some time after the          partition heals, to make sure there is enough time to receive          a configuration update.",1,0,0,1
1340, Change the state and log the event.,0,1,0,1
1341," This function is called after the node startup in order to verify that data  loaded from disk is in agreement with the cluster configuration:   1) If we find keys about hash slots we have no responsibility for, the     following happens:     A) If no other node is in charge according to the current cluster        configuration, we add these slots to our node.",1,0,0,1
1342,"B) If according to our config other nodes are already in charge for        this lots, we set the slots as IMPORTING from our point of view        in order to justify we have those slots, and in order to make        redis-trib aware of the issue, so that it can try to fix it.",1,0,0,1
1343,2) If we find data in a DB different than DB0 we return C_ERR to     signal the caller it should quit the server with an error message     or take other actions.,1,0,0,1
1344,"The function always returns C_OK even if it will try to correct  the error described in ""1"".",0,0,0,0
1345,"However if data is found in DB different  from DB0, C_ERR is returned.",1,0,0,1
1346,The function also uses the logging facility in order to warn the user  about desynchronizations between the data we have in memory and the  cluster configuration.,0,0,0,0
1347," If this node is a slave, don't perform the check at all as we      completely depend on the replication stream.",1,0,0,1
1348, Make sure we only have keys in DB0.,1,1,0,1
1349, Check that all the slots we see populated memory have a corresponding      entry in the cluster table.,0,0,0,0
1350,Otherwise fix the table.,0,0,0,0
1351, No keys in this slot.,0,1,0,1
1352, Check if we are assigned to this slot or if we are importing it.,0,1,0,1
1353,In both cases check the next slot as the configuration makes          sense.,0,0,0,0
1354," If we are here data and cluster config don't agree, and we have          slot 'j' populated even if we are not importing it, nor we are          assigned to this slot.",0,0,0,0
1355,Fix this condition.,0,1,0,1
1356, Case A: slot is unassigned.,0,1,0,1
1357,Take responsibility for it.,0,1,0,1
1358, -----------------------------------------------------------------------------  SLAVE nodes handling  --------------------------------------------------------------------------,0,0,0,0
1359, Set the specified node 'n' as master for this node.,0,1,0,1
1360,"If this node is currently a master, it is turned into a slave.",1,1,0,1
1361, -----------------------------------------------------------------------------  Nodes to string representation functions.,0,0,0,0
1362, Concatenate the comma separated list of node flags to the given SDS  string 'ci'.,0,0,0,0
1363," If no flag was added, add the ""noflags"" special flag.",1,0,0,1
1364, Remove trailing comma.,0,1,0,1
1365, Generate a csv-alike representation of the specified cluster node.,0,0,0,0
1366,See clusterGenNodesDescription() top comment for more information.,1,0,0,1
1367,The function returns the string representation as an SDS string.,0,1,0,1
1368, Node coordinates,0,1,0,1
1369, Flags,0,1,0,1
1370," Slave of... or just ""-""",0,0,0,0
1371," Latency from the POV of this node, config epoch, link status",0,0,0,0
1372, Slots served by this instance,0,1,0,1
1373, Just for MYSELF node we also dump info about slots that      we are migrating to other instances or importing from other      instances.,1,0,0,1
1374," Generate a csv-alike representation of the nodes we are aware of,  including the ""myself"" node, and return an SDS string containing the  representation (it is up to the caller to free it).",1,0,0,1
1375,"All the nodes matching at least one of the node flags specified in  ""filter"" are excluded from the output, so using zero as a filter will  include all the known nodes in the representation, including nodes in  the HANDSHAKE state.",1,0,0,1
1376,"The representation obtained using this function is used for the output  of the CLUSTER NODES function, and as format for the cluster  configuration file (nodes.conf) for a given node.",0,0,0,0
1377, -----------------------------------------------------------------------------  CLUSTER command  --------------------------------------------------------------------------,0,0,0,0
1378, Format: 1) 1) start slot                 2) end slot                 3) 1) master IP                    2) master port                    3) node ID                 4) 1) replica IP                    2) replica port                    3) node ID                ... continued until done,0,0,0,0
1379, Skip slaves (that are iterated when producing the output of their          master) and  masters not serving any slot.,0,0,0,0
1380, slots (2) + master addr (1).,0,0,0,0
1381," If slot exists in output map, add to it's list.",0,0,0,0
1382,"else, create a new output map for this slot",1,0,0,1
1383, only one slot; low==high,1,0,0,1
1384, low,1,0,0,1
1385, high,1,0,0,1
1386, First node reply position is always the master,1,1,0,1
1387, Remaining nodes in reply are replicas for slot range,0,1,0,1
1388, This loop is copy or pasted from clusterGenNodeDescription()                      with modifications for per-slot node aggregation,0,0,0,0
1389, CLUSTER MEET <ip> <port> [cport],0,0,0,0
1390, CLUSTER NODES,0,1,0,1
1391, CLUSTER MYID,0,1,0,1
1392, CLUSTER SLOTS,0,1,0,1
1393, CLUSTER FLUSHSLOTS,0,1,0,1
1394, CLUSTER ADDSLOTS <slot> [slot] ...,0,1,0,1
1395, CLUSTER DELSLOTS <slot> [slot] ...,0,1,0,1
1396, Check that all the arguments are parseable and that all the          slots are not already busy.,1,0,0,1
1397, If this slot was set as importing we can clear this                  state as now we are the real owner of the slot.,1,0,0,1
1398, SETSLOT 10 MIGRATING <node ID>,0,1,0,1
1399, SETSLOT 10 IMPORTING <node ID>,0,1,0,1
1400, SETSLOT 10 STABLE,0,1,0,1
1401, SETSLOT 10 NODE <node ID>,0,1,0,1
1402, CLUSTER SETSLOT <SLOT> STABLE,0,1,0,1
1403, CLUSTER SETSLOT <SLOT> NODE <NODE ID>,0,1,0,1
1404, If this hash slot was served by 'myself' before to switch              make sure there are no longer local keys for this hash slot.,1,0,0,1
1405, If this slot is in migrating status but we have no keys              for it assigning the slot to another node will clear              the migratig status.,1,0,0,1
1406," If this node was importing this slot, assigning the slot to              itself also clears the importing status.",0,0,0,0
1407," This slot was manually migrated, set this node configEpoch                  to a new epoch so that the new version can be propagated                  by the cluster.",1,0,0,1
1408,"Note that if this ever results in a collision with another                  node getting the same configEpoch, for example because a                  failover happens at the same time we close the slot, the                  configEpoch collision resolution will fix it assigning                  a different epoch to each node.",1,0,0,1
1409, CLUSTER BUMPEPOCH,0,1,0,1
1410, CLUSTER INFO,0,1,0,1
1411, Show stats about messages sent and received.,0,1,0,1
1412, Produce the reply protocol.,0,1,0,1
1413, CLUSTER KEYSLOT <key>,0,1,0,1
1414, CLUSTER COUNTKEYSINSLOT <slot>,0,1,0,1
1415, CLUSTER GETKEYSINSLOT <slot> <count>,0,1,0,1
1416, Avoid allocating more than needed in case of large COUNT argument          and smaller actual number of keys.,1,0,0,1
1417, CLUSTER FORGET <NODE ID>,0,1,0,1
1418, CLUSTER REPLICATE <NODE ID>,0,1,0,1
1419, Lookup the specified node in our table.,0,0,0,0
1420, I can't replicate myself.,0,1,0,1
1421, Can't replicate a slave.,0,1,0,1
1422," If the instance is currently a master, it should have no assigned          slots nor keys to accept to replicate some other node.",1,0,0,1
1423,Slaves can switch to another master without issues.,0,1,0,1
1424, Set the master.,0,1,0,1
1425, CLUSTER SLAVES <NODE ID>,0,1,0,1
1426, Lookup the specified node in our table.,0,0,0,0
1427, CLUSTER COUNT-FAILURE-REPORTS <NODE ID>,0,1,0,1
1428, CLUSTER FAILOVER [FORCE|TAKEOVER],0,1,0,1
1429, Takeover also implies force.,0,1,0,1
1430, Check preconditions.,0,1,0,1
1431, A takeover does not perform any initial check.,0,1,0,1
1432,"It just              generates a new configuration epoch for this node without              consensus, claims the master's slots, and broadcast the new              configuration.",1,0,0,1
1433," If this is a forced failover, we don't need to talk with our              master to agree about the offset.",1,0,0,1
1434,We just failover taking over              it without coordination.,0,0,0,0
1435," CLUSTER SET-CONFIG-EPOCH <epoch>                   The user is allowed to set the config epoch only when a node is          totally fresh: no config epoch, no other known node, and so forth.",1,0,0,1
1436,"This happens at cluster creation time to start with a cluster where          every node has a different node ID, without to rely on the conflicts          resolution system which is too slow when a big cluster is created.",1,0,0,1
1437," No need to fsync the config here since in the unlucky event              of a failure to persist the config, the conflict resolution code              will assign an unique config to this node.",1,0,0,1
1438, CLUSTER RESET [SOFT|HARD],0,1,0,1
1439, Parse soft or hard argument.,1,1,0,1
1440,Default is soft.,1,1,0,1
1441," Slaves can be reset while containing data, but not master nodes          that must be empty.",1,0,0,1
1442," -----------------------------------------------------------------------------  DUMP, RESTORE and MIGRATE commands  --------------------------------------------------------------------------",0,0,0,0
1443," Generates a DUMP-format representation of the object 'o', adding it to the  io stream pointed by 'rio'.",0,0,0,0
1444,This function can't fail.,1,1,0,1
1445, Serialize the object in a RDB-like format.,0,1,0,1
1446,It consist of an object type      byte followed by the serialized object.,0,0,0,0
1447,This is understood by RESTORE.,0,1,0,1
1448," Write the footer, this is how it looks like:      ----------------+---------------------+---------------+      ... RDB payload | 2 bytes RDB version | 8 bytes CRC64 |      ----------------+---------------------+---------------+      RDB version and CRC are both in little endian.",1,0,0,1
1449, RDB version,0,1,0,1
1450, CRC64,0,1,0,1
1451, Verify that the RDB version of the dump payload matches the one of this Redis  instance and that the checksum is ok.,1,0,0,1
1452,"If the DUMP payload looks valid C_OK is returned, otherwise C_ERR  is returned.",0,0,0,0
1453, At least 2 bytes of RDB version and 8 of CRC64 should be present.,1,1,0,1
1454, Verify RDB version,0,1,0,1
1455, Verify CRC64,0,1,0,1
1456, DUMP keyname  DUMP is actually not used by Redis Cluster but it is the obvious  complement of RESTORE and can be useful for different applications.,1,0,0,1
1457, Check if the key is here.,1,1,0,1
1458, Create the DUMP encoded representation.,0,1,0,1
1459, Transfer to the client,0,1,0,1
1460, RESTORE key ttl serialized-value [REPLACE],1,0,0,1
1461, Parse additional options,0,1,0,1
1462, Make sure this key does not already exist here...,1,1,0,1
1463, Check if the TTL value makes sense,0,1,0,1
1464, Verify RDB version and data checksum.,0,0,0,0
1465, Remove the old key if needed.,1,1,0,1
1466, Create the key and set the TTL if any,1,1,0,1
1467, MIGRATE socket cache implementation.,0,1,0,1
1468,We take a map between host:ip and a TCP socket that we used to connect  to this instance in recent time.,1,0,0,1
1469,"This sockets are closed when the max number we cache is reached, and also  in serverCron() when they are around for more than a few seconds.",1,0,0,1
1470, max num of items in the cache.,0,0,0,0
1471, close cached sockets after 10 sec.,1,0,0,1
1472," Return a migrateCachedSocket containing a TCP socket connected with the  target instance, possibly returning a cached one.",1,0,0,1
1473,This function is responsible of sending errors to the client if a  connection can't be established.,1,0,0,1
1474,In this case -1 is returned.,0,1,0,1
1475,"Otherwise on success the socket is returned, and the caller should not  attempt to free it after usage.",1,0,0,1
1476,"If the caller detects an error while using the socket, migrateCloseSocket()  should be called so that the connection will be created from scratch  the next time.",0,0,0,0
1477, Check if we have an already cached socket for this ip:port pair.,0,0,0,0
1478," No cached socket, create one.",0,1,0,1
1479," Too many items, drop one at random.",1,1,0,1
1480, Create the socket,0,1,0,1
1481, Check if it connects within the specified timeout.,0,1,0,1
1482, Add to the cache and return it to the caller.,0,1,0,1
1483, Free a migrate cached connection.,1,0,0,1
1484," MIGRATE host port key dbid timeout [COPY | REPLACE | AUTH password]   On in the multiple keys form:   MIGRATE host port """" dbid timeout [COPY | REPLACE | AUTH password] KEYS key1  key2 ... keyN",1,0,0,1
1485, Objects to migrate.,0,1,0,1
1486, Key names.,1,1,0,1
1487, Used to rewrite the command as DEL ... keys ...,0,1,0,1
1488, To support the KEYS option we need the following additional state.,1,1,0,1
1489, Argument index of the first key.,1,1,0,1
1490, By default only migrate the 'key' argument.,1,0,0,1
1491, Parse additional options,0,1,0,1
1492, All the remaining args are keys.,0,0,0,0
1493, Sanity check,0,1,0,1
1494, Check if the keys are here.,0,1,0,1
1495,"If at least one key is to migrate, do it      otherwise if all the keys are missing reply with ""NOKEY"" to signal      the caller there was nothing to migrate.",1,0,0,1
1496,"We don't return an error in      this case, since often this is due to a normal condition like the key      expiring in the meantime.",1,0,0,1
1497, Connect,0,1,0,1
1498, error sent to the client by migrateGetSocket(),0,0,0,0
1499, Authentication,0,1,0,1
1500, Send the SELECT command if the current DB is not already selected.,1,1,0,1
1501, Should we emit SELECT?,0,1,0,1
1502, Create RESTORE payload and generate the protocol to call the command.,0,1,0,1
1503," Emit the payload argument, that is the serialized object using          the DUMP format.",0,0,0,0
1504, Add the REPLACE option to the RESTORE command if it was specified          as a MIGRATE option.,0,0,0,0
1505, Transfer the query to the other node in 64K chunks.,1,1,0,1
1506, Auth reply.,0,0,0,0
1507, Select reply.,0,1,0,1
1508, Restore reply.,0,1,0,1
1509, Read the AUTH reply if needed.,0,1,0,1
1510, Read the SELECT reply if needed.,0,1,0,1
1511, Read the RESTORE replies.,0,0,0,0
1512, Index of the key argument for the replicated DEL op.,1,1,0,1
1513, On error assume that last_dbid is no longer valid.,0,0,0,0
1514," No COPY option: remove the local key, signal the change.",1,1,0,1
1515, Populate the argument vector to replace the old one.,1,1,0,1
1516," On socket error, if we want to retry, do it now before rewriting the      command vector.",0,0,0,0
1517,We only retry if we are sure nothing was processed      and we failed to read the first reply (j == 0 test).,1,0,0,1
1518, A retry is guaranteed because of tested conditions.,0,0,0,0
1519," On socket errors, close the migration socket now that we still have      the original host or port in the ARGV.",1,0,0,1
1520,Later the original command may be      rewritten to DEL and will be too later.,1,0,0,1
1521, Translate MIGRATE as DEL for replication or AOF.,0,1,0,1
1522,"Note that we do          this only for the keys for which we received an acknowledgement          from the receiving Redis server, by using the del_idx index.",1,0,0,1
1523, Note that the following call takes ownership of newargv.,1,0,0,1
1524," No key transfer acknowledged, no need to rewrite as DEL.",1,1,0,1
1525, Make it safe to call zfree() on it in the future.,1,0,0,1
1526," If we are here and a socket error happened, we don't want to retry.",0,1,0,1
1527,"Just signal the problem to the client, but only do it if we did not      already queue a different error reported by the destination server.",1,0,0,1
1528, Success!,1,1,0,1
1529,"Update the last_dbid in migrateCachedSocket, so that we can          avoid SELECT the next time if the target DB is the same.",1,0,0,1
1530,Reply +OK.,1,1,0,1
1531,"Note: If we reached this point, even if socket_error is true          still the SELECT command succeeded (otherwise the code jumps to          socket_err label.",1,0,0,1
1532," On error we already sent it in the for loop above, and set          the currently selected socket to -1 to force SELECT the next time.",1,0,0,1
1533, On socket errors we try to close the cached socket and try again.,0,1,0,1
1534,"It is very common for the cached socket to get closed, if just reopening  it works it's a shame to notify the error to the caller.",1,0,0,1
1535, Cleanup we want to perform in both the retry and no retry case.,0,0,0,0
1536,Note: Closing the migrate socket will also force SELECT next time.,0,0,0,0
1537," If the command was rewritten as DEL and there was a socket error,      we already closed the socket earlier.",1,0,0,1
1538,"While migrateCloseSocket()      is idempotent, the host or port arguments are now gone, so don't do it      again.",0,0,0,0
1539, This will get reallocated on retry.,0,1,0,1
1540, Retry only if it's not a timeout and we never attempted a retry      (or the code jumping here did not set may_retry to zero).,1,0,0,1
1541, Cleanup we want to do if no retry is attempted.,0,1,0,1
1542, -----------------------------------------------------------------------------  Cluster functions related to serving  or  redirecting clients  --------------------------------------------------------------------------,1,0,0,1
1543, The ASKING command is required after a -ASK redirection.,0,1,0,1
1544,The client should issue ASKING before to actually send the command to  the target instance.,1,0,0,1
1545,See the Redis Cluster specification for more  information.,1,0,0,1
1546, The READONLY command is used by clients to enter the read-only mode.,0,1,0,1
1547,In this mode slaves will not redirect clients as long as clients access  with read-only commands to keys that are served by the slave's master.,1,0,0,1
1548, The READWRITE command just clears the READONLY command state.,0,1,0,1
1549, Return the pointer to the cluster node that is able to serve the command.,1,1,0,1
1550,For the function to succeed the command should only target either:   1) A single key (even multiple times like LPOPRPUSH mylist mylist).,1,0,0,1
1551,"2) Multiple keys in the same hash slot, while the slot is stable (no     resharding in progress).",1,0,0,1
1552,On success the function returns the node that is able to serve the request.,1,1,0,1
1553,If the node is not 'myself' a redirection must be perfomed.,0,0,0,0
1554,"The kind of  redirection is specified setting the integer passed by reference  'error_code', which will be set to CLUSTER_REDIR_ASK or  CLUSTER_REDIR_MOVED.",1,0,0,1
1555,When the node is 'myself' 'error_code' is set to CLUSTER_REDIR_NONE.,0,0,0,0
1556,"If the command fails NULL is returned, and the reason of the failure is  provided via 'error_code', which will be set to:   CLUSTER_REDIR_CROSS_SLOT if the request contains multiple keys that  don't belong to the same hash slot.",1,0,0,1
1557,"CLUSTER_REDIR_UNSTABLE if the request contains multiple keys  belonging to the same slot, but the slot is not stable (in migration or  importing state, likely because a resharding is in progress).",1,0,0,1
1558,CLUSTER_REDIR_DOWN_UNBOUND if the request addresses a slot which is  not bound to any node.,0,0,0,0
1559,"In this case the cluster global state should be  already ""down"" but it is fragile to rely on the update of the global state,  so we also handle it here.",1,0,0,1
1560,CLUSTER_REDIR_DOWN_STATE if the cluster is down but the user attempts to  execute a command that addresses one or more keys.,1,0,0,1
1561, Set error code optimistically for the base case.,1,1,0,1
1562," We handle all the cases as if they were EXEC commands, so we have      a common code path for everything",1,0,0,1
1563, If CLIENT_MULTI flag is not set EXEC is just going to return an          error.,0,0,0,0
1564," In order to have a single codepath create a fake Multi State          structure if the client is not in MULTI or EXEC state, this way          we have a single codepath below.",1,0,0,1
1565," Check that all the keys are in the same hash slot, and obtain this      slot and the node associated.",1,0,0,1
1566, This is the first key we see.,1,1,0,1
1567,Check what is the slot                  and node.,0,0,0,0
1568," Error: If a slot is not served, we are in ""cluster down""                  state.",1,0,0,1
1569,"However the state is yet to be updated, so this was                  not trapped earlier in processCommand().",1,0,0,1
1570,Report the same                  error to the client.,1,0,0,1
1571," If we are migrating or importing this slot, we need to check                  if we have all the keys in the request (the only way we                  can safely serve the request, otherwise we return a TRYAGAIN                  error).",1,0,0,1
1572,To do so we set the importing or migrating state and                  increment a counter for every missing key.,1,0,0,1
1573," If it is not the first key, make sure it is exactly                  the same key as the first we saw.",1,0,0,1
1574, Error: multiple keys from different slots.,1,1,0,1
1575, Flag this request as one with multiple different                          keys.,1,0,0,1
1576, Migarting  or  Improrting slot?,0,0,0,0
1577,Count keys we don't have.,0,1,0,1
1578, No key at all in command?,1,1,0,1
1579,then we can serve the request      without redirections or errors in all the cases.,0,0,0,0
1580, Cluster is globally down but we got keys?,1,1,0,1
1581,We can't serve the request.,0,1,0,1
1582, Return the hashslot by reference.,0,0,0,0
1583, MIGRATE always works in the context of the local node if the slot      is open (migrating or importing state).,1,0,0,1
1584,We need to be able to freely      move keys among instances in this case.,1,0,0,1
1585," If we don't have all the keys and we are migrating the slot, send      an ASK redirection.",0,0,0,0
1586," If we are receiving the slot, and the client correctly flagged the      request as ""ASKING"", we can serve the request.",0,0,0,0
1587,"However if the request      involves multiple keys and we don't have them all, the only option is      to send a TRYAGAIN error.",1,0,0,1
1588," Handle the read-only client case reading from a slave: if this      node is a slave and the request is about an hash slot our master      is serving, we can reply without redirection.",0,0,0,0
1589, Base case: just return the right node.,1,1,0,1
1590,"However if this node is not      myself, set error_code to MOVED since we need to issue a rediretion.",0,0,0,0
1591," Send the client the right redirection code, according to error_code  that should be set to one of CLUSTER_REDIR_ macros.",1,0,0,1
1592,"If CLUSTER_REDIR_ASK or CLUSTER_REDIR_MOVED error codes  are used, then the node 'n' should not be NULL, but should be the  node we want to mention in the redirection.",0,0,0,0
1593,Moreover hashslot should  be set to the hash slot that caused the redirection.,0,0,0,0
1594," The request spawns mutliple keys in the same slot,          but the slot is not ""stable"" currently as there is          a migration or import in progress.",1,0,0,1
1595," This function is called by the function processing clients incrementally  to detect timeouts, in order to handle the following case:   1) A client blocks with BLPOP or similar blocking operation.",1,0,0,1
1596,2) The master migrates the hash slot elsewhere or turns into a slave.,0,1,0,1
1597,3) The client may remain blocked forever (or up to the max timeout time)     waiting for a key change that will never happen.,1,0,0,1
1598,"If the client is found to be blocked into an hash slot this node no  longer handles, the client is sent a redirection error, and the function  returns 1.",0,0,0,0
1599,Otherwise 0 is returned and no operation is performed.,0,0,0,0
1600," If the cluster is down, unblock the client with the right error.",1,1,0,1
1601," All keys must belong to the same slot, so check first key only.",1,1,0,1
1602," We send an error and unblock the client if:              1) The slot is unassigned, emitting a cluster down error.",1,0,0,1
1603,"2) The slot is not handled by this node, nor being imported.",0,1,0,1
1604,#NAME?,0,0,0,0
1605, Output buffer limits presets.,0,1,0,1
1606, normal,1,0,0,1
1607, slave,0,0,0,0
1608, pubsub,0,0,0,0
1609,-----------------------------------------------------------------------------  Enum access functions ----------------------------------------------------------------------------,0,0,0,0
1610, Get enum value from name.,0,0,0,0
1611,If there is no match INT_MIN is returned.,0,0,0,0
1612, Get enum name from value.,0,0,0,0
1613,If no match is found NULL is returned.,0,0,0,0
1614," Wrapper for configEnumGetName() returning ""unknown"" insetad of NULL if  there is no match.",1,0,0,1
1615, Used for INFO generation.,0,1,0,1
1616,-----------------------------------------------------------------------------  Config file parsing ----------------------------------------------------------------------------,0,0,0,0
1617, Skip comments and blank lines,0,1,0,1
1618, Split into arguments,0,1,0,1
1619, Skip this line if the resulting command vector is empty.,1,1,0,1
1620, Execute config directives,0,0,0,0
1621, Test if we are able to open the file.,1,1,0,1
1622,The server will not                  be able to abort just for this problem later...,1,0,0,1
1623, DEAD OPTION,1,1,0,1
1624, DEAD OPTION,1,1,0,1
1625, If the target command name is the empty string we just              remove it from the command table.,1,0,0,1
1626, Otherwise we re-add the command under a different name.,1,0,0,1
1627, argc == 1 is handled by main() as we need to enter the sentinel              mode ASAP.,1,0,0,1
1628, Sanity checks.,0,1,0,1
1629, Load the server configuration from the specified filename.,0,0,0,0
1630,The function appends the additional configuration directives stored  in the 'options' string to the config file before loading.,0,0,0,0
1631,"Both filename and options can be NULL, in such a case are considered  empty.",1,0,0,1
1632,This way loadServerConfig can be used to just load a file or  just load a string.,0,0,0,0
1633, Load the file content,0,1,0,1
1634, Append the additional options,0,1,0,1
1635,-----------------------------------------------------------------------------  CONFIG SET implementation ----------------------------------------------------------------------------,0,0,0,0
1636, this starts the config_set macros else-if chain.,0,0,0,0
1637, Special fields that can't be handled with general macros.,1,1,0,1
1638, Try to check if the OS is capable of supporting so many FDs.,1,0,0,1
1639," Perform sanity check before setting the new config:          - Even number of args          - Seconds >= 1, changes >= 0",1,0,0,1
1640, Finally set the new config,1,0,0,1
1641, We need a multiple of 4: <class> <hard> <soft> <soft_seconds>,0,0,0,0
1642," Sanity check of single arguments, so that we either refuse the          whole configuration string or accept it all, even if a single          error in a single client class is present.",1,0,0,1
1643, Finally set the new config,1,0,0,1
1644, Boolean fields.,0,1,0,1
1645,"config_set_bool_field(name,var).",0,0,0,0
1646, Numerical fields.,0,1,0,1
1647,"config_set_numerical_field(name,var,min,max)",0,0,0,0
1648, Cast to unsigned.,0,1,0,1
1649," Hz is more an hint from the user, so we accept values out of range          but cap them to reasonable values.",1,0,0,1
1650, Memory fields.,0,1,0,1
1651,"config_set_memory_field(name,var)",0,0,0,0
1652, Enumeration fields.,0,1,0,1
1653,"config_set_enum_field(name,var,enum_var)",0,0,0,0
1654, Everyhing else is an error...,0,0,0,0
1655, On success we just return a generic OK for all the options.,1,1,0,1
1656, Bad format errors,1,1,0,1
1657,-----------------------------------------------------------------------------  CONFIG GET implementation ----------------------------------------------------------------------------,0,0,0,0
1658, String values,0,1,0,1
1659, Numerical values,0,1,0,1
1660, Bool (yes or no) values,0,0,0,0
1661, Enum values,0,0,0,0
1662, Everything we can't handle with macros follows.,0,1,0,1
1663,-----------------------------------------------------------------------------  CONFIG REWRITE implementation ----------------------------------------------------------------------------,0,0,0,0
1664," We use the following dictionary type to store where a configuration  option is mentioned in the old configuration file, so it's  like ""maxmemory"" -> list of line numbers (first line is zero).",1,0,0,1
1665, Sentinel config rewriting is implemented inside sentinel.c by  rewriteConfigSentinelOption().,0,0,0,0
1666, hash function,0,0,0,0
1667, key dup,1,0,0,1
1668, val dup,0,0,0,0
1669, key compare,1,0,0,1
1670, key destructor,1,0,0,1
1671, val destructor,0,0,0,0
1672, hash function,0,0,0,0
1673, key dup,1,0,0,1
1674, val dup,0,0,0,0
1675, key compare,1,0,0,1
1676, key destructor,1,0,0,1
1677, val destructor,0,0,0,0
1678, The config rewrite state.,0,0,0,0
1679, Option -> list of config file lines map,0,0,0,0
1680, Dictionary of already processed options,0,1,0,1
1681, Number of lines in current config,1,0,0,1
1682, Current lines as an array of sds strings,1,0,0,1
1683, True if we already added directives that were                             not present in the original config file.,1,0,0,1
1684, Append the new line to the current configuration state.,1,1,0,1
1685, Populate the option -> list of line numbers map.,0,1,0,1
1686, Add the specified option to the set of processed options.,0,1,0,1
1687,"This is useful as only unused lines of processed options will be blanked  in the config file, while options the rewrite process does not understand  remain untouched.",1,0,0,1
1688," Read the old file, split it into lines to populate a newly created  config rewrite state, and return it to the caller.",1,0,0,1
1689,"If it is impossible to read the old file, NULL is returned.",1,1,0,1
1690,"If the old file does not exist at all, an empty state is returned.",1,1,0,1
1691," Read the old file line by line, populate the state.",1,1,0,1
1692," Zero based, so we init at -1",0,0,0,0
1693, Handle comments and empty lines.,1,1,0,1
1694," Not a comment, split into arguments.",0,1,0,1
1695," Apparently the line is unparsable for some reason, for              instance it may have unbalanced quotes.",1,0,0,1
1696,Load it as a              comment.,0,0,0,0
1697, We only want lowercase config directives.,1,0,0,1
1698, Now we populate the state according to the content of this line.,0,1,0,1
1699,Append the line and populate the option -> line numbers map.,0,1,0,1
1700," Rewrite the specified configuration option with the new ""line"".",1,0,0,1
1701,"It progressively uses lines of the file that were already used for the same  configuration option in the old version of the file, removing that line from  the map of options -> line numbers.",1,0,0,1
1702,"If there are lines associated with a given configuration option and  ""force"" is non-zero, the line is appended to the configuration file.",0,0,0,0
1703,"Usually ""force"" is true when an option has not its default value, so it  must be rewritten even if not present previously.",1,0,0,1
1704,"The first time a line is appended into a configuration file, a comment  is added to show that starting from that point the config file was generated  by CONFIG REWRITE.",1,0,0,1
1705,"""line"" is either used, or freed, so the caller does not need to free it  in any way.",1,0,0,1
1706," Option not used previously, and we are not forced to use it.",1,1,0,1
1707, There are still lines in the old configuration file we can reuse          for this option.,1,0,0,1
1708,Replace the line with the new one.,1,1,0,1
1709, Append a new line.,1,1,0,1
1710, Write the long long 'bytes' value as a string in a way that is parsable  inside redis.conf.,1,0,0,1
1711,"If possible uses the GB, MB, KB notation.",1,1,0,1
1712," Rewrite a simple ""option-name <bytes>"" configuration option.",1,0,0,1
1713, Rewrite a yes or no option.,0,1,0,1
1714, Rewrite a string option.,0,1,0,1
1715, String options set to NULL need to be not present at all in the      configuration file to be set to NULL again at the next reboot.,0,0,0,0
1716, Set force to zero if the value is set to its default.,0,1,0,1
1717, Rewrite a numerical (long long range) option.,1,0,0,1
1718, Rewrite a octal option.,0,0,0,0
1719, Rewrite an enumeration option.,0,1,0,1
1720,"It takes as usually state and option name,  and in addition the enumeration array and the default value for the  option.",1,0,0,1
1721, Rewrite the syslog-facility option.,0,0,0,0
1722, Rewrite the save option.,0,1,0,1
1723," Note that if there are no save parameters at all, all the current      config line with ""save"" will be detected as orphaned and deleted,      resulting into no RDB persistence as expected.",1,0,0,1
1724," Mark ""save"" as processed in case server.saveparamslen is zero.",0,0,0,0
1725," Rewrite the dir option, always using absolute paths.",1,0,0,1
1726, no rewrite on error.,0,0,0,0
1727, Rewrite the slaveof option.,0,0,0,0
1728," If this is a master, we want all the slaveof config options      in the file to be removed.",0,0,0,0
1729,Note that if this is a cluster instance      we don't want a slaveof directive inside redis.conf.,0,0,0,0
1730, Rewrite the notify-keyspace-events option.,0,0,0,0
1731, Rewrite the client-output-buffer-limit option.,0,1,0,1
1732, Rewrite the bind option.,0,1,0,1
1733, Nothing to rewrite if we don't have bind addresses.,0,1,0,1
1734, Rewrite as bind <addr1> <addr2> ... <addrN>,0,0,0,0
1735," Glue together the configuration lines in the current configuration  rewrite state into a single string, stripping multiple empty lines.",1,0,0,1
1736, Every cluster of empty lines is turned into a single empty line.,1,1,0,1
1737, Free the configuration rewrite state.,1,1,0,1
1738," At the end of the rewrite process the state contains the remaining  map between ""option name"" => ""lines in the original config file"".",1,0,0,1
1739,"Lines used by the rewrite process were removed by the function  rewriteConfigRewriteLine(), all the other lines are ""orphaned"" and  should be replaced by empty lines.",1,0,0,1
1740,"This function does just this, iterating all the option names and  blanking all the lines still associated.",0,0,0,0
1741, Don't blank lines about options the rewrite process          don't understand.,0,0,0,0
1742, This function overwrites the old configuration file with the new content.,1,1,0,1
1743,1) The old file length is obtained.,1,1,0,1
1744,"2) If the new content is smaller, padding is added.",1,1,0,1
1745,3) A single write(2) call is used to replace the content of the file.,1,1,0,1
1746,4) Later the file is truncated to the length of the new content.,1,1,0,1
1747,This way we are sure the file is left in a consistent state even if the  process is stopped between any of the four operations.,1,0,0,1
1748,"The function returns 0 on success, otherwise -1 is returned and errno  set accordingly.",1,0,0,1
1749," 1) Open the old file (or create a new one if it does not         exist), get the size.",1,0,0,1
1750, errno set by open().,1,0,0,1
1751, errno set by fstat().,0,0,0,0
1752, 2) Pad the content at least match the old file size.,1,1,0,1
1753," If the old file was bigger, pad the content with          a newline plus as many ""#"" chars as required.",1,0,0,1
1754, 3) Write the new content using a single write(2).,1,1,0,1
1755, 4) Truncate the file to the right length if we used padding.,1,1,0,1
1756, Non critical error...,1,1,0,1
1757," Rewrite the configuration file at ""path"".",0,0,0,0
1758,"If the configuration file already exists, we try at best to retain comments  and overall structure.",1,0,0,1
1759,"Configuration parameters that are at their default value, unless already  explicitly included in the old configuration file, are not rewritten.",1,0,0,1
1760,"On error -1 is returned and errno is set accordingly, otherwise 0.",0,0,0,0
1761, Step 1: read the old config into our rewrite state.,1,0,0,1
1762," Step 2: rewrite every single option, replacing or appending it inside      the rewrite state.",1,0,0,1
1763, Rewrite Sentinel config if in Sentinel mode.,0,0,0,0
1764," Step 3: remove all the orphaned lines in the old file, that is, lines      that were used by a config option and are no longer used, like in case      of multiple ""save"" options or duplicated options.",1,0,0,1
1765, Step 4: generate a new configuration file from the modified state      and write it into the original file.,1,0,0,1
1766,-----------------------------------------------------------------------------  CONFIG command entry point ----------------------------------------------------------------------------,0,0,0,0
1767, Only allow CONFIG GET while loading.,1,1,0,1
1768, CRC16 implementation according to CCITT standards.,0,1,0,1
1769,"Note by @antirez: this is actually the XMODEM CRC 16 algorithm, using the  following parameters:   Name                       : ""XMODEM"", also known as ""ZMODEM"", ""CRC-16 or ACORN""  Width                      : 16 bit  Poly                       : 1021 (That is actually x^16 + x^12 + x^5 + 1)  Initialization             : 0000  Reflect Input byte         : False  Reflect Output CRC         : False  Xor constant to output CRC : 0000  Output for ""123456789""     : 31C3",1,0,0,1
1770, Test main,1,1,0,1
1771,-----------------------------------------------------------------------------  C-level DB API ----------------------------------------------------------------------------,0,0,0,0
1772, Update LFU when an object is accessed.,0,1,0,1
1773,"Firstly, decrement the counter if the decrement time is reached.",1,0,0,1
1774,"Then logarithmically increment the counter, and update the access time.",0,0,0,0
1775," Low level key lookup API, not actually called directly from commands  implementations that should instead rely on lookupKeyRead(),  lookupKeyWrite() and lookupKeyReadWithFlags().",1,0,0,1
1776, Update the access time for the ageing algorithm.,0,0,0,0
1777,"Don't do it if we have a saving child, as this will trigger          a copy on write madness.",0,0,0,0
1778," Lookup a key for read operations, or return NULL if the key is not found  in the specified DB.",1,0,0,1
1779,As a side effect of calling this function:  1.,0,0,0,0
1780,A key gets expired if it reached it's TTL.,1,1,0,1
1781,The key last access time is updated.,1,1,0,1
1782,The global keys hits or misses stats are updated (reported in INFO).,0,0,0,0
1783,"This API should not be used when we write to the key after obtaining  the object linked to the key, but only for read only operations.",1,0,0,1
1784,Flags change the behavior of this command:    LOOKUP_NONE (or zero): no special flags are passed.,1,0,0,1
1785,LOOKUP_NOTOUCH: don't alter the last access time of the key.,1,1,0,1
1786,"Note: this function also returns NULL is the key is logically expired  but still existing, in case this is a slave, since this API is called only  for read operations.",1,0,0,1
1787,"Even if the key expiry is master-driven, we can  correctly report a key is expired on slaves even if the master is lagging  expiring our key via DELs in the replication link.",1,0,0,1
1788, Key expired.,1,1,0,1
1789,"If we are in the context of a master, expireIfNeeded()          returns 0 only when the key does not exist at all, so it's safe          to return NULL ASAP.",1,0,0,1
1790," However if we are in the context of a slave, expireIfNeeded() will          not really try to expire the key, it only returns information          about the ""logical"" status of the key: key expiring is up to the          master in order to have a consistent view of master's data set.",1,0,0,1
1791,"However, if the command caller is not the master, and as additional          safety measure, the command invoked is a read-only command, we can          safely return NULL here, and provide a more consistent behavior          to clients accessign expired values in a read-only fashion, that          will say the key as non exisitng.",1,0,0,1
1792,Notably this covers GETs when slaves are used to scale reads.,1,0,0,1
1793," Like lookupKeyReadWithFlags(), but does not use any flag, which is the  common case.",1,0,0,1
1794," Lookup a key for write operations, and as a side effect, if needed, expires  the key if its TTL is reached.",1,0,0,1
1795,Returns the linked value object if the key exists or NULL if the key  does not exist in the specified DB.,1,0,0,1
1796, Add the key to the DB.,1,1,0,1
1797,It's up to the caller to increment the reference  counter of the value if needed.,0,0,0,0
1798,The program is aborted if the key already exists.,1,1,0,1
1799, Overwrite an existing key with a new value.,1,1,0,1
1800,Incrementing the reference  count of the new value is up to the caller.,1,0,0,1
1801,This function does not modify the expire time of the existing key.,1,0,0,1
1802,The program is aborted if the key was not already present.,1,1,0,1
1803, High level Set operation.,1,1,0,1
1804,"This function can be used in order to set  a key, whatever it was existing or not, to a new object.",1,0,0,1
1805,1) The ref count of the value object is incremented.,0,1,0,1
1806,2) clients WATCHing for the destination key notified.,1,0,0,1
1807,3) The expire time of the key is reset (the key is made persistent).,1,0,0,1
1808,All the new keys in the database should be craeted via this interface.,1,0,0,1
1809," Return a random key, in form of a Redis object.",1,0,0,1
1810,"If there are no keys, NULL is returned.",0,1,0,1
1811,The function makes sure to return keys not already expired.,1,1,0,1
1812, search for another key.,1,0,0,1
1813,This expired.,0,1,0,1
1814," Delete a key, value, and associated expiration entry if any, from the DB",1,1,0,1
1815," Deleting an entry from the expires dict will not free the sds of      the key, because it is shared with the main dictionary.",1,0,0,1
1816, This is a wrapper whose behavior depends on the Redis lazy free  configuration.,1,0,0,1
1817,Deletes the key synchronously or asynchronously.,1,1,0,1
1818, Prepare the string object stored at 'key' to be modified destructively  to implement commands like SETBIT or APPEND.,1,0,0,1
1819,"An object is usually ready to be modified unless one of the two conditions  are true:   1) The object 'o' is shared (refcount > 1), we don't want to affect     other users.",1,0,0,1
1820,"2) The object encoding is not ""RAW"".",1,0,0,1
1821,"If the object is found in one of the above conditions (or both) by the  function, an unshared  or  not-encoded copy of the string object is stored  at 'key' in the specified 'db'.",1,0,0,1
1822,Otherwise the object 'o' itself is  returned.,0,0,0,0
1823,"USAGE:   The object 'o' is what the caller already obtained by looking up 'key'  in 'db', the usage pattern looks like this:   o = lookupKeyWrite(db,key);  if (checkType(c,o,OBJ_STRING)) return;  o = dbUnshareStringValue(db,key,o);   At this point the caller is ready to modify the object, for example  using an sdscat() call to append some data, or anything else.",1,0,0,1
1824, Remove all keys from all the databases in a Redis server.,0,0,0,0
1825,If callback is given the function is called from time to time to  signal that work is in progress.,0,0,0,0
1826,"The dbnum can be -1 if all teh DBs should be flushed, or the specified  DB number if we want to flush only a single Redis database number.",1,0,0,1
1827,Flags are be EMPTYDB_NO_FLAGS if no special flags are specified or  EMPTYDB_ASYNC if we want the memory to be freed in a different thread  and the function to return ASAP.,1,0,0,1
1828,On success the fuction returns the number of keys removed from the  database(s).,1,0,0,1
1829,"Otherwise -1 is returned in the specific case the  DB number is out of range, and errno is set to EINVAL.",1,0,0,1
1830,#NAME?,1,0,0,1
1831,Every time a key in the database is modified the function  signalModifiedKey() is called.,1,0,0,1
1832,Every time a DB is flushed the function signalFlushDb() is called.,0,0,0,0
1833,-----------------------------------------------------------------------------  Type agnostic commands operating on the key space ----------------------------------------------------------------------------,1,0,0,1
1834, Return the set of flags to use for the emptyDb() call for FLUSHALL  and FLUSHDB commands.,0,0,0,0
1835,"Currently the command just attempts to parse the ""ASYNC"" option.",1,0,0,1
1836,It  also checks if the command arity is wrong.,1,0,0,1
1837,"On success C_OK is returned and the flags are stored in flags, otherwise  C_ERR is returned and the function sends an error to the client.",1,0,0,1
1838, Parse the optional ASYNC option.,0,1,0,1
1839, FLUSHDB [ASYNC]   Flushes the currently SELECTed Redis DB.,1,0,0,1
1840, FLUSHALL [ASYNC]   Flushes the whole server data set.,1,0,0,1
1841," Normally rdbSave() will reset dirty, but we don't want this here          as otherwise FLUSHALL will not be replicated nor put into the AOF.",1,0,0,1
1842, This command implements DEL and LAZYDEL.,0,1,0,1
1843, EXISTS key1 key2 ... key_N.,0,0,0,0
1844,Return value is the number of keys existing.,0,1,0,1
1845, This callback is used by scanGenericCommand in order to collect elements  returned by the dictionary iterator into a list.,0,0,0,0
1846," Try to parse a SCAN cursor stored at object 'o':  if the cursor is valid, store it as unsigned integer into cursor and  returns C_OK.",0,0,0,0
1847,Otherwise return C_ERR and send an error to the  client.,0,0,0,0
1848," Use strtoul() because we need an unsigned long, so      getLongLongFromObject() does not cover the whole cursor space.",1,0,0,1
1849," This command implements SCAN, HSCAN and SSCAN commands.",0,1,0,1
1850,"If object 'o' is passed, then it must be a Hash or Set object, otherwise  if 'o' is NULL the command will operate on the dictionary associated with  the current database.",1,0,0,1
1851,When 'o' is not NULL the function assumes that the first argument in  the client arguments vector is a key so it skips it before iterating  in order to parse options.,1,0,0,1
1852,In the case of a Hash object the function returns both the field and value  of every element on the Hash.,0,0,0,0
1853," Object must be NULL (to iterate keys names), or the type of the object      must be Set, Sorted Set, or Hash.",0,0,0,0
1854, Set i to the first option argument.,1,1,0,1
1855,The previous one is the cursor.,1,1,0,1
1856, Skip the key argument if needed.,1,1,0,1
1857, Step 1: Parse options.,0,1,0,1
1858," The pattern always matches if it is exactly """", so it is              equivalent to disabling it.",1,0,0,1
1859, Step 2: Iterate the collection.,0,1,0,1
1860,"Note that if the object is encoded with a ziplist, intset, or any other      representation that is not a hash table, we are sure that it is also      composed of a small number of elements.",1,0,0,1
1861,"So to avoid taking state we      just return everything inside the object in a single call, setting the      cursor to zero to signal the end of the iteration.",1,0,0,1
1862, Handle the case of a hash table.,0,1,0,1
1863, We return key  or  value for this type.,1,0,0,1
1864, We return key  or  value for this type.,1,0,0,1
1865," We set the max number of iterations to ten times the specified          COUNT, so if the hash table is in a pathological state (very          sparsely populated) we avoid to block too much time at the cost          of returning no or very few elements.",1,0,0,1
1866," We pass two pointers to the callback: the list to which it will          add new elements, and the object containing the dictionary so that          it is possible to fetch more data in a type-dependent way.",1,0,0,1
1867, Step 3: Filter elements.,0,1,0,1
1868, Filter element if it does not match the pattern.,0,1,0,1
1869, Filter element if it is an expired key.,1,1,0,1
1870, Remove the element and its associted value if needed.,0,0,0,0
1871," If this is a hash or a sorted set, we have a flat list of          key-value elements, so if this element was filtered, remove the          value, or skip it if it was not filtered: we only match keys.",1,0,0,1
1872, Step 4: Reply to the client.,0,1,0,1
1873, The SCAN command completely relies on scanGenericCommand.,1,0,0,1
1874, When SHUTDOWN is called while the server is loading a dataset in      memory we need to make sure no attempt is performed to save      the dataset on shutdown (otherwise it could overwrite the current DB      with half-read data).,1,0,0,1
1875,Also when in Sentinel mode clear the SAVE flag and force NOSAVE.,1,0,0,1
1876," When source and dest key is the same, no operation is performed,      if the key exists, however we still return an error on unexisting key.",1,0,0,1
1877, Overwrite: delete the old key before creating the new one          with the same name.,1,0,0,1
1878, Obtain source and target DB pointers,0,1,0,1
1879, Back to the source DB,0,1,0,1
1880, If the user is moving using as target the same      DB as the source DB it is probably an error.,1,0,0,1
1881, Check if the element exists and get a reference,0,1,0,1
1882, Return zero if the key already exists in the target DB,1,1,0,1
1883, OK!,1,1,0,1
1884,"key moved, free the entry in the source DB",1,0,0,1
1885, Helper function for dbSwapDatabases(): scans the list of keys that have  one or more blocked clients for B[LR]POP or other list blocking commands  and signal the keys are ready if they are lists.,1,0,0,1
1886,See the comment where  the function is used for more info.,1,0,0,1
1887, Swap two databases at runtime so that all clients will magically see  the new database even if already connected.,1,0,0,1
1888,"Note that the client  structure c->db points to a given DB, so we need to be smarter and  swap the underlying referenced structures, otherwise we would need  to fix all the references to the Redis DB structure.",0,0,0,0
1889,"Returns C_ERR if at least one of the DB ids are out of range, otherwise  C_OK is returned.",1,0,0,1
1890, Swap hash tables.,0,1,0,1
1891,"Note that we don't swap blocking_keys,      ready_keys and watched_keys, since we want clients to      remain in the same DB they were.",1,0,0,1
1892," Now we need to handle clients blocked on lists: as an effect      of swapping the two DBs, a client that was waiting for list      X in a given DB, may now actually be unblocked if X happens      to exist in the new version of the DB, after the swap.",1,0,0,1
1893,However normally we only do this check for efficiency reasons      in dbAdd() when a list is created.,1,0,0,1
1894,So here we need to rescan      the list of clients blocked on lists and signal lists as ready      if needed.,1,0,0,1
1895, SWAPDB db1 db2,0,1,0,1
1896, Not allowed in cluster mode: we have just DB 0 there.,0,1,0,1
1897, Get the two DBs indexes.,0,0,0,0
1898, Swap...,0,1,0,1
1899,-----------------------------------------------------------------------------  Expires API ----------------------------------------------------------------------------,0,0,0,0
1900, An expire may only be removed if there is a corresponding entry in the      main dict.,1,0,0,1
1901,"Otherwise, the key will never be freed.",1,1,0,1
1902, Set an expire to the specified key.,1,0,0,1
1903,"If the expire is set in the context  of an user calling a command 'c' is the client, otherwise 'c' is set  to NULL.",0,0,0,0
1904,The 'when' parameter is the absolute unix time in milliseconds  after which the key will no longer be considered valid.,1,0,0,1
1905, Reuse the sds from the main dict in the expire dict,1,0,0,1
1906," Return the expire time of the specified key, or -1 if no expire  is associated with this key (i.e.",1,0,0,1
1907,the key is non volatile),1,0,0,1
1908, No expire?,0,1,0,1
1909,return ASAP,0,0,0,0
1910," The entry was found in the expire dict, this means it should also      be present in the main dict (safety check).",1,0,0,1
1911, Propagate expires into slaves and the AOF file.,0,1,0,1
1912,"When a key expires in the master, a DEL operation for this key is sent  to all the slaves and the AOF file if enabled.",1,0,0,1
1913,"This way the key expiry is centralized in one place, and since both  AOF and the master->slave link guarantee operation ordering, everything  will be consistent even if we allow write operations against expiring  keys.",1,0,0,1
1914," This function is called when we are going to perform some operation  in a given key, but such key may be already logically expired even if  it still exists in the database.",1,0,0,1
1915,The main way this function is called  is via lookupKey() family of functions.,1,0,0,1
1916,"The behavior of the function depends on the replication role of the  instance, because slave instances do not expire keys, they wait  for DELs from the master for consistency matters.",0,0,0,0
1917,"However even  slaves will try to have a coherent return value for the function,  so that read commands executed in the slave side will be able to  behave like if the key is expired even if still present (because the  master has yet to propagate the DEL).",1,0,0,1
1918,"In masters as a side effect of finding a key which is expired, such  key will be evicted from the database.",1,0,0,1
1919,Also this may trigger the  propagation of a DEL or UNLINK command in AOF  or  replication stream.,0,0,0,0
1920,"The return value of the function is 0 if the key is still valid,  otherwise the function returns 1 if the key is expired.",1,0,0,1
1921, No expire for this key,1,1,0,1
1922, Don't expire anything while loading.,0,1,0,1
1923,It will be done later.,0,1,0,1
1924," If we are in the context of a Lua script, we pretend that time is      blocked to when the Lua script started.",0,0,0,0
1925,"This way a key can expire      only the first time it is accessed and not in the middle of the      script execution, making propagation to slaves  or  AOF consistent.",1,0,0,1
1926,See issue #1525 on Github for more information.,1,0,0,1
1927," If we are running in the context of a slave, return ASAP:      the slave key expiration is controlled by the master that will      send us synthesized DEL operations for expired keys.",1,0,0,1
1928,"Still we try to return the right information to the caller,      that is, 0 if we think the key should be still valid, 1 if      we think the key is expired at this time.",1,0,0,1
1929, Return when this key has not expired,1,1,0,1
1930, Delete the key,1,1,0,1
1931, -----------------------------------------------------------------------------  API to get key arguments from commands  ---------------------------------------------------------------------------,1,0,0,1
1932," The base case is to use the keys position as given in the command table  (firstkey, lastkey, step).",1,0,0,1
1933," Modules commands, and standard commands with a not fixed number              of arugments (negative arity parameter) do not have dispatch              time arity checks, so we need to handle the case where the user              passed an invalid number of arguments here.",1,0,0,1
1934,In this case we              return no keys and expect the command implementation to report              an arity or syntax error.,0,0,0,0
1935, Return all the arguments that are keys in the command passed via argc  or  argv.,0,0,0,0
1936,"The command returns the positions of all the key arguments inside the array,  so the actual return value is an heap allocated array of integers.",1,0,0,1
1937,The  length of the array is returned by reference into numkeys.,0,0,0,0
1938,"'cmd' must be point to the corresponding entry into the redisCommand  table, according to the command name in argv[0].",0,0,0,0
1939,"This function uses the command table if a command-specific helper function  is not required, otherwise it calls the command-specific function.",0,0,0,0
1940, Free the result of getKeysFromCommand.,1,0,0,1
1941, Helper function to extract keys from following commands:  ZUNIONSTORE <destkey> <num-keys> <key> <key> ... <key> <options>  ZINTERSTORE <destkey> <num-keys> <key> <key> ... <key> <options>,1,0,0,1
1942, Sanity check.,0,1,0,1
1943,Don't return any key if the command is going to      reply with syntax error.,1,0,0,1
1944," Keys in z{union,inter}store come from two places:      argv[1] = storage key,      argv[3...n] = keys to intersect",1,0,0,1
1945, Add all key positions for argv[3...n] to keys[],1,0,0,1
1946, Finally add the argv[1] key position (the storage key target).,1,0,0,1
1947," Total keys = {union,inter} keys + storage key",1,0,0,1
1948, Helper function to extract keys from the following commands:  EVAL <script> <num-keys> <key> <key> ... <key> [more stuff]  EVALSHA <script> <num-keys> <key> <key> ... <key> [more stuff],1,0,0,1
1949, Sanity check.,0,1,0,1
1950,Don't return any key if the command is going to      reply with syntax error.,1,0,0,1
1951, Add all key positions for argv[3...n] to keys[],1,0,0,1
1952, Helper function to extract keys from the SORT command.,0,1,0,1
1953,SORT <sort-key> ... STORE <store-key> ...,0,1,0,1
1954,"The first argument of SORT is always a key, however a list of options  follow in SQL-alike style.",1,0,0,1
1955,"Here we parse just the minimum in order to  correctly identify keys in the ""STORE"" option.",0,0,0,0
1956, Alloc 2 places for the worst case.,1,0,0,1
1957, <sort-key> is always present.,0,1,0,1
1958, Search for STORE option.,0,1,0,1
1959,"By default we consider options to don't      have arguments, so if we find an unknown option name we scan the      next.",1,0,0,1
1960,"However there are options with 1 or 2 arguments, so we      provide a list here in order to skip the right number of args.",1,0,0,1
1961, End of elements.,0,1,0,1
1962," Note: we don't increment ""num"" here and continue the loop                  to be sure to process the last ""STORE"" option if multiple                  ones are provided.",1,0,0,1
1963,This is same behavior as SORT.,1,1,0,1
1964, <store-key>,0,1,0,1
1965, Assume the obvious form.,1,1,0,1
1966, But check for the extended one with the KEYS option.,0,1,0,1
1967, Helper function to extract keys from following commands:  GEORADIUS key x y radius unit [WITHDIST] [WITHHASH] [WITHCOORD] [ASC|DESC]                              [COUNT count] [STORE key] [STOREDIST key]  GEORADIUSBYMEMBER key member radius unit ... options ...,1,0,0,1
1968, Check for the presence of the stored key in the command,1,1,0,1
1969," For the case when user specifies both ""store"" and ""storedist"" options, the          second key specified would override the first key.",1,0,0,1
1970,This behavior is kept          the same as in georadiusCommand method.,1,0,0,1
1971," Keys in the command come from two places:      argv[1] = key,      argv[5...n] = stored key if present",1,0,0,1
1972, Add all key positions to keys[],1,1,0,1
1973, XREAD [BLOCK <milliseconds>] [COUNT <count>] [GROUP <groupname> <ttl>]        [RETRY <milliseconds> <ttl>] STREAMS key_1 key_2 ... key_N        ID_1 ID_2 ... ID_N,0,0,0,0
1974," We need to seek the last argument that contains ""STREAMS"", because other      arguments before may contain it (for example the group name).",1,0,0,1
1975, Syntax error.,0,1,0,1
1976," We have half the keys as there are arguments because                 there are also the IDs, one per key.",1,0,0,1
1977, Slot to Key API.,1,1,0,1
1978,This is used by Redis Cluster in order to obtain in  a fast way a key that belongs to a specified hash slot.,1,0,0,1
1979,This is useful  while rehashing the cluster and in other conditions when we need to  understand if we have keys for a given hash slot.,1,0,0,1
1980, Pupulate the specified array of objects with keys in the specified slot.,0,0,0,0
1981,"New objects are returned to represent keys, it's up to the caller to  decrement the reference count to release the keys names.",1,0,0,1
1982, Remove all the keys in the specified hash slot.,0,1,0,1
1983,The number of removed items is returned.,0,1,0,1
1984, SHA1 is used for DEBUG DIGEST,0,1,0,1
1985, HAVE_BACKTRACE,0,1,0,1
1986, ================================= Debugging ==============================,0,1,0,1
1987, Compute the sha1 of string at 's' with 'len' bytes long.,1,0,0,1
1988,The SHA1 is then xored against the string pointed by digest.,0,0,0,0
1989,"Since xor is commutative, this operation is used in order to  ""add"" digests relative to unordered elements.",0,0,0,0
1990,"So digest(a,b,c,d) will be the same of digest(b,a,c,d)",1,0,0,1
1991," This function instead of just computing the SHA1 and xoring it  against digest, also perform the digest of ""digest"" itself and  replace the old value with the new one.",1,0,0,1
1992,"So the final digest will be:   digest = SHA1(digest xor SHA1(data))   This function is used every time we want to preserve the order so  that digest(a,b,c,d) will be different than digest(b,c,d,a)   Also note that mixdigest(""foo"") followed by mixdigest(""bar"")  will lead to a different digest compared to ""fo"", ""obar"".",1,0,0,1
1993, Compute the dataset digest.,0,0,0,0
1994,"Since keys, sets elements, hashes elements  are not ordered, we use a trick: every aggregate digest is the xor  of the digests of their elements.",0,0,0,0
1995,This way the order will not change  the result.,0,0,0,0
1996,For list instead we use a feedback entering the output digest  as input in order to ensure that a different ordered list will result in  a different digest.,1,0,0,1
1997, Start with a clean result,1,1,0,1
1998," hash the DB id, so the same dataset moved in a different          DB will lead to a different digest",1,0,0,1
1999, Iterate this DB writing every entry,0,1,0,1
2000, This key-val digest,0,1,0,1
2001, Save the key and associated value,1,1,0,1
2002," If the key has an expire, add it to the mix",1,0,0,1
2003, We can finally xor the key-val digest to the final digest,1,1,0,1
2004, Should trigger an out of memory.,0,1,0,1
2005, Prevent AOF  or  replication,0,0,0,0
2006, Add number of quicklist nodes,0,0,0,0
2007, Add average quicklist fill factor,1,0,0,1
2008, Add quicklist fill level  or  max ziplist size,0,0,0,0
2009, Add isCompressed?,0,0,0,0
2010, Add total uncompressed size,1,1,0,1
2011, no newlines in errors.,0,0,0,0
2012, =========================== Crash handling  ==============================,0,0,0,0
2013, OSX < 10.6,0,1,0,1
2014, OSX >= 10.6,0,1,0,1
2015, Linux,0,1,0,1
2016, Linux 32,0,1,0,1
2017, Linux 64,0,1,0,1
2018, Linux IA64,0,1,0,1
2019, Linux ARM,0,1,0,1
2020, OSX,0,1,0,1
2021, OSX AMD64,0,1,0,1
2022, OSX x86,0,1,0,1
2023, Linux,0,1,0,1
2024, Linux x86,0,1,0,1
2025, Linux AMD64,0,1,0,1
2026," Return a file descriptor to write directly to the Redis log with the  write(2) syscall, that can be used in critical sections of the code  where the rest of Redis can't be trusted (for example during the memory  test) or when an API call requires a raw fd.",1,0,0,1
2027,Close it with closeDirectLogFiledes().,0,0,0,0
2028, Used to close what closeDirectLogFiledes() returns.,0,0,0,0
2029, Logs the stack trace using the backtrace() call.,0,0,0,0
2030,This function is designed  to be called from signal handlers safely.,1,0,0,1
2031, If we can't log there is anything to do.,0,0,0,0
2032, Generate the stack trace,0,1,0,1
2033, Avoid warning.,0,1,0,1
2034, Avoid warning.,0,1,0,1
2035, Write symbols to log file,0,1,0,1
2036, Cleanup,0,1,0,1
2037," Log information about the ""current"" client, that is, the client that is  currently being served by Redis.",1,0,0,1
2038,May be NULL if Redis is not serving a  client right now.,1,0,0,1
2039," Check if the first argument, usually a key, is found inside the      selected DB, and if so print info about the associated object.",1,0,0,1
2040, A non destructive memory test executed during segfauls.,1,0,0,1
2041, Nothing to do.,0,1,0,1
2042, Nothing to do.,0,1,0,1
2043, Nothing to do.,0,1,0,1
2044, Nothing to do.,0,1,0,1
2045, NOTE: It is very important to close the file descriptor only now      because closing it before may result into unmapping of some memory      region that we are testing.,1,0,0,1
2046," Scans the (assumed) x86 code starting at addr, for a max of `len`  bytes, searching for E8 (callq) opcodes, and dumping the symbols  and the call offset if they appear to be valid.",1,0,0,1
2047, Hash table to best-effort avoid printing the same symbol      multiple times.,1,0,0,1
2048, Not an E8 CALL opcode.,0,0,0,0
2049, Skip the 32 bit immediate.,0,1,0,1
2050, Log the stack trace,0,1,0,1
2051, Log INFO and CLIENT LIST,0,1,0,1
2052, Log the current client,1,1,0,1
2053, Log dump of processor registers,0,1,0,1
2054, Test memory,0,1,0,1
2055, we don't have functions over 8k (verified),0,0,0,0
2056," Find the address of the next page, which is our ""safety""                  limit when dumping.",0,0,0,0
2057,"Then try to dump just 128 bytes more                  than EIP if there is room, or stop sooner.",1,0,0,1
2058, free(messages); Don't call free() with possibly corrupted memory.,1,0,0,1
2059, Make sure we exit with the right signal at the end.,1,1,0,1
2060,So for instance      the core will be dumped if enabled.,0,0,0,0
2061, HAVE_BACKTRACE,0,1,0,1
2062, ==================== Logging functions for debugging =====================,0,1,0,1
2063, =========================== Software Watchdog ============================,0,1,0,1
2064, Schedule a SIGALRM delivery after the specified period in milliseconds.,0,1,0,1
2065,"If a timer is already scheduled, this function will re-schedule it to the  specified time.",0,0,0,0
2066,If period is 0 the current timer is disabled.,1,0,0,1
2067, Will stop the timer if period is 0.,0,1,0,1
2068, Don't automatically restart.,0,1,0,1
2069, Enable the software watchdog with the specified period in milliseconds.,0,1,0,1
2070," Watchdog was actually disabled, so we have to setup the signal          handler.",1,0,0,1
2071," If the configured period is smaller than twice the timer period, it is      too short for the software watchdog to work reliably.",1,0,0,1
2072,Fix it now      if needed.,0,0,0,0
2073, Adjust the current timer.,1,1,0,1
2074, Disable the software watchdog.,0,1,0,1
2075, Already disabled.,1,1,0,1
2076, Stop the current timer.,1,1,0,1
2077," Set the signal handler to SIG_IGN, this will also remove pending      signals from the queue.",0,0,0,0
2078, this method was added to jemalloc in order to help us understand which  pointers are worthwhile moving and which aren't,1,0,0,1
2079, forward declarations,0,0,0,0
2080, Defrag helper for generic allocations.,0,0,0,0
2081,returns NULL in case the allocatoin wasn't moved.,0,0,0,0
2082,"when it returns a non-null value, the old pointer was already released  and should NOT be accessed.",1,0,0,1
2083," if this run is more utilized than the average utilization in this bin      (or it is full), skip it.",1,0,0,1
2084,This will eventually move all the allocations      from relatively empty runs into relatively full runs.,1,0,0,1
2085, move this allocation to a new allocation.,1,0,0,1
2086,make sure not to use the thread cache.,1,0,0,1
2087,so that we don't get back the same      pointers we try to free,1,0,0,1
2088,Defrag helper for sds strings   returns NULL in case the allocatoin wasn't moved.,0,0,0,0
2089,"when it returns a non-null value, the old pointer was already released  and should NOT be accessed.",1,0,0,1
2090, Defrag helper for robj and or or string objects   returns NULL in case the allocatoin wasn't moved.,0,0,0,0
2091,"when it returns a non-null value, the old pointer was already released  and should NOT be accessed.",1,0,0,1
2092, try to defrag robj (only if not an EMBSTR type (handled below).,1,0,0,1
2093, try to defrag string object,0,0,0,0
2094," The sds is embedded in the object allocation, calculate the              offset and update the pointer in the new allocation.",1,0,0,1
2095, Defrag helper for dictEntries to be used during dict iteration (called on  each step).,0,0,0,0
2096,Teturns a stat of how many pointers were moved.,1,0,0,1
2097," This function is a little bit dirty since it messes with the internals      of the dict and it's iterator, but the benefit is that it is very easy      to use, and require no other chagnes in the dict.",1,0,0,1
2098," Handle the next entry (if there is one), and update the pointer in the      current entry.",1,0,0,1
2099, handle the case of the first entry in the hash bucket.,1,0,0,1
2100," Defrag helper for dict main allocations (dict struct, and hash tables).",1,0,0,1
2101,receives a pointer to the dict and implicitly updates it when the dict  struct itself was moved.,0,0,0,0
2102,Returns a stat of how many pointers were moved.,1,1,0,1
2103, handle the first hash table,1,0,0,1
2104, handle the second hash table,0,0,0,0
2105, Internal function used by zslDefrag,0,0,0,0
2106, Defrag helper for sorted set.,0,0,0,0
2107,"Update the robj pointer, defrag the skiplist struct and return the new score  reference.",1,0,0,1
2108,"We may not access oldele pointer (not even the pointer stored in  the skiplist), as it was already freed.",0,0,0,0
2109,"Newele may be null, in which case we  only need to defrag the skiplist, but not update the obj pointer.",1,0,0,1
2110,"When return value is non-NULL, it is the score reference that must be updated  in the dict record.",0,0,0,0
2111," find the skiplist node referring to the object that was moved,      and all pointers that need to be updated if we'll end up moving the skiplist node.",0,0,0,0
2112, make sure not to access the                                                     ->obj pointer if it matches                                                     oldele,1,0,0,1
2113, update the robj pointer inside the skip list record.,0,0,0,0
2114, try to defrag the skiplist record itself,0,0,0,0
2115, Defrag helpler for sorted set.,0,0,0,0
2116,"Defrag a single dict entry key name, and corresponding skiplist struct",1,0,0,1
2117," Defrag a dict with sds key and optional value (either ptr, sds or robj string)",1,0,0,1
2118, defrag the value,0,0,0,0
2119," Defrag a list of ptr, sds or robj string values",0,0,0,0
2120, Defrag a list of sds values and a dict with the same sds keys,1,0,0,1
2121, Defrag the list and it's sds values,0,0,0,0
2122," When defragging an sds value, we need to update the dict key",1,0,0,1
2123, Defrag the dict values (keys were already handled),0,0,0,0
2124, Utility function that replaces an old key pointer in the dictionary with a  new pointer.,1,0,0,1
2125,"Additionally, we try to defrag the dictEntry in that dict.",0,0,0,0
2126,Oldkey mey be a dead pointer and should not be accessed (we get a  pre-calculated hash value).,1,0,0,1
2127,Newkey may be null if the key pointer wasn't  moved.,1,0,0,1
2128,"Return value is the the dictEntry if found, or NULL if not found.",0,0,0,0
2129,"NOTE: this is very ugly code, but it let's us avoid the complication of  doing a scan on another dict.",1,0,0,1
2130," when the value has lots of elements, we want to handle it later and not as  oart of the main dictionary scan.",1,0,0,1
2131,this is needed in order to prevent latency  spikes when handling large items,1,0,0,1
2132, handle the dict struct,0,0,0,0
2133, defrag the dict tables,0,0,0,0
2134, handle the dict struct,0,0,0,0
2135, defrag the dict tables,0,0,0,0
2136, handle the dict struct,0,0,0,0
2137, defrag the dict tables,0,0,0,0
2138," for each key we scan in the main dict, this function will attempt to defrag  all the various pointers it has.",1,0,0,1
2139,Returns a stat of how many pointers were  moved.,1,0,0,1
2140, Try to defrag the key name.,1,0,0,1
2141, Dirty code:           I can't search in db->expires for that key after i already released           the pointer it holds it won't be able to do the string compare,1,0,0,1
2142, Try to defrag robj and  or  or string value.,0,0,0,0
2143, Already handled in activeDefragStringOb.,0,0,0,0
2144, Currently defragmenting modules private data types          is not supported.,1,0,0,1
2145, Defrag scan callback for the main db dictionary.,1,0,0,1
2146," Defrag scan callback for for each hash table bicket,  used in order to defrag the dictEntry allocations.",0,0,0,0
2147," NOTE: this function is also used by both activeDefragCycle and scanLaterHash, etc.",0,0,0,0
2148,don't use privdata,0,0,0,0
2149, Utility function to get the fragmentation ratio from jemalloc.,0,0,0,0
2150,"It is critical to do that by comparing only heap maps that belong to  jemalloc, and skip ones the jemalloc keeps as spare.",1,0,0,1
2151,"Since we use this  fragmentation ratio in order to decide if a defrag action should be taken  or not, a false detection can cause the defragmenter to waste a lot of CPU  without the possibility of getting any results.",1,0,0,1
2152," We may need to defrag other globals, one small allcation can hold a full allocator run.",1,0,0,1
2153,"so although small, it is still important to defrag these",1,0,0,1
2154, there are many more pointers to defrag (e.g.,1,0,0,1
2155,"client argv, output  or  aof buffers, etc.",0,0,0,0
2156,"but we assume most of these are short lived, we only need to defrag allocations      that remain static for a long time",1,0,0,1
2157," list has no scan, we must finish it in one go",0,0,0,0
2158, object type may have changed since we schedule it for later,0,0,0,0
2159, object may have been deleted already,0,0,0,0
2160," returns 0 if no more work needs to be been done, and 1 if time is up and more work is needed.",1,0,0,1
2161," if we're not continuing a scan from the last call or loop, start a new one",1,0,0,1
2162, Move on to next key,1,1,0,1
2163, stop if we reached the last one.,1,0,0,1
2164, start a new key,1,0,0,1
2165, each time we enter this function we need to fetch the key from the dict again (if it still exists),1,0,0,1
2166," Once in 16 scan iterations, 512 pointer reallocations, or 64 fields              (if we have a lot of pointers in one hash bucket, or rehashing),              check if we reached the time limit.",0,0,0,0
2167,"But regardless, don't start a new BIG key in this loop, this is because the              next key can be a list, and scanLaterList must be done in once cycle",1,0,0,1
2168," decide if defrag is needed, and at what CPU effort to invest in it",0,0,0,0
2169," If we're not already running, and below the threshold, exit.",0,1,0,1
2170, Calculate the adaptive aggressiveness of the defrag,0,0,0,0
2171," We allow increasing the aggressiveness during a scan, but don't       reduce it.",0,0,0,0
2172, Perform incremental defragmentation work from the serverCron.,0,0,0,0
2173,"This works in a similar way to activeExpireCycle, in the sense that  we do incremental work across calls.",1,0,0,1
2174, Defragging memory while there's a fork will just do damage.,0,0,0,0
2175," Once a second, check if we the fragmentation justfies starting a scan      or making it more aggressive.",1,0,0,1
2176, See activeExpireCycle for how timelimit is handled.,0,0,0,0
2177," if we're not continuing a scan from the last call or loop, start a new one",1,0,0,1
2178, finish any leftovers from previous db before moving to the next one,1,0,0,1
2179," time is up, we didn't finish all the work",0,0,0,0
2180, this will exit the function and we'll continue on the next cycle,0,0,0,0
2181," Move on to next database, and stop if we reached the last one.",1,1,0,1
2182, defrag other items not part of the db  or  keys,1,0,0,1
2183," if another scan is needed, start it right away",1,0,0,1
2184, Start a scan from the first database.,1,1,0,1
2185," before scanning the next bucket, see if we have big keys left from the previous bucket to scan",1,0,0,1
2186," time is up, we didn't finish all the work",0,0,0,0
2187, this will exit the function and we'll continue on the next cycle,0,0,0,0
2188," Once in 16 scan iterations, 512 pointer reallocations.",0,0,0,0
2189,"or 64 keys              (if we have a lot of pointers in one hash bucket or rehasing),              check if we reached the time limit.",0,0,0,0
2190,"But regardless, don't start a new db in this loop, this is because after              the last db we call defragOtherGlobals, which must be done in once cycle",1,0,0,1
2191, HAVE_DEFRAG,0,1,0,1
2192, Not implemented yet.,0,1,0,1
2193, Using dictEnableResize()  or  dictDisableResize() we make possible to  enable or disable resizing of the hash table as needed.,1,0,0,1
2194,"This is very important  for Redis, as we use copy-on-write and don't want to move too much memory  around when there is a child performing saving operations.",1,0,0,1
2195,"Note that even when dict_can_resize is set to 0, not all resizes are  prevented: a hash table is still allowed to grow if the ratio between  the number of elements and the buckets > dict_force_resize_ratio.",0,0,0,0
2196, -------------------------- private prototypes ----------------------------,1,1,0,1
2197, -------------------------- hash functions --------------------------------,0,1,0,1
2198, The default hashing function uses SipHash implementation  in siphash.c.,0,0,0,0
2199, ----------------------------- API implementation -------------------------,0,1,0,1
2200, Reset a hash table already initialized with ht_init().,0,0,0,0
2201,NOTE: This function should only be called by ht_destroy().,1,0,0,1
2202, Create a new hash table,1,1,0,1
2203, Initialize the hash table,0,1,0,1
2204," Resize the table to the minimal size that contains all the elements,  but with the invariant of a USED or BUCKETS ratio near to <= 1",1,0,0,1
2205, Expand or create the hash table,0,1,0,1
2206, the new hash table,1,0,0,1
2207, the size is invalid if it is smaller than the number of      elements already inside the hash table,1,0,0,1
2208, Rehashing to the same table size is not useful.,1,1,0,1
2209, Allocate the new hash table and initialize all pointers to NULL,1,1,0,1
2210, Is this the first initialization?,1,1,0,1
2211,If so it's not really a rehashing      we just set the first hash table so that it can accept keys.,1,0,0,1
2212, Prepare a second hash table for incremental rehashing,0,1,0,1
2213, Performs N steps of incremental rehashing.,0,1,0,1
2214,"Returns 1 if there are still  keys to move from the old to the new hash table, otherwise 0 is returned.",1,0,0,1
2215,"Note that a rehashing step consists in moving a bucket (that may have more  than one key as we use chaining) from the old to the new hash table, however  since part of the hash table may be composed of empty spaces, it is not  guaranteed that this function will rehash even a single bucket, since it  will visit at max N10 empty buckets in total, otherwise the amount of  work it does would be unbound and the function may block for a long time.",1,0,0,1
2216, Max number of empty buckets to visit.,1,1,0,1
2217, Note that rehashidx can't overflow as we are sure there are more          elements because ht[0].used != 0,1,0,0,1
2218, Move all the keys in this bucket from the old to the new hash HT,1,1,0,1
2219, Get the index in the new hash table,1,1,0,1
2220, Check if we already rehashed the whole table...,1,1,0,1
2221, More to rehash...,1,1,0,1
2222, Rehash for an amount of time between ms milliseconds and ms+1 milliseconds,0,1,0,1
2223," This function performs just a step of rehashing, and only if there are  no safe iterators bound to our hash table.",1,0,0,1
2224,When we have iterators in the  middle of a rehashing we can't mess with the two hash tables otherwise  some element can be missed or duplicated.,1,0,0,1
2225,This function is called by common lookup or update operations in the  dictionary so that the hash table automatically migrates from H1 to H2  while it is actively used.,1,0,0,1
2226, Add an element to the target hash table,0,1,0,1
2227," Low level add or find:  This function adds the entry but instead of setting a value returns the  dictEntry structure to the user, that will make sure to fill the value  field as he wishes.",1,0,0,1
2228,"This function is also directly exposed to the user API to be called  mainly in order to store non-pointers inside the hash value, example:   entry = dictAddRaw(dict,mykey,NULL);  if (entry != NULL) dictSetSignedIntegerVal(entry,1000);   Return values:   If key already exists NULL is returned, and ""existing"" is populated  with the existing entry if existing is not NULL.",1,0,0,1
2229,"If key was added, the hash entry is returned to be manipulated by the caller.",1,1,0,1
2230," Get the index of the new element, or -1 if      the element already exists.",1,0,0,1
2231, Allocate the memory and store the new entry.,1,1,0,1
2232,"Insert the element in top, with the assumption that in a database      system it is more likely that recently added entries are accessed      more frequently.",1,0,0,1
2233, Set the hash entry fields.,0,1,0,1
2234," Add or Overwrite:  Add an element, discarding the old value if the key already exists.",1,0,0,1
2235,"Return 1 if the key was added from scratch, 0 if there was already an  element with such key and dictReplace() just performed a value update  operation.",1,0,0,1
2236, Try to add the element.,0,1,0,1
2237,If the key      does not exists dictAdd will suceed.,1,0,0,1
2238, Set the new value and free the old one.,1,1,0,1
2239,"Note that it is important      to do that in this order, as the value may just be exactly the same      as the previous one.",1,0,0,1
2240,"In this context, think to reference counting,      you want to increment (set), and then decrement (free), and not the      reverse.",1,0,0,1
2241," Add or Find:  dictAddOrFind() is simply a version of dictAddRaw() that always  returns the hash entry of the specified key, even if the key already  exists and can't be added (in that case the entry of the already  existing key is returned.)",1,0,0,1
2242,See dictAddRaw() for more information.,1,0,0,1
2243, Search and remove an element.,0,1,0,1
2244,"This is an helper function for  dictDelete() and dictUnlink(), please check the top comment  of those functions.",1,0,0,1
2245, Unlink the element from the list,0,0,0,0
2246, not found,0,0,0,0
2247," Remove an element, returning DICT_OK on success or DICT_ERR if the  element was not found.",1,0,0,1
2248," Remove an element from the table, but without actually releasing  the key, value and dictionary entry.",1,0,0,1
2249,"The dictionary entry is returned  if the element was found (and unlinked from the table), and the user  should later call `dictFreeUnlinkedEntry()` with it in order to release it.",0,0,0,0
2250,"Otherwise if the key is not found, NULL is returned.",1,0,0,1
2251,This function is useful when we want to remove something from the hash  table but want to use its value before actually deleting the entry.,1,0,0,1
2252,"Without this function the pattern would require two lookups:    entry = dictFind(...);    or  or  Do something with entry   dictDelete(dictionary,entry);   Thanks to this function it is possible to avoid this, and use  instead:   entry = dictUnlink(dictionary,entry);   or  or  Do something with entry  dictFreeUnlinkedEntry(entry);  or  or  <- This does not need to lookup again.",1,0,0,1
2253, You need to call this function to really free the entry after a call  to dictUnlink().,1,0,0,1
2254,It's safe to call this function with 'he' = NULL.,1,1,0,1
2255, Destroy an entire dictionary,1,1,0,1
2256, Free all the elements,1,1,0,1
2257, Free the table and the allocated cache structure,1,1,0,1
2258, Re-initialize the table,0,1,0,1
2259, never fails,1,0,0,1
2260, Clear & Release the hash table,1,1,0,1
2261, dict is empty,1,0,0,1
2262," A fingerprint is a 64 bit number that represents the state of the dictionary  at a given time, it's just a few dict properties xored together.",1,0,0,1
2263,"When an unsafe iterator is initialized, we get the dict fingerprint, and check  the fingerprint again when the iterator is released.",0,0,0,0
2264,If the two fingerprints are different it means that the user of the iterator  performed forbidden operations against the dictionary while iterating.,1,0,0,1
2265, We hash N integers by summing every successive integer with the integer      hashing of the previous sum.,1,0,0,1
2266,Basically:           Result = hash(hash(hash(int1)+int2)+int3) ...,0,0,0,0
2267,This way the same set of integers in a different order will (likely) hash      to a different number.,1,0,0,1
2268, For the hashing step we use Tomas Wang's 64 bit integer hash.,0,1,0,1
2269, hash = (hash << 21) - hash - 1;,1,0,0,1
2270, hash  265,0,0,0,0
2271, hash  21,0,0,0,0
2272," We need to save the 'next' here, the iterator user              may delete the entry we are returning.",0,0,0,0
2273, Return a random entry from the hash table.,1,1,0,1
2274,Useful to  implement randomized algorithms,1,0,0,1
2275, We are sure there are no elements in indexes from 0              to rehashidx-1,1,0,0,1
2276," Now we found a non empty bucket, but it is a linked      list and we need to get a random element from the list.",1,0,0,1
2277,The only sane way to do so is counting the elements and      select a random index.,1,0,0,1
2278, This function samples the dictionary to return a few keys from random  locations.,1,0,0,1
2279,"It does not guarantee to return all the keys specified in 'count', nor  it does guarantee to return non-duplicated elements, however it will make  some effort to do both things.",0,0,0,0
2280,Returned pointers to hash table entries are stored into 'des' that  points to an array of dictEntry pointers.,0,0,0,0
2281,"The array must have room for  at least 'count' elements, that is the argument we pass to the function  to tell how many random elements we need.",1,0,0,1
2282,"The function returns the number of items stored into 'des', that may  be less than 'count' if the hash table has less than 'count' elements  inside, or if not enough elements were found in a reasonable amount of  steps.",1,0,0,1
2283,"Note that this function is not suitable when you need a good distribution  of the returned items, but only when you need to ""sample"" a given number  of continuous elements to run some kind of algorithm or to produce  statistics.",1,0,0,1
2284,However the function is much faster than dictGetRandomKey()  at producing N elements.,1,0,0,1
2285," internal hash table id, 0 or 1.",0,0,0,0
2286, 1 or 2 tables?,0,1,0,1
2287, Try to do a rehashing work proportional to 'count'.,0,1,0,1
2288, Pick a random point inside the larger table.,1,1,0,1
2289, Continuous empty entries so far.,1,1,0,1
2290," Invariant of the dict.c rehashing: up to the indexes already              visited in ht[0] during the rehashing, there are no populated              buckets, so we can skip ht[0] for indexes between 0 and idx-1.",0,0,0,0
2291," Moreover, if we are currently out of range in the second                  table, there will be no elements in both tables up to                  the current rehashing index, so we jump if possible.",1,0,0,1
2292,(this happens when going from big to small table).,1,1,0,1
2293, Out of range for this table.,0,1,0,1
2294," Count contiguous empty buckets, and jump to other              locations if they reach 'count' (with a minimum of 5).",1,0,0,1
2295, Collect all the elements of the buckets found non                      empty while iterating.,1,0,0,1
2296, Function to reverse bits.,0,1,0,1
2297,Algorithm from:  http: or  or graphics.stanford.edu or ~seander or bithacks.html#ReverseParallel,0,0,0,0
2298, bit size; must be power of 2,0,0,0,0
2299, dictScan() is used to iterate over the elements of a dictionary.,0,0,0,0
2300,Iterating works the following way:   1) Initially you call the function using a cursor (v) value of 0.,1,0,0,1
2301,"2) The function performs one step of the iteration, and returns the     new cursor value you must use in the next call.",1,0,0,1
2302,"3) When the returned cursor is 0, the iteration is complete.",1,1,0,1
2303,The function guarantees all elements present in the  dictionary get returned between the start and end of the iteration.,0,0,0,0
2304,However it is possible some elements get returned multiple times.,1,0,0,1
2305,"For every element returned, the callback argument 'fn' is  called with 'privdata' as first argument and the dictionary entry  'de' as second argument.",1,0,0,1
2306,HOW IT WORKS.,0,1,0,1
2307,The iteration algorithm was designed by Pieter Noordhuis.,0,0,0,0
2308,The main idea is to increment a cursor starting from the higher order  bits.,1,0,0,1
2309,"That is, instead of incrementing the cursor normally, the bits  of the cursor are reversed, then the cursor is incremented, and finally  the bits are reversed again.",1,0,0,1
2310,This strategy is needed because the hash table may be resized between  iteration calls.,0,0,0,0
2311,"dict.c hash tables are always power of two in size, and they  use chaining, so the position of an element in a given table is given  by computing the bitwise AND between Hash(key) and SIZE-1  (where SIZE-1 is always the mask that is equivalent to taking the rest   of the division between the Hash of the key and SIZE).",1,0,0,1
2312,"For example if the current hash table size is 16, the mask is  (in binary) 1111.",1,0,0,1
2313,"The position of a key in the hash table will always be  the last four bits of the hash output, and so forth.",1,0,0,1
2314,WHAT HAPPENS IF THE TABLE CHANGES IN SIZE?,0,1,0,1
2315,"If the hash table grows, elements can go anywhere in one multiple of  the old bucket: for example let's say we already iterated with  a 4 bit cursor 1100 (the mask is 1111 because hash table size = 16).",1,0,0,1
2316,"If the hash table will be resized to 64 elements, then the new mask will  be 111111.",1,0,0,1
2317,The new buckets you obtain by substituting in ?,1,1,0,1
2318,?1100  with either 0 or 1 can be targeted only by keys we already visited  when scanning the bucket 1100 in the smaller hash table.,1,0,0,1
2319,"By iterating the higher bits first, because of the inverted counter, the  cursor does not need to restart if the table size gets bigger.",1,0,0,1
2320,"It will  continue iterating using cursors without '1100' at the end, and also  without any other combination of the final 4 bits already explored.",1,0,0,1
2321,"Similarly when the table size shrinks over time, for example going from  16 to 8, if a combination of the lower three bits (the mask for size 8  is 111) were already completely explored, it would not be visited again  because we are sure we tried, for example, both 0111 and 1111 (all the  variations of the higher bit) so we don't need to test it again.",1,0,0,1
2322,WAIT... YOU HAVE TWO TABLES DURING REHASHING!,0,1,0,1
2323,"Yes, this is true, but we always iterate the smaller table first, then  we test all the expansions of the current cursor into the larger  table.",1,0,0,1
2324,"For example if the current cursor is 101 and we also have a  larger table of size 16, we also test (0)101 and (1)101 inside the larger  table.",1,0,0,1
2325,"This reduces the problem back to having only one table, where  the larger one, if it exists, is just an expansion of the smaller one.",1,0,0,1
2326,"LIMITATIONS   This iterator is completely stateless, and this is a huge advantage,  including no additional memory used.",1,0,0,1
2327,The disadvantages resulting from this design are:   1) It is possible we return elements more than once.,1,0,0,1
2328,However this is usually     easy to deal with in the application level.,1,0,0,1
2329,"2) The iterator must return multiple elements per call, as it needs to always     return all the keys chained in a given bucket, and all the expansions, so     we are sure we don't miss keys moving during rehashing.",1,0,0,1
2330,"3) The reverse cursor is somewhat hard to understand at first, but this     comment is supposed to help.",1,0,0,1
2331, Emit entries at cursor,0,1,0,1
2332, Make sure t0 is the smaller and t1 is the bigger table,1,1,0,1
2333, Emit entries at cursor,0,1,0,1
2334, Iterate over indices in larger table that are the expansion          of the index pointed to by the cursor in the smaller table,1,0,0,1
2335, Emit entries at cursor,0,1,0,1
2336, Increment bits not covered by the smaller mask,1,1,0,1
2337, Continue while bits covered by mask difference is non-zero,0,1,0,1
2338, Set unmasked bits so incrementing the reversed cursor      operates on the masked bits of the smaller table,1,0,0,1
2339, Increment the reverse cursor,0,1,0,1
2340, ------------------------- private functions ------------------------------,1,1,0,1
2341, Expand the hash table if needed,0,1,0,1
2342, Incremental rehashing already in progress.,0,1,0,1
2343,Return.,0,1,0,1
2344, If the hash table is empty expand it to the initial size.,1,0,0,1
2345," If we reached the 1:1 ratio, and we are allowed to resize the hash      table (global setting) or we should avoid it but the ratio between      elements or buckets is over the ""safe"" threshold, we resize doubling      the number of buckets.",1,0,0,1
2346, Our hash table capability is a power of two,0,1,0,1
2347, Returns the index of a free slot that can be populated with  a hash entry for the given 'key'.,1,0,0,1
2348,"If the key already exists, -1 is returned  and the optional output parameter may be filled.",1,0,0,1
2349,"Note that if we are in the process of rehashing the hash table, the  index is always returned in the context of the second (new) hash table.",1,0,0,1
2350, Expand the hash table if needed,0,1,0,1
2351, Search if this slot does not already contain the given key,1,1,0,1
2352, Finds the dictEntry reference by using pointer and pre-calculated hash.,0,0,0,0
2353,oldkey is a dead pointer and should not be accessed.,1,0,0,1
2354,the hash value should be provided using dictGetHash.,0,0,0,0
2355,no string  or  key comparison is performed.,1,0,0,1
2356,"return value is the reference to the dictEntry if found, or NULL if not found.",0,0,0,0
2357, dict is empty,1,0,0,1
2358, ------------------------------- Debugging ---------------------------------,0,1,0,1
2359, Compute stats.,0,1,0,1
2360, For each hash entry on this slot...,0,1,0,1
2361, Generate human readable stats.,1,1,0,1
2362," Unlike snprintf(), teturn the number of characters actually written.",1,0,0,1
2363, Make sure there is a NULL term at the end.,1,1,0,1
2364, ------------------------------- Benchmark ---------------------------------,0,1,0,1
2365, dict-benchmark [count],0,0,0,0
2366, Wait for rehashing.,0,1,0,1
2367, Change first number to letter.,1,1,0,1
2368, Toggle the 16 bit unsigned integer pointed by p from little endian to  big endian,1,0,0,1
2369, Toggle the 32 bit unsigned integer pointed by p from little endian to  big endian,1,0,0,1
2370, Toggle the 64 bit unsigned integer pointed by p from little endian to  big endian,1,0,0,1
2371, ----------------------------------------------------------------------------  Data structures  --------------------------------------------------------------------------,0,0,0,0
2372, To improve the quality of the LRU approximation we take a set of keys  that are good candidate for eviction across freeMemoryIfNeeded() calls.,1,0,0,1
2373,"Entries inside the eviciton pool are taken ordered by idle time, putting  greater idle times to the right (ascending order).",1,0,0,1
2374,"When an LFU policy is used instead, a reverse frequency indication is used  instead of the idle time, so that we still evict by larger value (larger  inverse frequency means to evict keys with the least frequent accesses).",1,0,0,1
2375,Empty entries have the key pointer set to NULL.,1,1,0,1
2376, Object idle time (inverse frequency for LFU),0,1,0,1
2377, Key name.,1,1,0,1
2378, Cached SDS object for key name.,1,1,0,1
2379, Key DB number.,1,1,0,1
2380," ----------------------------------------------------------------------------  Implementation of eviction, aging and LRU  --------------------------------------------------------------------------",0,0,0,0
2381," Return the LRU clock, based on the clock resolution.",0,1,0,1
2382,This is a time  in a reduced-bits format that can be used to set and check the  object->lru field of redisObject structures.,0,0,0,0
2383, This function is used to obtain the current LRU clock.,1,1,0,1
2384,"If the current resolution is lower than the frequency we refresh the  LRU clock (as it should be in production servers) we return the  precomputed value, otherwise we need to resort to a system call.",1,0,0,1
2385," Given an object returns the min number of milliseconds the object was never  requested, using an approximated LRU algorithm.",0,0,0,0
2386," freeMemoryIfNeeded() gets called when 'maxmemory' is set on the config  file to limit the max memory used by the server, before processing a  command.",0,0,0,0
2387,The goal of the function is to free enough memory to keep Redis under the  configured memory limit.,1,0,0,1
2388,"The function starts calculating how many bytes should be freed to keep  Redis under the limit, and enters a loop selecting the best keys to  evict accordingly to the configured policy.",1,0,0,1
2389,"If all the bytes needed to return back under the limit were freed the  function returns C_OK, otherwise C_ERR is returned, and the caller  should block the execution of commands that will result in more memory  used by the server.",1,0,0,1
2390,#NAME?,1,0,0,1
2391,"Every time there is a key to expire, we sample N keys (with  N very small, usually in around 5) to populate a pool of best keys to  evict of M keys (the pool size is defined by EVPOOL_SIZE).",1,0,0,1
2392,The N keys sampled are added in the pool of good keys to expire (the one  with an old access time) if they are better than one of the current keys  in the pool.,1,0,0,1
2393,"After the pool is populated, the best key we have in the pool is expired.",1,1,0,1
2394,However note that we don't remove keys from the pool when they are deleted  so the pool may contain keys that no longer exist.,0,0,0,0
2395,"When we try to evict a key, and all the entries in the pool don't exist  we populate it again.",1,0,0,1
2396,"This time we'll be sure that the pool has at least  one key that can be evicted, if there is at least one key that can be  evicted in the whole database.",1,0,0,1
2397, Create a new eviction pool.,1,1,0,1
2398," This is an helper function for freeMemoryIfNeeded(), it is used in order  to populate the evictionPool with a few entries every time we want to  expire a key.",1,0,0,1
2399,Keys with idle time smaller than one of the current  keys are added.,1,0,0,1
2400,Keys are always added if there are free entries.,1,1,0,1
2401,"We insert keys on place in ascending order, so keys with the smaller  idle time are on the left, and keys with the higher idle time on the  right.",1,0,0,1
2402, If the dictionary we are sampling from is not the main          dictionary (but the expires one) we need to lookup the key          again in the key dictionary to obtain the value object.,1,0,0,1
2403, Calculate the idle time according to the policy.,0,1,0,1
2404,"This is called          idle just because the code initially handled LRU, but is in fact          just a score where an higher score means better candidate.",1,0,0,1
2405," When we use an LRU policy, we sort the keys by idle time              so that we expire keys starting from greater idle time.",1,0,0,1
2406,"However when the policy is an LFU one, we have a frequency              estimation, and we want to evict keys with lower frequency              first.",1,0,0,1
2407,So inside the pool we put objects using the inverted              frequency subtracting the actual frequency to the maximum              frequency of 255.,1,0,0,1
2408, In this case the sooner the expire the better.,1,0,0,1
2409, Insert the element inside the pool.,0,1,0,1
2410,"First, find the first empty bucket or the first populated          bucket that has an idle time smaller than our idle time.",1,0,0,1
2411, Can't insert if the element is < the worst element we have              and there are no empty buckets.,1,0,0,1
2412, Inserting into empty position.,1,1,0,1
2413,No setup needed before insert.,0,1,0,1
2414, Inserting in the middle.,0,1,0,1
2415,Now k points to the first element              greater than the element to insert.,1,0,0,1
2416, Free space on the right?,1,1,0,1
2417,Insert at k shifting                  all the elements from k to end to the right.,1,0,0,1
2418, Save SDS before overwriting.,0,1,0,1
2419, No free space on right?,1,1,0,1
2420,Insert at k-1,0,1,0,1
2421," Shift all elements on the left of k (included) to the                  left, so we discard the element with smaller idle time.",1,0,0,1
2422, Save SDS before overwriting.,0,1,0,1
2423," Try to reuse the cached SDS string allocated in the pool entry,          because allocating and deallocating this object is costly          (according to the profiler, not my fantasy.",0,0,0,0
2424,Remember:          premature optimizbla bla bla bla.,0,0,0,0
2425, ----------------------------------------------------------------------------  LFU (Least Frequently Used) implementation.,1,0,0,1
2426,"We have 24 total bits of space in each object in order to implement  an LFU (Least Frequently Used) eviction policy, since we re-use the  LRU field for this purpose.",1,0,0,1
2427,We split the 24 bits into two fields:            16 bits      8 bits      +----------------+--------+      + Last decr time | LOG_C  |      +----------------+--------+   LOG_C is a logarithmic counter that provides an indication of the access  frequency.,1,0,0,1
2428,"However this field must also be decremented otherwise what used  to be a frequently accessed key in the past, will remain ranked like that  forever, while we want the algorithm to adapt to access pattern changes.",1,0,0,1
2429,"So the remaining 16 bits are used in order to store the ""decrement time"",  a reduced-precision Unix time (we take 16 bits of the time converted  in minutes since we don't care about wrapping around) where the LOG_C  counter is halved if it has an high value, or just decremented if it  has a low value.",1,0,0,1
2430,"New keys don't start at zero, in order to have the ability to collect  some accesses before being trashed away, so they start at COUNTER_INIT_VAL.",1,0,0,1
2431,"The logarithmic increment performed on LOG_C takes care of COUNTER_INIT_VAL  when incrementing the key, so that keys starting at COUNTER_INIT_VAL  (or having a smaller value) have a very high chance of being incremented  on access.",1,0,0,1
2432,"During decrement, the value of the logarithmic counter is halved if  its current value is greater than two times the COUNTER_INIT_VAL, otherwise  it is just decremented by one.",1,0,0,1
2433," Return the current time in minutes, just taking the least significant  16 bits.",1,0,0,1
2434,The returned time is suitable to be stored as LDT (last decrement  time) for the LFU implementation.,1,0,0,1
2435," Given an object last access time, compute the minimum number of minutes  that elapsed since the last access.",1,0,0,1
2436,Handle overflow (ldt greater than  the current 16 bits minutes time) considering the time as wrapping  exactly once.,1,0,0,1
2437, Logarithmically increment a counter.,0,0,0,0
2438,The greater is the current counter value  the less likely is that it gets really implemented.,1,0,0,1
2439,Saturate it at 255.,0,1,0,1
2440," If the object decrement time is reached decrement the LFU counter but  do not update LFU fields of the object, we update the access time  and counter in an explicit way when the object is really accessed.",1,0,0,1
2441,And we will times halve the counter according to the times of  elapsed time than server.lfu_decay_time.,0,0,0,0
2442,Return the object frequency counter.,0,1,0,1
2443,"This function is used in order to scan the dataset for the best object  to fit: as we check for the candidate, we incrementally decrement the  counter of the scanned objects if needed.",1,0,0,1
2444, ----------------------------------------------------------------------------  The external API for eviction: freeMemroyIfNeeded() is called by the  server when there is data to add in order to make space if needed.,1,0,0,1
2445, We don't want to count AOF buffers and slaves output buffers as  used memory: the eviction should use mostly data size.,1,0,0,1
2446,This function  returns the sum of AOF and slaves buffer.,0,0,0,0
2447, Get the memory status from the point of view of the maxmemory directive:  if the memory used is under the maxmemory setting then C_OK is returned.,0,0,0,0
2448,"Otherwise, if we are over the memory limit, the function returns  C_ERR.",0,0,0,0
2449,"The function may return additional info via reference, only if the  pointers to the respective arguments is not NULL.",1,0,0,1
2450,Certain fields are  populated only when C_ERR is returned:    'total'     total amount of bytes used.,1,0,0,1
2451,(Populated both for C_ERR and C_OK)    'logical'   the amount of memory used minus the slaves or AOF buffers.,1,0,0,1
2452,(Populated when C_ERR is returned)    'tofree'    the amount of memory that should be released               in order to return back into the memory limits.,0,0,0,0
2453,"(Populated when C_ERR is returned)    'level'     this usually ranges from 0 to 1, and reports the amount of               memory currently used.",1,0,0,1
2454,May be > 1 if we are over the memory               limit.,0,0,0,0
2455,(Populated both for C_ERR and C_OK),0,1,0,1
2456, Check if we are over the memory usage limit.,0,1,0,1
2457,"If we are not, no need      to subtract the slaves output buffers.",0,0,0,0
2458,We can just return ASAP.,0,1,0,1
2459, We may return ASAP if there is no need to compute the level.,0,1,0,1
2460, Remove the size of slaves output buffers and AOF buffer from the      count of used memory.,0,0,0,0
2461, Compute the ratio of memory usage.,0,1,0,1
2462, Check if we are still over the memory limit.,0,1,0,1
2463, Compute how much memory we need to free.,1,1,0,1
2464," This function is periodically called to see if there is memory to free  according to the current ""maxmemory"" settings.",1,0,0,1
2465,"In case we are over the  memory limit, the function will try to free some memory to return back  under the limit.",1,0,0,1
2466,"The function returns C_OK if we are under the memory limit or if we  were over the limit, but the attempt to free memory was successful.",1,0,0,1
2467,"Otehrwise if we are over the memory limit, but not enough memory  was freed to return back under the limit, the function returns C_ERR.",1,0,0,1
2468," When clients are paused the dataset should be static not just from the      POV of clients not being able to write, but also from the POV of      expires and evictions of keys not being performed.",1,0,0,1
2469," We need to free memory, but policy forbids.",1,1,0,1
2470," We don't want to make local-db choices when expiring keys,                  so to start populate the eviction pool sampling keys from                  every DB.",0,0,0,0
2471, No keys to evict.,0,1,0,1
2472, Go backward from best to worst element to evict.,1,0,0,1
2473, Remove the entry from the pool.,0,1,0,1
2474," If the key exists, is our pick.",1,1,0,1
2475,Otherwise it is                      a ghost and we need to try the next element.,0,0,0,0
2476, Ghost... Iterate again.,0,1,0,1
2477, volatile-random and allkeys-random policy,0,0,0,0
2478," When evicting a random key, we try to evict a key for              each DB, so we use the static 'next_db' variable to              incrementally visit all DBs.",1,0,0,1
2479, Finally remove the selected key.,1,0,0,1
2480, We compute the amount of memory freed by dbDelete() alone.,0,0,0,0
2481,"It is possible that actually the memory needed to propagate              the DEL in AOF and replication link is greater than the one              we are freeing removing the key, but we can't account for              that otherwise we would never exit the loop.",1,0,0,1
2482,AOF and Output buffer memory will be freed eventually so              we only care about memory used by the key space.,1,0,0,1
2483," When the memory to free starts to be big enough, we may              start spending so much time here that is impossible to              deliver data to the slaves fast enough, so we force the              transmission here inside the loop.",1,0,0,1
2484," Normally our stop condition is the ability to release              a fixed, pre-computed amount of memory.",1,0,0,1
2485,"However when we              are deleting objects in another thread, it's better to              check, from time to time, if we already reached our target              memory, since the ""mem_freed"" amount is computed only              across the dbAsyncDelete() call, while the thread can              release the memory all the time.",1,0,0,1
2486, Let's satisfy our stop condition.,0,1,0,1
2487, nothing to free...,1,0,0,1
2488, We are here if we are not able to reclaim memory.,1,1,0,1
2489,There is only one      last thing we can try: check if the lazyfree thread has jobs in queue      and wait...,1,0,0,1
2490,#NAME?,0,0,0,0
2491,When keys are accessed they are expired on-access.,0,0,0,0
2492,However we need a  mechanism in order to ensure keys are eventually removed when expired even  if no access is performed on them.,0,0,0,0
2493, Helper function for the activeExpireCycle() function.,0,0,0,0
2494,This function will try to expire the key that is stored in the hash table  entry 'de' of the 'expires' hash table of a Redis database.,1,0,0,1
2495,"If the key is found to be expired, it is removed from the database and  1 is returned.",1,0,0,1
2496,Otherwise no operation is performed and 0 is returned.,0,0,0,0
2497,"When a key is expired, server.stat_expiredkeys is incremented.",1,0,0,1
2498,The parameter 'now' is the current time in milliseconds as is passed  to the function to avoid too many gettimeofday() syscalls.,1,0,0,1
2499, Try to expire a few timed out keys.,1,1,0,1
2500,"The algorithm used is adaptive and  will use few CPU cycles if there are few expiring keys, otherwise  it will get more aggressive to avoid that too much memory is used by  keys that can be removed from the keyspace.",1,0,0,1
2501,No more than CRON_DBS_PER_CALL databases are tested at every  iteration.,1,0,0,1
2502,"This kind of call is used when Redis detects that timelimit_exit is  true, so there is more work to do, and we do it more incrementally from  the beforeSleep() function of the event loop.",1,0,0,1
2503,"Expire cycle type:   If type is ACTIVE_EXPIRE_CYCLE_FAST the function will try to run a  ""fast"" expire cycle that takes no longer than EXPIRE_FAST_CYCLE_DURATION  microseconds, and is not repeated again before the same amount of time.",1,0,0,1
2504,"If type is ACTIVE_EXPIRE_CYCLE_SLOW, that normal expire cycle is  executed, where the time limit is a percentage of the REDIS_HZ period  as specified by the ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC define.",1,0,0,1
2505, This function has some global state in order to continue the work      incrementally across calls.,0,0,0,0
2506, Last DB tested.,1,1,0,1
2507, Time limit hit in previous call?,1,1,0,1
2508, When last fast cycle ran.,1,0,0,1
2509," When clients are paused the dataset should be static not just from the      POV of clients not being able to write, but also from the POV of      expires and evictions of keys not being performed.",1,0,0,1
2510, Don't start a fast cycle if the previous cycle did not exit          for time limt.,1,0,0,1
2511,Also don't repeat a fast cycle for the same period          as the fast cycle total duration itself.,1,0,0,1
2512," We usually should test CRON_DBS_PER_CALL per iteration, with      two exceptions:           1) Don't test more DBs than we have.",1,0,0,1
2513,"2) If last time we hit the time limit, we want to scan all DBs      in this iteration, as there is work to do in some DB and we don't want      expired keys to use memory for too much time.",1,0,0,1
2514, We can use at max ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC percentage of CPU time      per iteration.,0,0,0,0
2515,"Since this function gets called with a frequency of      server.hz times per second, the following is the max amount of      microseconds we can spend in this function.",1,0,0,1
2516, in microseconds.,0,0,0,0
2517," Accumulate some global stats as we expire keys, to have some idea      about the number of keys that are already logically expired, but still      existing inside the database.",1,0,0,1
2518, Increment the DB now so we are sure if we run out of time          in the current DB we'll restart from the next.,1,0,0,1
2519,This allows to          distribute the time evenly across DBs.,0,0,0,0
2520, Continue to expire if at the end of the cycle more than 25%          of the keys were expired.,1,0,0,1
2521, If there is nothing to expire try next DB ASAP.,0,0,0,0
2522," When there are less than 1% filled slots getting random              keys is expensive, so stop here waiting for better times...",1,0,0,1
2523,The dictionary will be resized asap.,0,0,0,0
2524, The main collection cycle.,1,1,0,1
2525,"Sample random keys among keys              with an expire set, checking for expired ones.",1,0,0,1
2526, We want the average TTL of keys yet not expired.,1,1,0,1
2527, Update the average TTL stats for this database.,1,1,0,1
2528, Do a simple running average with a few samples.,1,1,0,1
2529,We just use the current estimate with a weight of 2%                  and the previous estimate with a weight of 98%.,1,0,0,1
2530, We can't block forever here even if there are many keys to              expire.,1,0,0,1
2531,So after a given amount of milliseconds return to the              caller waiting for the other active expire cycle.,1,0,0,1
2532, check once every 16 iterations.,0,0,0,0
2533, We don't repeat the cycle if there are less than 25% of keys              found expired in the current DB.,1,0,0,1
2534, Update our estimate of keys existing but yet to be expired.,0,1,0,1
2535,Running average with this sample accounting for 5%.,1,1,0,1
2536,#NAME?,1,0,0,1
2537,"However writable slaves are  an exception: if a key is created in the slave and an expire is assigned  to it, we need a way to expire such a key, since the master does not know  anything about such a key.",1,0,0,1
2538,"In order to do so, we track keys created in the slave side with an expire  set, and call the expireSlaveKeys() function from time to time in order to  reclaim the keys if they already expired.",0,0,0,0
2539,"Note that the use case we are trying to cover here, is a popular one where  slaves are put in writable mode in order to compute slow operations in  the slave side that are mostly useful to actually read data in a more  processed way.",1,0,0,1
2540,"Think at sets intersections in a tmp key, with an expire so  that it is also used as a cache to avoid intersecting every time.",1,0,0,1
2541,This implementation is currently not perfect but a lot better than leaking  the keys as implemented in 3.2.,1,0,0,1
2542, The dictionary where we remember key names and database ID of keys we may  want to expire from the slave.,1,0,0,1
2543,Since this function is not often used we  don't even care to initialize the database at startup.,0,0,0,0
2544,"We'll do it once  the feature is used the first time, that is, when rememberSlaveKeyWithExpire()  is called.",1,0,0,1
2545,"The dictionary has an SDS string representing the key as the hash table  key, while the value is a 64 bit unsigned integer with the bits corresponding  to the DB where the keys may exist set to 1.",1,0,0,1
2546,"Currently the keys created  with a DB id > 63 are not expired, but a trivial fix is to set the bitmap  to the max 64 bit unsigned value when we know there is a key with a DB  ID greater than 63, and check all the configured DBs in such a case.",1,0,0,1
2547, Check the set of keys created by the master with an expire set in order to  check if they should be evicted.,0,0,0,0
2548, Check the key against every database corresponding to the          bits set in the value bitmap.,1,0,0,1
2549," If the key was not expired in this DB, we need to set the                  corresponding bit in the new bitmap we set as value.",1,0,0,1
2550,"At the end of the loop if the bitmap is zero, it means we                  no longer need to keep track of this key.",1,0,0,1
2551," Set the new bitmap as value of the key, in the dictionary          of keys with an expire set directly in the writable slave.",1,0,0,1
2552,"Otherwise          if the bitmap is zero, we no longer need to keep track of it.",0,0,0,0
2553, Stop conditions: found 3 keys we cna't expire in a row or          time limit was reached.,0,0,0,0
2554, Track keys that received an EXPIRE or similar command in the context  of a writable slave.,1,0,0,1
2555, hash function,0,0,0,0
2556, key dup,1,0,0,1
2557, val dup,0,0,0,0
2558, key compare,1,0,0,1
2559, key destructor,1,0,0,1
2560, val destructor,0,0,0,0
2561," If the entry was just created, set it to a copy of the SDS string      representing the key: we don't want to need to take those keys      in sync with the main DB.",1,0,0,1
2562,The keys will be removed by expireSlaveKeys()      as it scans to find keys to remove.,0,0,0,0
2563, Return the number of keys we are tracking.,0,1,0,1
2564, Remove the keys in the hash table.,0,1,0,1
2565,We need to do that when data is  flushed from the server.,0,0,0,0
2566,We may receive new keys from the master with  the same name or db and it is no longer a good idea to expire them.,1,0,0,1
2567,Note: technically we should handle the case of a single DB being flushed  but it is not worth it since anyway race conditions using the same set  of key names in a wriatable slave and in its master will lead to  inconsistencies.,1,0,0,1
2568,This is just a best-effort thing we do.,0,1,0,1
2569,-----------------------------------------------------------------------------  Expires Commands ----------------------------------------------------------------------------,0,0,0,0
2570," This is the generic command implementation for EXPIRE, PEXPIRE, EXPIREAT  and PEXPIREAT.",0,0,0,0
2571,"Because the commad second argument may be relative or absolute  the ""basetime"" argument is used to signal what the base time is (either 0  for AT variants of the command, or the current time for relative expires).",1,0,0,1
2572,"unit is either UNIT_SECONDS or UNIT_MILLISECONDS, and is only used for  the argv[2] parameter.",1,0,0,1
2573,The basetime is always specified in milliseconds.,0,0,0,0
2574, unix time in milliseconds when the key will expire.,1,0,0,1
2575," No key, return zero.",1,1,0,1
2576," EXPIRE with negative TTL, or EXPIREAT with a timestamp into the past      should never be executed as a DEL when load the AOF or in the context      of a slave instance.",1,0,0,1
2577,Instead we take the other branch of the IF statement setting an expire      (possibly in the past) and wait for an explicit DEL from the master.,1,0,0,1
2578, Replicate or AOF this as an explicit DEL or UNLINK.,0,1,0,1
2579, EXPIRE key seconds,1,1,0,1
2580, EXPIREAT key time,1,1,0,1
2581, PEXPIRE key milliseconds,1,1,0,1
2582, PEXPIREAT key ms_time,1,0,0,1
2583, Implements TTL and PTTL,0,1,0,1
2584," If the key does not exist at all, return -2",1,1,0,1
2585, The key exists.,1,1,0,1
2586,"Return -1 if it has no expire, or the actual      TTL value otherwise.",1,0,0,1
2587, TTL key,1,1,0,1
2588, PTTL key,1,1,0,1
2589, PERSIST key,1,1,0,1
2590, TOUCH key1 [key2 key3 ... keyN],0,0,0,0
2591," Things exported from t_zset.c only for geo.c, since it is the only other  part of Redis that requires close zset introspection.",1,0,0,1
2592, ====================================================================  This file implements the following commands:     - geoadd - add coordinates for value to geoset    - georadius - search radius by coordinates in geoset    - georadiusbymember - search radius based on geoset member position  ====================================================================,1,0,0,1
2593, ====================================================================  geoArray implementation  ====================================================================,0,0,0,0
2594, Create a new array of geoPoints.,1,0,0,1
2595, It gets allocated on first geoArrayAppend() call.,1,0,0,1
2596, Add a new entry and return its pointer so that the caller can populate  it with data.,1,0,0,1
2597, Destroy a geoArray created with geoArrayCreate().,0,0,0,0
2598, ====================================================================  Helpers  ====================================================================,0,0,0,0
2599, Input Argument Helper,0,1,0,1
2600, Take a pointer to the latitude arg then use the next arg for longitude.,0,0,0,0
2601,"On parse error C_ERR is returned, otherwise C_OK.",0,1,0,1
2602, Input Argument Helper,0,1,0,1
2603, Decode lat or long from a zset member's score.,1,0,0,1
2604,"Returns C_OK on successful decoding, otherwise C_ERR is returned.",1,1,0,1
2605," Check that the unit argument matches one of the known units, and returns  the conversion factor to meters (you need to divide meters by the conversion  factor to convert to the right unit).",1,0,0,1
2606,"If the unit is not valid, an error is reported to the client, and a value  less than zero is returned.",1,0,0,1
2607, Input Argument Helper.,0,1,0,1
2608,Extract the dinstance from the specified two arguments starting at 'argv'  that shouldbe in the form: <number> <unit> and return the dinstance in the  specified unit on success.,1,0,0,1
2609,conversino is populated with the coefficient  to use in order to convert meters to the unit.,0,0,0,0
2610,On error a value less than zero is returned.,1,1,0,1
2611, The default addReplyDouble has too much accuracy.,1,0,0,1
2612,We use this  for returning location distances.,0,0,0,0
2613,"""5.2145 meters away"" is nicer  than ""5.2144992818115 meters away.""",0,0,0,0
2614,We provide 4 digits after the dot  so that the returned value is decently accurate even when the unit is  the kilometer.,1,0,0,1
2615," Helper function for geoGetPointsInRange(): given a sorted set score  representing a point, and another point (the center of our search) and  a radius, appends this entry as a geoPoint into the specified geoArray  only if the point is within the search area.",1,0,0,1
2616,"returns C_OK if the point is included, or REIDS_ERR if it is outside.",1,0,0,1
2617, Can't decode.,0,1,0,1
2618," Note that geohashGetDistanceIfInRadiusWGS84() takes arguments in      reverse order: longitude first, latitude later.",1,0,0,1
2619, Append the new element.,1,1,0,1
2620," Query a Redis sorted set to extract all the elements between 'min' and  'max', appending them into the array of geoPoint structures 'gparray'.",0,0,0,0
2621,The command returns the number of elements added to the array.,0,1,0,1
2622,Elements which are farest than 'radius' from the specified 'x' and 'y'  coordinates are not included.,0,0,0,0
2623,"The ability of this function to append to an existing set of points is  important for good performances because querying by radius is performed  using multiple queries to the sorted set, that we later need to sort  via qsort.",1,0,0,1
2624,Similarly we need to be able to reject points outside the search  radius area ASAP in order to allocate and process more points than needed.,1,0,0,1
2625, minex 0 = include min in range; maxex 1 = exclude max in range,0,0,0,0
2626, That's: min <= val < max,0,1,0,1
2627, Nothing exists starting at our min.,1,1,0,1
2628,No results.,0,1,0,1
2629," If we fell out of range, break.",0,1,0,1
2630, We know the element exists.,0,1,0,1
2631,ziplistGet should always succeed,0,0,0,0
2632, Nothing exists starting at our min.,1,1,0,1
2633,No results.,0,1,0,1
2634, Abort when the node is no longer in range.,0,1,0,1
2635," Compute the sorted set scores min (inclusive), max (exclusive) we should  query in order to retrieve all the elements inside the specified area  'hash'.",0,0,0,0
2636,The two scores are returned by reference in min and max.,0,1,0,1
2637," We want to compute the sorted set scores that will include all the      elements inside the specified Geohash 'hash', which has as many      bits as specified by hash.step  2.",1,0,0,1
2638,"So if step is, for example, 3, and the hash value in binary      is 101010, since our score is 52 bits we want every element which      is in binary: 101010?????????????????????????????????????????????",0,0,0,0
2639,Where ?,0,0,0,0
2640,can be 0 or 1.,0,0,0,0
2641,To get the min score we just use the initial hash value left      shifted enough to get the 52 bit value.,1,0,0,1
2642,"Later we increment the      6 bit prefis (see the hash.bits++ statement), and get the new      prefix: 101011, which we align again to 52 bits to get the maximum      value (which is excluded from the search).",1,0,0,1
2643,So we get everything      between the two following scores (represented in binary):           1010100000000000000000000000000000000000000000000000 (included)      and      1010110000000000000000000000000000000000000000000000 (excluded).,1,0,0,1
2644, Obtain all members between the min or max of this geohash bounding box.,0,0,0,0
2645,Populate a geoArray of GeoPoints by calling geoGetPointsInRange().,0,0,0,0
2646,Return the number of points added to the array.,0,1,0,1
2647, Search all eight neighbors + self geohash box,0,0,0,0
2648," For each neighbor (and our own hashbox), get all the matching      members and add them to the potential result list.",1,0,0,1
2649, Debugging info.,0,1,0,1
2650, Dump center square.,1,1,0,1
2651," When a huge Radius (in the 5000 km range or more) is used,          adjacent neighbors can be the same, leading to duplicated          elements.",1,0,0,1
2652,Skip every range which is the same as the one          processed previously.,1,0,0,1
2653, Sort comparators for qsort(),0,0,0,0
2654, We can't do adist - bdist because they are doubles and      the comparator returns an int.,0,0,0,0
2655, ====================================================================  Commands  ====================================================================,0,0,0,0
2656, GEOADD key long lat name [long2 lat2 name2 ... longN latN nameN],1,0,0,1
2657, Check arguments number for sanity.,0,1,0,1
2658, Need an odd number of arguments if we got this far...,1,1,0,1
2659, ZADD key score ele ...,1,0,0,1
2660, key,1,0,0,1
2661," Create the argument vector to call ZADD in order to add all      the score,value pairs to the requested zset, where score is actually      an encoded version of lat,long.",1,0,0,1
2662, Turn the coordinates into the score of the element.,0,1,0,1
2663, Finally call ZADD that will do the work for us.,1,0,0,1
2664, Search around coordinates.,0,1,0,1
2665, Search around member.,0,1,0,1
2666, Do not acceot STORE or STOREDIST option.,0,0,0,0
2667, GEORADIUS key x y radius unit [WITHDIST] [WITHHASH] [WITHCOORD] [ASC|DESC]                                [COUNT count] [STORE key] [STOREDIST key]  GEORADIUSBYMEMBER key member radius unit ... options ...,1,0,0,1
2668," 0 for STORE, 1 for STOREDIST.",0,1,0,1
2669, Look up the requested zset,0,0,0,0
2670, Find long or lat to use for radius search based on inquiry type,1,1,0,1
2671, Extract radius and units from arguments,0,1,0,1
2672, Discover and populate all optional parameters.,0,1,0,1
2673, Trap options not compatible with STORE and STOREDIST.,0,1,0,1
2674," COUNT without ordering does not make much sense, force ASC      ordering if COUNT was specified but no sorting was requested.",1,0,0,1
2675, Get all neighbor geohash boxes for our radius search,0,0,0,0
2676, Search the zset for all matching points,0,0,0,0
2677," If no matching results, the user gets an empty reply.",1,1,0,1
2678, Process [optional] requested sorting,0,1,0,1
2679," No target key, return results to user.",1,1,0,1
2680," Our options are self-contained nested multibulk replies, so we          only need to track how many of those nested replies we return.",1,0,0,1
2681, The multibulk len we send is exactly result_length.,1,0,0,1
2682,The result is          either all strings of just zset members  or a nested multi-bulk          reply containing the zset member string _and_ all the additional          options the user enabled for this request.,0,0,0,0
2683, Finally send results back to the caller,1,0,0,1
2684, Fix according to unit.,0,1,0,1
2685," If we have options in option_length, return each sub-result              as a nested multi-bulk.",0,0,0,0
2686,Add 1 to account for result value              itself.,0,0,0,0
2687," Target key, create a sorted set with the results.",1,1,0,1
2688, Fix according to unit.,0,1,0,1
2689, GEORADIUS wrapper function.,0,1,0,1
2690, GEORADIUSBYMEMBER wrapper function.,0,1,0,1
2691, GEORADIUS_RO wrapper function.,0,1,0,1
2692, GEORADIUSBYMEMBER_RO wrapper function.,0,1,0,1
2693, GEOHASH key ele1 ele2 ... eleN   Returns an array with an 11 characters geohash representation of the  position of the specified elements.,1,0,0,1
2694, Look up the requested zset,0,0,0,0
2695," Geohash elements one after the other, using a null bulk reply for      missing elements.",1,0,0,1
2696," The internal format we use for geocoding is a bit different              than the standard, since we use as initial latitude range              -85,85, while the normal geohashing algorithm uses -90,90.",1,0,0,1
2697,So we have to decode our position and re-encode using the              standard ranges in order to output a valid geohash string.,0,0,0,0
2698, Decode...,0,1,0,1
2699, Re-encode,0,1,0,1
2700," GEOPOS key ele1 ele2 ... eleN   Returns an array of two-items arrays representing the x,y position of each  element specified in the arguments.",1,0,0,1
2701,For missing elements NULL is returned.,1,1,0,1
2702, Look up the requested zset,0,0,0,0
2703," Report elements one after the other, using a null bulk reply for      missing elements.",1,0,0,1
2704, Decode...,0,1,0,1
2705," GEODIST key ele1 ele2 [unit]   Return the distance, in meters by default, otherwise accordig to ""unit"",  between points ele1 and ele2.",1,0,0,1
2706,If one or more elements are missing NULL  is returned.,1,0,0,1
2707," Check if there is the unit to extract, otherwise assume meters.",0,1,0,1
2708, Look up the requested zset,0,0,0,0
2709, Get the scores.,0,1,0,1
2710,We need both otherwise NULL is returned.,0,1,0,1
2711, Decode & compute the distance.,0,1,0,1
2712,  Hashing works like this:  Divide the world into 4 buckets.,0,0,0,0
2713,"Label each one as such:   -----------------   |       |       |   |       |       |   | 0,1   | 1,1   |   -----------------   |       |       |   |       |       |   | 0,0   | 1,0   |   -----------------",1,0,0,1
2714," Interleave lower bits of x and y, so the bits of x  are in the even positions and bits from y in the odd;  x and y must initially be less than 232 (65536).",1,0,0,1
2715,From:  https: or  or graphics.stanford.edu or ~seander or bithacks.html#InterleaveBMN,0,0,0,0
2716, reverse the interleave process  derived from http: or  or stackoverflow.com or questions or 4909263,0,0,0,0
2717, These are constraints from EPSG:900913  or  EPSG:3785  or  OSGEO:41001,0,0,0,0
2718, We can't geocode at the north or south pole.,0,0,0,0
2719, Check basic arguments sanity.,1,0,0,1
2720, Return an error when trying to index outside the supported      constraints.,1,0,0,1
2721, convert to fixed point based on the step size,1,0,0,1
2722, hash = [LAT][LONG],0,0,0,0
2723, get lat part of deinterleaved hash,0,0,0,0
2724, shift over to get long part of hash,1,0,0,1
2725, divide by 2step.,0,0,0,0
2726,"Then, for 0-1 coordinate, multiply times scale and add       to the min to get the absolute coordinate.",1,0,0,1
2727, This is a C++ to C conversion from the ardb project.,0,0,0,0
2728,This file started out as:  https: or  or github.com or yinqiwen or ardb or blob or d42503 or src or geo or geohash_helper.cpp,0,0,0,0
2729, or  @brief The usual PI or 180 constant,1,0,0,1
2730, or  @brief Earth's quatratic mean radius for WGS-84,1,0,0,1
2731, This function is used in order to estimate the step (bits precision)  of the 9 search area boxes during radius queries.,0,0,0,0
2732, Make sure range is included in most of the base cases.,1,1,0,1
2733, Wider range torwards the poles...,0,0,0,0
2734,"Note: it is possible to do better      than this approximation by computing the distance between meridians      at this latitude, but this does the trick for now.",1,0,0,1
2735, Frame to valid range.,0,1,0,1
2736," Return the bounding box of the search area centered at latitude,longitude  having a radius of radius_meter.",0,0,0,0
2737,"bounds[0] - bounds[2] is the minimum  and maxium longitude, while bounds[1] - bounds[3] is the minimum and  maximum latitude.",0,0,0,0
2738,"This function does not behave correctly with very large radius values, for  instance for the coordinates 81.634948934258375 30.561509253718668 and a  radius of 7083 kilometers, it reports as bounding boxes:   min_lon 7.680495, min_lat -33.119473, max_lon 155.589402, max_lat 94.242491   However, for instance, a min_lon of 7.680495 is not correct, because the  point -1.27579540014266968 61.33421815228281559 is at less than 7000  kilometers away.",1,0,0,1
2739,"Since this function is currently only used as an optimization, the  optimization is not used for very big radiuses, however the function  should be fixed.",1,0,0,1
2740, Return a set of areas (center + 8) that are able to cover a range query  for the specified position and radius.,1,0,0,1
2741, Check if the step is enough at the limits of the covered area.,1,1,0,1
2742,"Sometimes when the search area is near an edge of the      area, the estimated step is not small enough, since one of the      north  or  south  or  west  or  east square is too near to the search area      to cover everything.",1,0,0,1
2743, Exclude the search areas that are useless.,1,1,0,1
2744, Calculate distance using haversin great circle distance formula.,1,0,0,1
2745," The Redis HyperLogLog implementation is based on the following ideas:    The use of a 64 bit hash function as proposed in [1], in order to don't    limited to cardinalities up to 10^9, at the cost of just 1 additional    bit per register.",1,0,0,1
2746,"The use of 16384 6-bit registers for a great level of accuracy, using    a total of 12k per key.",1,0,0,1
2747,The use of the Redis string data type.,0,0,0,0
2748,No new type is introduced.,1,1,0,1
2749,No attempt is made to compress the data structure as in [1].,0,1,0,1
2750,"Also the    algorithm used is the original HyperLogLog Algorithm as in [2], with    the only difference that a 64 bit hash function is used, so no correction    is performed for values near 2^32 as in [1].",1,0,0,1
2751,"[1] Heule, Nunkesser, Hall: HyperLogLog in Practice: Algorithmic      Engineering of a State of The Art Cardinality Estimation Algorithm.",0,0,0,0
2752,"[2] P. Flajolet, ric Fusy, O. Gandouet, and F. Meunier.",0,0,0,0
2753,Hyperloglog: The      analysis of a near-optimal cardinality estimation algorithm.,0,0,0,0
2754,"Redis uses two representations:   1) A ""dense"" representation where every entry is represented by     a 6-bit integer.",0,0,0,0
2755,"2) A ""sparse"" representation using run length compression suitable     for representing HyperLogLogs with many registers set to 0 in     a memory efficient way.",1,0,0,1
2756,HLL header  ===   Both the dense and sparse representation have a 16 byte header as follows:   +------+---+-----+----------+  | HYLL | E | N or U | Cardin.,0,0,0,0
2757,"|  +------+---+-----+----------+   The first 4 bytes are a magic string set to the bytes ""HYLL"".",1,0,0,1
2758,"""E"" is one byte encoding, currently set to HLL_DENSE or  HLL_SPARSE.",1,0,0,1
2759,N or U are three not used bytes.,0,1,0,1
2760,"The ""Cardin.""",0,0,0,0
2761,field is a 64 bit integer stored in little endian format  with the latest cardinality computed that can be reused if the data  structure was not modified since the last computation (this is useful  because there are high probabilities that HLLADD operations don't  modify the actual data structure and hence the approximated cardinality).,1,0,0,1
2762,"When the most significant bit in the most significant byte of the cached  cardinality is set, it means that the data structure was modified and  we can't reuse the cached value that must be recomputed.",1,0,0,1
2763,"Dense representation  ===   The dense representation used by Redis is the following:   +--------+--------+--------+------ or  or        or  or --+  |11000000|22221111|33333322|55444444 ....     |  +--------+--------+--------+------ or  or        or  or --+   The 6 bits counters are encoded one after the other starting from the  LSB to the MSB, and using the next bytes as needed.",1,0,0,1
2764,"Sparse representation  ===   The sparse representation encodes registers using a run length  encoding composed of three opcodes, two using one byte, and one using  of two bytes.",0,0,0,0
2765,"The opcodes are called ZERO, XZERO and VAL.",0,0,0,0
2766,ZERO opcode is represented as 00xxxxxx.,0,0,0,0
2767,"The 6-bit integer represented  by the six bits 'xxxxxx', plus 1, means that there are N registers set  to 0.",0,0,0,0
2768,This opcode can represent from 1 to 64 contiguous registers set  to the value of 0.,0,0,0,0
2769,XZERO opcode is represented by two bytes 01xxxxxx yyyyyyyy.,0,0,0,0
2770,"The 14-bit  integer represented by the bits 'xxxxxx' as most significant bits and  'yyyyyyyy' as least significant bits, plus 1, means that there are N  registers set to 0.",1,0,0,1
2771,This opcode can represent from 0 to 16384 contiguous  registers set to the value of 0.,0,0,0,0
2772,VAL opcode is represented as 1vvvvvxx.,0,0,0,0
2773,"It contains a 5-bit integer  representing the value of a register, and a 2-bit integer representing  the number of contiguous registers set to that value 'vvvvv'.",0,0,0,0
2774,"To obtain the value and run length, the integers vvvvv and xx must be  incremented by one.",0,0,0,0
2775,"This opcode can represent values from 1 to 32,  repeated from 1 to 4 times.",0,0,0,0
2776,"The sparse representation can't represent registers with a value greater  than 32, however it is very unlikely that we find such a register in an  HLL with a cardinality where the sparse representation is still more  memory efficient than the dense representation.",1,0,0,1
2777,When this happens the  HLL is converted to the dense representation.,0,0,0,0
2778,The sparse representation is purely positional.,1,1,0,1
2779,For example a sparse  representation of an empty HLL is just: XZERO:16384.,1,0,0,1
2780,"An HLL having only 3 non-zero registers at position 1000, 1020, 1021  respectively set to 2, 3, 3, is represented by the following three  opcodes:   XZERO:1000 (Registers 0-999 are set to 0)  VAL:2,1    (1 register set to value 2, that is register 1000)  ZERO:19    (Registers 1001-1019 set to 0)  VAL:3,2    (2 registers set to value 3, that is registers 1020,1021)  XZERO:15362 (Registers 1022-16383 set to 0)   In the example the sparse representation used just 7 bytes instead  of 12k in order to represent the HLL registers.",1,0,0,1
2781,"In general for low  cardinality there is a big win in terms of space efficiency, traded  with CPU time since the sparse representation is slower to access:   The following table shows average cardinality vs bytes used, 100  samples per cardinality (when the set was not representable because  of registers with too big value, the dense representation size was used  as a sample).",1,0,0,1
2782,"100 267  200 485  300 678  400 859  500 1033  600 1205  700 1375  800 1544  900 1713  1000 1882  2000 3480  3000 4879  4000 6089  5000 7138  6000 8042  7000 8823  8000 9500  9000 10088  10000 10591   The dense representation uses 12288 bytes, so there is a big win up to  a cardinality of ~2000-3000.",1,0,0,1
2783,For bigger cardinalities the constant times  involved in updating the sparse representation is not justified by the  memory savings.,1,0,0,1
2784,The exact maximum length of the sparse representation  when this implementation switches to the dense representation is  configured via the define server.hll_sparse_max_bytes.,1,0,0,1
2785," ""HYLL""",0,0,0,0
2786, HLL_DENSE or HLL_SPARSE.,0,1,0,1
2787," Reserved for future use, must be zero.",1,1,0,1
2788," Cached cardinality, little endian.",1,0,0,1
2789, Data bytes.,0,1,0,1
2790, The cached cardinality MSB is used to signal validity of the cached value.,0,0,0,0
2791," The greater is P, the smaller the error.",1,1,0,1
2792, The number of bits of the hash value used for                            determining the number of leading zeros.,0,0,0,0
2793," With P=14, 16384 registers.",0,1,0,1
2794, Mask to index register.,0,1,0,1
2795, Enough to count up to 63 leading zeroes.,1,1,0,1
2796, Dense encoding.,0,1,0,1
2797, Sparse encoding.,0,1,0,1
2798," Only used internally, never exposed.",1,1,0,1
2799, =========================== Low level bit macros =========================,1,1,0,1
2800, Macros to access the dense representation.,0,1,0,1
2801,We need to get and set 6 bit counters in an array of 8 bit bytes.,0,1,0,1
2802,We use macros to make sure the code is inlined since speed is critical  especially in order to compute the approximated cardinality in  HLLCOUNT where we need to access all the registers at once.,1,0,0,1
2803,For the same reason we also want to avoid conditionals in this code path.,1,1,0,1
2804,+--------+--------+--------+------ or  or   |11000000|22221111|33333322|55444444  +--------+--------+--------+------ or  or    Note: in the above representation the most significant bit (MSB)  of every byte is on the left.,1,0,0,1
2805,"We start using bits from the LSB to MSB,  and so forth passing to the next byte.",0,0,0,0
2806,"Example, we want to access to counter at pos = 1 (""111111"" in the  illustration above).",1,0,0,1
2807,The index of the first byte b0 containing our data is:    b0 = 6  pos  or  8 = 0     +--------+    |11000000|  <- Our byte at b0    +--------+   The position of the first bit (counting from the LSB = 0) in the byte  is given by:    fb = 6  pos % 8 -> 6   Right shift b0 of 'fb' bits.,1,0,0,1
2808,+--------+    |11000000|  <- Initial value of b0    |00000011|  <- After right shift of 6 pos.,1,0,0,1
2809,+--------+   Left shift b1 of bits 8-fb bits (2 bits)     +--------+    |22221111|  <- Initial value of b1    |22111100|  <- After left shift of 2 bits.,0,0,0,0
2810,"+--------+   OR the two bits, and finally AND with 111111 (63 in decimal) to  clean the higher order bits we are not interested in:     +--------+    |00000011|  <- b0 right shifted    |22111100|  <- b1 left shifted    |22111111|  <- b0 OR b1    |  111111|  <- (b0 OR b1) AND 63, our value.",1,0,0,1
2811,#NAME?,1,0,0,1
2812,In this case  the 6-bit counter is actually contained in a single byte.,1,0,0,1
2813,"b0 = 6  pos  or  8 = 0     +--------+    |11000000|  <- Our byte at b0    +--------+    fb = 6  pos % 8 = 0    So we right shift of 0 bits (no shift in practice) and   left shift the next byte of 8 bits, even if we don't use it,   but this has the effect of clearing the bits so the result   will not be affacted after the OR.",1,0,0,1
2814,"-------------------------------------------------------------------------   Setting the register is a bit more complex, let's assume that 'val'  is the value we want to set, already in the right range.",1,0,0,1
2815,"We need two steps, in one we need to clear the bits, and in the other  we need to bitwise-OR the new bits.",1,0,0,1
2816,"Let's try with 'pos' = 1, so our first byte at 'b' is 0,   ""fb"" is 6 in this case.",1,0,0,1
2817,"+--------+    |11000000|  <- Our byte at b0    +--------+   To create a AND-mask to clear the bits about this position, we just  initialize the mask with the value 63, left shift it of ""fs"" bits,  and finally invert the result.",1,0,0,1
2818,"+--------+    |00111111|  <- ""mask"" starts at 63    |11000000|  <- ""mask"" after left shift of ""ls"" bits.",0,0,0,0
2819,"|00111111|  <- ""mask"" after invert.",0,0,0,0
2820,"+--------+   Now we can bitwise-AND the byte at ""b"" with the mask, and bitwise-OR  it with ""val"" left-shifted of ""ls"" bits to set the new bits.",1,0,0,1
2821,"Now let's focus on the next byte b1:     +--------+    |22221111|  <- Initial value of b1    +--------+   To build the AND mask we start again with the 63 value, right shift  it by 8-fb bits, and invert it.",1,0,0,1
2822,"+--------+    |00111111|  <- ""mask"" set at 2&6-1    |00001111|  <- ""mask"" after the right shift by 8-fb = 2 bits    |11110000|  <- ""mask"" after bitwise not.",1,0,0,1
2823,"+--------+   Now we can mask it with b+1 to clear the old bits, and bitwise-OR  with ""val"" left-shifted by ""rs"" bits to set the new value.",1,0,0,1
2824," Note: if we access the last counter, we will also access the b+1 byte  that is out of the array, but sds strings always have an implicit null  term, so the byte exists, and we can skip the conditional (or the need  to allocate 1 byte more explicitly).",1,0,0,1
2825, Store the value of the register at position 'regnum' into variable 'target'.,0,0,0,0
2826,'p' is an array of unsigned bytes.,0,0,0,0
2827, Set the value of the register at position 'regnum' to 'val'.,0,0,0,0
2828,'p' is an array of unsigned bytes.,0,0,0,0
2829, Macros to access the sparse representation.,0,1,0,1
2830,The macros parameter is expected to be an uint8_t pointer.,1,0,0,1
2831, 01xxxxxx,0,1,0,1
2832, 1vvvvvxx,0,1,0,1
2833, 00xxxxxx,0,1,0,1
2834, constant for 0.5 or ln(2),1,0,0,1
2835, ========================= HyperLogLog algorithm  =========================,0,0,0,0
2836," Our hash function is MurmurHash2, 64 bit version.",0,1,0,1
2837,It was modified for Redis in order to provide the same result in  big and little endian archs (endian neutral).,1,0,0,1
2838," Given a string element to add to the HyperLogLog, returns the length  of the pattern 000..1 of the element hash.",0,0,0,0
2839,As a side effect 'regp' is  set to the register index this element hashes to.,0,0,0,0
2840, Count the number of zeroes starting from bit HLL_REGISTERS      (that is a power of two corresponding to the first bit we don't use      as index).,1,0,0,1
2841,The max run can be 64-P+1 = Q+1 bits.,0,1,0,1
2842,"Note that the final ""1"" ending the sequence of zeroes must be      included in the count, so if we find ""001"" the count is 3, and      the smallest count possible is no zeroes at all, just a 1 bit      at the first position, that is a count of 1.",1,0,0,1
2843,"This may sound like inefficient, but actually in the average case      there are high probabilities to find a 1 after a few iterations.",1,0,0,1
2844, Register index.,0,1,0,1
2845, Remove bits used to address the register.,0,1,0,1
2846, Make sure the loop terminates                                     and count will be <= Q+1.,1,0,0,1
2847," Initialized to 1 since we count the ""00000...1"" pattern.",0,0,0,0
2848, ================== Dense representation implementation  ==================,0,0,0,0
2849, Low level function to set the dense HLL register at 'index' to the  specified value if the current value is smaller than 'count'.,1,0,0,1
2850,'registers' is expected to have room for HLL_REGISTERS plus an  additional byte on the right.,1,0,0,1
2851,This requirement is met by sds strings  automatically since they are implicitly null terminated.,0,0,0,0
2852,"The function always succeed, however if as a result of the operation  the approximated cardinality changed, 1 is returned.",0,0,0,0
2853,Otherwise 0  is returned.,0,0,0,0
2854," ""Add"" the element in the dense hyperloglog data structure.",0,0,0,0
2855,"Actually nothing is added, but the max 0 pattern counter of the subset  the element belongs to is incremented if needed.",1,0,0,1
2856,"This is just a wrapper to hllDenseSet(), performing the hashing of the  element in order to retrieve the index and zero-run count.",0,0,0,0
2857, Update the register if this element produced a longer run of zeroes.,0,1,0,1
2858, Compute the register histogram in the dense representation.,0,1,0,1
2859, Redis default is to use 16384 registers 6 bits each.,0,0,0,0
2860,"The code works      with other values by modifying the defines, but for our target value      we take a faster path with unrolled loops.",1,0,0,1
2861, Handle 16 registers per iteration.,0,1,0,1
2862, ================== Sparse representation implementation  =================,0,0,0,0
2863, Convert the HLL with sparse representation given as input in its dense  representation.,0,0,0,0
2864,"Both representations are represented by SDS strings, and  the input representation is freed as a side effect.",0,0,0,0
2865,"The function returns C_OK if the sparse representation was valid,  otherwise C_ERR is returned if the representation was corrupted.",0,0,0,0
2866, If the representation is already the right one return ASAP.,1,0,0,1
2867, Create a string of the right size filled with zero bytes.,1,1,0,1
2868,Note that the cached cardinality is set to 0 as a side effect      that is exactly the cardinality of an empty HLL.,1,0,0,1
2869, This will copy the magic and cached cardinality.,1,0,0,1
2870, Now read the sparse representation and set non-zero registers      accordingly.,0,0,0,0
2871," If the sparse representation was valid, we expect to find idx      set to HLL_REGISTERS.",0,0,0,0
2872, Free the old representation and set the new one.,1,1,0,1
2873, Low level function to set the sparse HLL register at 'index' to the  specified value if the current value is smaller than 'count'.,1,0,0,1
2874,The object 'o' is the String object holding the HLL.,0,1,0,1
2875,The function requires  a reference to the object in order to be able to enlarge the string if  needed.,1,0,0,1
2876,"On success, the function returns 1 if the cardinality changed, or 0  if the register for this element was not updated.",1,0,0,1
2877,On error (if the representation is invalid) -1 is returned.,0,1,0,1
2878,"As a side effect the function may promote the HLL representation from  sparse to dense: this happens when a register requires to be set to a value  not representable with the sparse representation, or when the resulting  size would be greater than server.hll_sparse_max_bytes.",1,0,0,1
2879, If the count is too big to be representable by the sparse representation      switch to dense representation.,1,0,0,1
2880," When updating a sparse representation, sometimes we may need to      enlarge the buffer for up to 3 bytes in the worst case (XZERO split      into XZERO-VAL-XZERO).",1,0,0,1
2881,Make sure there is enough space right now      so that the pointers we take during the execution of the function      will be valid all the time.,1,0,0,1
2882, Step 1: we need to locate the opcode we need to modify to check      if a value update is actually needed.,1,0,0,1
2883, Points to previos opcode at the end of the loop.,0,0,0,0
2884, Points to the next opcode at the end of the loop.,0,0,0,0
2885, Set span to the number of registers covered by this opcode.,0,0,0,0
2886,This is the most performance critical loop of the sparse          representation.,1,0,0,1
2887,Sorting the conditionals from the most to the          least frequent opcode in many-bytes sparse HLLs is faster.,1,0,0,1
2888, XZERO.,0,1,0,1
2889, Break if this opcode covers the register as 'index'.,0,0,0,0
2890, Invalid format.,0,1,0,1
2891, Cache current opcode type to avoid using the macro again and      again for something that will not change.,1,0,0,1
2892,Also cache the run-length of the opcode.,0,0,0,0
2893," Step 2: After the loop:           'first' stores to the index of the first register covered       by the current opcode, which is pointed by 'p'.",1,0,0,1
2894,"'next' ad 'prev' store respectively the next and previous opcode,       or NULL if the opcode at 'p' is respectively the last or first.",1,0,0,1
2895,'span' is set to the number of registers covered by the current       opcode.,1,0,0,1
2896,"There are different cases in order to update the data structure      in place without generating it from scratch:           A) If it is a VAL opcode already set to a value >= our 'count'         no update is needed, regardless of the VAL run-length field.",1,0,0,1
2897,In this case PFADD returns 0 since no changes are performed.,0,1,0,1
2898,"B) If it is a VAL opcode with len = 1 (representing only our         register) and the value is less than 'count', we just update it         since this is a trivial case.",1,0,0,1
2899, Case A.,0,1,0,1
2900, Case B.,0,1,0,1
2901, C) Another trivial to handle case is a ZERO opcode with a len of 1.,0,0,0,0
2902,We can just replace it with a VAL opcode with our value and len of 1.,0,0,0,0
2903, D) General case.,1,1,0,1
2904,"The other cases are more complex: our register requires to be updated      and is either currently represented by a VAL opcode with len > 1,      by a ZERO opcode with len > 1, or by an XZERO opcode.",1,0,0,1
2905,In those cases the original opcode must be split into muliple      opcodes.,1,0,0,1
2906,"The worst case is an XZERO split in the middle resuling into      XZERO - VAL - XZERO, so the resulting sequence max length is      5 bytes.",1,0,0,1
2907,We perform the split writing the new sequence into the 'new' buffer      with 'newlen' as length.,1,0,0,1
2908,"Later the new sequence is inserted in place      of the old one, possibly moving what is on the right a few bytes      if the new sequence is longer than the older one.",1,0,0,1
2909, Last register covered by the sequence.,1,1,0,1
2910, Handle splitting of ZERO  or  XZERO.,0,0,0,0
2911, Handle splitting of VAL.,0,1,0,1
2912, Step 3: substitute the new sequence with the old one.,1,1,0,1
2913,Note that we already allocated space on the sds string      calling sdsMakeRoomFor().,0,0,0,0
2914, Step 4: Merge adjacent values if possible.,1,1,0,1
2915,"The representation was updated, however the resulting representation      may not be optimal: adjacent VAL opcodes can sometimes be merged into      a single one.",1,0,0,1
2916, Scan up to 5 upcodes starting from prev.,1,0,0,1
2917," We need two adjacent VAL opcodes to try a merge, having          the same value, and a len that fits the VAL opcode max len.",1,0,0,1
2918, After a merge we reiterate without incrementing 'p'                      in order to try to merge the just merged value with                      a value on its right.,1,0,0,1
2919, Invalidate the cached cardinality.,0,0,0,0
2920, Promote to dense representation.,0,1,0,1
2921, Corrupted HLL.,0,1,0,1
2922, We need to call hllDenseAdd() to perform the operation after the      conversion.,0,0,0,0
2923,"However the result must be 1, since if we need to      convert from sparse to dense a register requires to be updated.",0,0,0,0
2924,"Note that this in turn means that PFADD will make sure the command      is propagated to slaves  or  AOF, so if there is a sparse -> dense      convertion, it will be performed in all the slaves as well.",1,0,0,1
2925," ""Add"" the element in the sparse hyperloglog data structure.",0,0,0,0
2926,"Actually nothing is added, but the max 0 pattern counter of the subset  the element belongs to is incremented if needed.",1,0,0,1
2927,"This function is actually a wrapper for hllSparseSet(), it only performs  the hashshing of the elmenet to obtain the index and zeros run length.",1,0,0,1
2928, Update the register if this element produced a longer run of zeroes.,0,1,0,1
2929, Compute the register histogram in the sparse representation.,0,1,0,1
2930, ========================= HyperLogLog Count ==============================  This is the core of the algorithm where the approximated count is computed.,0,0,0,0
2931,"The function uses the lower level hllDenseRegHisto() and hllSparseRegHisto()  functions as helpers to compute histogram of register values part of the  computation, which is representation-specific, while all the rest is common.",1,0,0,1
2932, Implements the register histogram calculation for uint8_t data type  which is only used internally as speedup for PFCOUNT with multiple keys.,1,0,0,1
2933," Helper function sigma as defined in  ""New cardinality estimation algorithms for HyperLogLog sketches""  Otmar Ertl, arXiv:1702.01284",1,0,0,1
2934," Helper function tau as defined in  ""New cardinality estimation algorithms for HyperLogLog sketches""  Otmar Ertl, arXiv:1702.01284",1,0,0,1
2935, Return the approximated cardinality of the set based on the harmonic  mean of the registers values.,1,0,0,1
2936,'hdr' points to the start of the SDS  representing the String object holding the HLL representation.,0,0,0,0
2937,"If the sparse representation of the HLL object is not valid, the integer  pointed by 'invalid' is set to non-zero, otherwise it is left untouched.",0,0,0,0
2938,"hllCount() supports a special internal-only encoding of HLL_RAW, that  is, hdr->registers will point to an uint8_t array of HLL_REGISTERS element.",1,0,0,1
2939,This is useful in order to speedup PFCOUNT when called against multiple  keys (no need to work with 6-bit integers encoding).,1,0,0,1
2940, Compute register histogram,0,1,0,1
2941, Estimate cardinality form register histogram.,0,0,0,0
2942,"See:      ""New cardinality estimation algorithms for HyperLogLog sketches""      Otmar Ertl, arXiv:1702.01284",1,0,0,1
2943, Call hllDenseAdd() or hllSparseAdd() according to the HLL encoding.,0,0,0,0
2944, Invalid representation.,0,1,0,1
2945," Merge by computing MAX(registers[i],hll[i]) the HyperLogLog 'hll'  with an array of uint8_t HLL_REGISTERS registers pointed by 'max'.",0,0,0,0
2946,The hll object must be already validated via isHLLObjectOrReply()  or in some other way.,1,0,0,1
2947,"If the HyperLogLog is sparse and is found to be invalid, C_ERR  is returned, otherwise the function always succeeds.",1,0,0,1
2948, ========================== HyperLogLog commands ==========================,0,1,0,1
2949, Create an HLL object.,0,1,0,1
2950,We always create the HLL using sparse encoding.,0,1,0,1
2951,This will be upgraded to the dense representation as needed.,0,1,0,1
2952, Populate the sparse representation with as many XZERO opcodes as      needed to represent all the registers.,1,0,0,1
2953, Create the actual object.,1,1,0,1
2954, Check if the object is a String with a valid HLL representation.,0,1,0,1
2955,"Return C_OK if this is true, otherwise reply to the client  with an error and return C_ERR.",1,0,0,1
2956," Key exists, check type",1,1,0,1
2957, Error already sent.,0,1,0,1
2958," Magic should be ""HYLL"".",1,0,0,1
2959, Dense representation string length should match exactly.,1,1,0,1
2960, All tests passed.,0,1,0,1
2961, PFADD var ele ele ele ... ele => :0 or :1,0,0,0,0
2962, Create the key with a string value of the exact length to          hold our HLL data structure.,1,0,0,1
2963,sdsnewlen() when NULL is passed          is guaranteed to return bytes initialized to zero.,0,0,0,0
2964, Perform the low level ADD operation for every element.,1,1,0,1
2965, PFCOUNT var -> approximated cardinality of set.,0,0,0,0
2966," Case 1: multi-key keys, cardinality of the union.",0,0,0,0
2967,"When multiple keys are specified, PFCOUNT actually computes      the cardinality of the merge of the N HLLs specified.",1,0,0,1
2968, Compute an HLL with M[i] = MAX(M[i]_j).,0,0,0,0
2969, Special internal-only encoding.,1,1,0,1
2970, Check type and size.,0,1,0,1
2971, Assume empty HLL for non existing var.,1,1,0,1
2972," Merge with this HLL with our 'max' HHL by setting max[i]              to MAX(max[i],hll[i]).",0,0,0,0
2973, Compute cardinality of the resulting set.,0,0,0,0
2974, Case 2: cardinality of the single HLL.,1,0,0,1
2975,The user specified a single key.,1,1,0,1
2976,Either return the cached value      or compute one and update the cache.,0,0,0,0
2977, No key?,1,1,0,1
2978,"Cardinality is zero since no element was added, otherwise          we would have a key as HLLADD creates it as a side effect.",1,0,0,1
2979, Check if the cached cardinality is valid.,0,0,0,0
2980, Just return the cached value.,0,1,0,1
2981, Recompute it and update the cached value.,0,1,0,1
2982," This is not considered a read-only command even if the              data structure is not modified, since the cached value              may be modified and given that the HLL is a Redis string              we need to propagate the change.",0,0,0,0
2983, PFMERGE dest src1 src2 src3 ... srcN => OK,1,0,0,1
2984, Use dense representation as target?,0,1,0,1
2985, Compute an HLL with M[i] = MAX(M[i]_j).,0,0,0,0
2986,We store the maximum into the max array of registers.,0,1,0,1
2987,We'll write      it to the target variable later.,0,0,0,0
2988, Check type and size.,0,1,0,1
2989, Assume empty HLL for non existing var.,1,1,0,1
2990," If at least one involved HLL is dense, use the dense representation          as target ASAP to save time and avoid the conversion step.",1,0,0,1
2991," Merge with this HLL with our 'max' HHL by setting max[i]          to MAX(max[i],hll[i]).",0,0,0,0
2992, Create  or  unshare the destination key's value if needed.,1,0,0,1
2993, Create the key with a string value of the exact length to          hold our HLL data structure.,1,0,0,1
2994,sdsnewlen() when NULL is passed          is guaranteed to return bytes initialized to zero.,0,0,0,0
2995," If key exists we are sure it's of the right type or size          since we checked when merging the different HLLs, so we          don't check again.",1,0,0,1
2996, Convert the destination object to dense representation if at least      one of the inputs was dense.,1,0,0,1
2997, Write the resulting HLL to the destination HLL registers and      invalidate the cached value.,0,0,0,0
2998," o->ptr may be different now, as a side effect of                     last hllSparseSet() call.",1,0,0,1
2999, We generate a PFADD event for PFMERGE for semantical simplicity      since in theory this is a mass-add of elements.,0,0,0,0
3000, ========================== Testing  or  Debugging  ==========================,0,0,0,0
3001, PFSELFTEST  This command performs a self-test of the HLL registers implementation.,0,0,0,0
3002,Something that is not easy to test from within the outside.,1,1,0,1
3003, Test 1: access registers.,0,1,0,1
3004,The test is conceived to test that the different counters of our data      structure are accessible and that setting their values both result in      the correct value to be retained and not affect adjacent values.,1,0,0,1
3005, Set the HLL counters and an array of unsigned byes of the          same size to the same set of random values.,1,0,0,1
3006, Check that we are able to retrieve the same values.,1,1,0,1
3007, Test 2: approximation error.,0,1,0,1
3008,The test adds unique elements and check that the estimated value      is always reasonable bounds.,1,0,0,1
3009,"We check that the error is smaller than a few times than the expected      standard error, to make it very unlikely for the test to fail because      of a ""bad"" run.",1,0,0,1
3010,The test is performed with both dense and sparse HLLs at the same      time also verifying that the computed cardinality is the same.,1,0,0,1
3011, Make sure that for small cardinalities we use sparse          encoding.,1,0,0,1
3012, Check that dense and sparse representations agree.,0,1,0,1
3013, Check error.,0,1,0,1
3014," Adjust the max error we expect for cardinality 10              since from time to time it is statistically likely to get              much higher error due to collision, resulting into a false              positive.",1,0,0,1
3015, Success!,1,1,0,1
3016, PFDEBUG <subcommand> <key> ... args ...,0,0,0,0
3017,Different debugging related operations about the HLL implementation.,1,1,0,1
3018, PFDEBUG GETREG <key>,0,1,0,1
3019, Force propagation on encoding change.,0,1,0,1
3020, PFDEBUG DECODE <key>,0,1,0,1
3021, PFDEBUG ENCODING <key>,0,1,0,1
3022, PFDEBUG TODENSE <key>,0,1,0,1
3023, Force propagation on encoding change.,0,1,0,1
3024," Note that these encodings are ordered, so:  INTSET_ENC_INT16 < INTSET_ENC_INT32 < INTSET_ENC_INT64.",0,0,0,0
3025, Return the required encoding for the provided value.,0,1,0,1
3026," Return the value at pos, given an encoding.",0,0,0,0
3027," Return the value at pos, using the configured encoding.",0,0,0,0
3028," Set the value at pos, using the configured encoding.",0,0,0,0
3029, Create an empty intset.,1,0,0,1
3030, Resize the intset,0,0,0,0
3031," Search for the position of ""value"".",0,0,0,0
3032,"Return 1 when the value was found and  sets ""pos"" to the position of the value within the intset.",0,0,0,0
3033,"Return 0 when  the value is not present in the intset and sets ""pos"" to the position  where ""value"" can be inserted.",0,0,0,0
3034, The value can never be found when the set is empty,1,1,0,1
3035," Check for the case where we know we cannot find the value,          but do know the insert position.",0,0,0,0
3036, Upgrades the intset to a larger encoding and inserts the given integer.,1,0,0,1
3037, First set new encoding and resize,1,0,0,1
3038, Upgrade back-to-front so we don't overwrite values.,0,1,0,1
3039,"Note that the ""prepend"" variable is used to make sure we have an empty      space at either the beginning or the end of the intset.",1,0,0,1
3040, Set the value at the beginning or the end.,0,1,0,1
3041, Insert an integer in the intset,0,0,0,0
3042, Upgrade encoding if necessary.,1,1,0,1
3043,"If we need to upgrade, we know that      this value should be either appended (if > 0) or prepended (if < 0),      because it lies outside the range of existing values.",1,0,0,1
3044," This always succeeds, so we don't need to curry success.",1,1,0,1
3045, Abort if the value is already present in the set.,0,1,0,1
3046,"This call will populate ""pos"" with the right position to insert          the value when it cannot be found.",1,0,0,1
3047, Delete integer from intset,0,0,0,0
3048, We know we can delete,0,1,0,1
3049, Overwrite value with tail and update length,0,1,0,1
3050, Determine whether a value belongs to this set,0,1,0,1
3051, Return random member,1,1,0,1
3052, Get the value at the given position.,0,1,0,1
3053,"When this position is  out of range the function returns 0, when in range it returns 1.",0,0,0,0
3054, Return intset length,0,0,0,0
3055, Return intset blob size in bytes.,0,0,0,0
3056, Dictionary type for latency events.,0,1,0,1
3057, hash function,0,0,0,0
3058, key dup,1,0,0,1
3059, val dup,0,0,0,0
3060, key compare,1,0,0,1
3061, key destructor,1,0,0,1
3062, val destructor,0,0,0,0
3063, ------------------------- Utility functions ------------------------------,0,1,0,1
3064, Returns 1 if Transparent Huge Pages support is enabled in the kernel.,1,1,0,1
3065,Otherwise (or if we are unable to check) 0 is returned.,1,0,0,1
3066," Report the amount of AnonHugePages in smap, in bytes.",0,0,0,0
3067,"If the return  value of the function is non-zero, the process is being targeted by  THP support, and is likely to have memory usage  or  latency issues.",1,0,0,1
3068, ---------------------------- Latency API ---------------------------------,0,1,0,1
3069, Latency monitor initialization.,0,1,0,1
3070,"We just need to create the dictionary  of time series, each time serie is craeted on demand in order to avoid  having a fixed list to maintain.",1,0,0,1
3071," Add the specified sample to the specified time series ""event"".",0,0,0,0
3072,"This function is usually called via latencyAddSampleIfNeeded(), that  is a macro that only adds the sample if the latency is higher than  server.latency_monitor_threshold.",1,0,0,1
3073, Create the time series if it does not exist.,0,1,0,1
3074," If the previous sample is in the same second, we update our old sample      if this latency is > of the old one, or just return.",1,0,0,1
3075," Reset data for the specified event, or all the events data if 'event' is  NULL.",0,0,0,0
3076,Note: this is O(N) even when event_to_reset is not NULL because makes  the code simpler and we have a small fixed max number of events.,1,0,0,1
3077, ------------------------ Latency reporting (doctor) ----------------------,0,1,0,1
3078," Analyze the samples avaialble for a given event and return a structure  populate with different metrics, average, MAD, min, max, and so forth.",1,0,0,1
3079,Check latency.h definition of struct latenctStat for more info.,1,0,0,1
3080,If the specified event has no elements the structure is populate with  zero values.,0,0,0,0
3081," First pass, populate everything but the MAD.",1,1,0,1
3082, Track the oldest event time in ls->period.,0,1,0,1
3083," So far avg is actually the sum of the latencies, and period is      the oldest event time.",1,0,0,1
3084,We need to make the first an average and      the second a range of seconds.,1,0,0,1
3085," Second pass, compute MAD.",1,1,0,1
3086, Create a human readable report of latency events for this Redis instance.,1,0,0,1
3087, Better virtual machines.,1,1,0,1
3088, Enable slowlog.,0,0,0,0
3089, Reconfigure slowlog.,0,0,0,0
3090, Check your slowlog.,0,0,0,0
3091, Try to lower disk contention.,0,1,0,1
3092, Intrinsic latency.,0,1,0,1
3093, data=writeback.,0,0,0,0
3094, don't fsync during rewrites.,0,0,0,0
3095, Avoid remote disks.,1,1,0,1
3096, Use an SSD drive.,0,1,0,1
3097, Print info about AOF and write load.,0,1,0,1
3098, Use higher HZ.,1,1,0,1
3099, Deletion of large objects.,1,1,0,1
3100, Avoid mass eviction of keys.,0,1,0,1
3101, appendfsync always is slow.,1,0,0,1
3102, AnonHugePages detected.,0,1,0,1
3103, Return ASAP if the latency engine is disabled and it looks like it      was never enabled so far.,1,0,0,1
3104, Show all the events stats and add for each event some event-related      comment depending on the values.,0,0,0,0
3105, Fork,0,1,0,1
3106, Potentially commands.,1,1,0,1
3107, fast-command.,0,0,0,0
3108, AOF and I or O.,0,1,0,1
3109, Expire cycle.,0,1,0,1
3110, Eviction cycle.,0,1,0,1
3111, Add non event based advices.,0,0,0,0
3112, Add all the suggestions accumulated so far.,1,1,0,1
3113, Better VM.,1,1,0,1
3114, Slow log.,1,1,0,1
3115, Intrinsic latency.,0,1,0,1
3116, AOF  or  Disk latency.,0,0,0,0
3117, ---------------------- Latency command implementation --------------------,0,1,0,1
3118, latencyCommand() helper to produce a time-delay reply for all the samples  in memory for the specified time series.,0,0,0,0
3119," latencyCommand() helper to produce the reply for the LATEST subcommand,  listing the last latency sample for every event type registered so far.",1,0,0,1
3120, Update min and max.,0,1,0,1
3121, Use as label the number of seconds  or  minutes  or  hours  or  days          ago the event happened.,0,0,0,0
3122, LATENCY command implementations.,0,1,0,1
3123,LATENCY SAMPLES: return time-latency samples for the specified event.,0,1,0,1
3124,LATENCY LATEST: return the latest latency for all the events classes.,1,1,0,1
3125,LATENCY DOCTOR: returns an human readable analysis of instance latency.,1,0,0,1
3126,LATENCY GRAPH: provide an ASCII graph of the latency of the specified event.,0,1,0,1
3127, LATENCY HISTORY <event>,0,1,0,1
3128, LATENCY GRAPH <event>,0,1,0,1
3129, LATENCY LATEST,1,1,0,1
3130, LATENCY DOCTOR,0,1,0,1
3131, LATENCY RESET,0,1,0,1
3132, Common error when the user asks for an event we have no latency      information about.,1,0,0,1
3133, Return the amount of work needed in order to free an object.,1,1,0,1
3134,"The return value is not always the actual number of allocations the  object is compoesd of, but a number proportional to it.",1,0,0,1
3135,For strings the function always returns 1.,0,1,0,1
3136,For aggregated objects represented by hash tables or other data structures  the function just returns the number of elements the object is composed of.,1,0,0,1
3137,Objects composed of single allocations are always reported as having a  single item even if they are actaully logical composed of multiple  elements.,1,0,0,1
3138,For lists the funciton returns the number of elements in the quicklist  representing the list.,0,0,0,0
3139, Everything else is a single allocation.,1,1,0,1
3140," Delete a key, value, and associated expiration entry if any, from the DB.",1,1,0,1
3141,If there are enough allocations to free the value object may be put into  a lazy free list instead of being freed synchronously.,1,0,0,1
3142,The lazy free list  will be reclaimed in a different bio.c thread.,1,0,0,1
3143," Deleting an entry from the expires dict will not free the sds of      the key, because it is shared with the main dictionary.",1,0,0,1
3144," If the value is composed of a few allocations, to free in a lazy way      is actually just slower...",1,0,0,1
3145,So under a certain limit we just free      the object synchronously.,1,0,0,1
3146," If releasing the object is too much work, do it in the background          by adding the object to the lazy free list.",1,0,0,1
3147,"Note that if the object is shared, to reclaim it now it is not          possible.",1,0,0,1
3148,"This rarely happens, however sometimes the implementation          of parts of the Redis core may call incrRefCount() to protect          objects, and then call dbDelete().",1,0,0,1
3149,"In this case we'll fall          through and reach the dictFreeUnlinkedEntry() call, that will be          equivalent to just calling decrRefCount().",0,0,0,0
3150," Release the key-val pair, or just the key if we set the val      field to NULL in order to lazy free it later.",1,0,0,1
3151, Empty a Redis DB asynchronously.,1,0,0,1
3152,What the function does actually is to  create a new empty set of hash tables and scheduling the old ones for  lazy freeing.,1,0,0,1
3153, Empty the slots-keys map of Redis CLuster by creating a new empty one  and scheduiling the old for lazy freeing.,1,0,0,1
3154, Release objects from the lazyfree thread.,0,0,0,0
3155,It's just decrRefCount()  updating the count of objects to release.,0,0,0,0
3156, Release a database from the lazyfree thread.,0,0,0,0
3157,The 'db' pointer is the  database which was substitutied with a fresh one in the main thread  when the database was logically deleted.,1,0,0,1
3158,'sl' is a skiplist used by  Redis Cluster in order to take the hash slots -> keys mapping.,0,0,0,0
3159,This  may be NULL if Redis Cluster is disabled.,1,0,0,1
3160, Release the skiplist mapping Redis Cluster keys to slots in the  lazyfree thread.,0,0,0,0
3161, 32 bit total len + 16 bit number of elements.,1,0,0,1
3162, Convert a string into a signed 64 bit integer.,0,1,0,1
3163,"The function returns 1 if the string could be parsed into a (non-overflowing)  signed 64 bit int, 0 otherwise.",0,0,0,0
3164,The 'value' will be set to the parsed value  when the function returns success.,1,0,0,1
3165,"Note that this function demands that the string strictly represents  a int64 value: no spaces or other characters before or after the string  representing the number are accepted, nor zeroes at the start if not  for the string ""0"" representing the zero number.",1,0,0,1
3166,"Because of its strictness, it is safe to use this function to check if  you can convert a string into a long long, and obtain back the string  from the number without any loss in the string representation.",1,0,0,1
3167,"-----------------------------------------------------------------------------   Credits: this function was adapted from the Redis source code, file  ""utils.c"", function string2ll(), and is copyright:   Copyright(C) 2011, Pieter Noordhuis  Copyright(C) 2011, Salvatore Sanfilippo   The function is released under the BSD 3-clause license.",0,0,0,0
3168, Special case: first and only digit is 0.,1,1,0,1
3169, Abort on only a negative sign.,1,1,0,1
3170," First digit should be 1-9, otherwise the string should just be 0.",1,1,0,1
3171, Overflow.,0,1,0,1
3172, Overflow.,0,1,0,1
3173, Return if not all bytes were used.,0,1,0,1
3174, Overflow.,0,1,0,1
3175, Overflow.,0,1,0,1
3176," Create a new, empty listpack.",1,0,0,1
3177,"On success the new listpack is returned, otherwise an error is returned.",1,0,0,1
3178, Free the specified listpack.,1,0,0,1
3179," Given an element 'ele' of size 'size', determine if the element can be  represented inside the listpack encoded as integer, and returns  LP_ENCODING_INT if so.",0,0,0,0
3180,Otherwise returns LP_ENCODING_STR if no integer  encoding is possible.,1,0,0,1
3181,"If the LP_ENCODING_INT is returned, the function stores the integer encoded  representation of the element in the 'intenc' buffer.",0,0,0,0
3182,"Regardless of the returned encoding, 'enclen' is populated by reference to  the number of bytes that the string or integer encoded element will require  in order to be represented.",0,0,0,0
3183, Single byte 0-127 integer.,1,1,0,1
3184, 13 bit integer.,0,1,0,1
3185, 16 bit integer.,0,1,0,1
3186, 24 bit integer.,0,1,0,1
3187, 32 bit integer.,0,1,0,1
3188, 64 bit integer.,0,1,0,1
3189," Store a reverse-encoded variable length field, representing the length  of the previous element of size 'l', in the target buffer 'buf'.",1,0,0,1
3190,"The function returns the number of bytes used to encode it, from  1 to 5.",0,0,0,0
3191,If 'buf' is NULL the funciton just returns the number of bytes  needed in order to encode the backlen.,0,0,0,0
3192, Decode the backlen and returns it.,0,0,0,0
3193,"If the encoding looks invalid (more than  5 bytes are used), UINT64_MAX is returned to report the problem.",1,0,0,1
3194, Encode the string element pointed by 's' of size 'len' in the target  buffer 's'.,0,0,0,0
3195,The function should be called with 'buf' having always enough  space for encoding the string.,1,0,0,1
3196,This is done by calling lpEncodeGetType()  before calling this function.,0,0,0,0
3197, Return the encoded length of the listpack element pointed by 'p'.,0,0,0,0
3198,If the  element encoding is wrong then 0 is returned.,1,0,0,1
3199, Skip the current entry returning the next.,1,1,0,1
3200,"It is invalid to call this  function if the current element is the EOF element at the end of the  listpack, however, while this function is used to implement lpNext(),  it does not return NULL when the EOF element is encountered.",1,0,0,1
3201," If 'p' points to an element of the listpack, calling lpNext() will return  the pointer to the next element (the one on the right), or NULL if 'p'  already pointed to the last element of the listpack.",1,0,0,1
3202, lp is not used for now.,0,0,0,0
3203,However lpPrev() uses it.,0,0,0,0
3204," If 'p' points to an element of the listpack, calling lpPrev() will return  the pointer to the preivous element (the one on the left), or NULL if 'p'  already pointed to the first element of the listpack.",1,0,0,1
3205, Seek the first backlen byte of the last element.,1,0,0,1
3206, Seek the first byte of the previous entry.,1,1,0,1
3207," Return a pointer to the first element of the listpack, or NULL if the  listpack has no elements.",1,0,0,1
3208, Skip the header.,0,1,0,1
3209," Return a pointer to the last element of the listpack, or NULL if the  listpack has no elements.",1,0,0,1
3210, Seek EOF element.,0,1,0,1
3211, Will return NULL if EOF is the only element.,1,1,0,1
3212, Return the number of elements inside the listpack.,0,0,0,0
3213,"This function attempts  to use the cached value when within range, otherwise a full scan is  needed.",1,0,0,1
3214,"As a side effect of calling this function, the listpack header  could be modified, because if the count is found to be already within  the 'numele' header field range, the new value is set.",1,0,0,1
3215, Too many elements inside the listpack.,1,0,0,1
3216,We need to scan in order      to get the total number.,1,0,0,1
3217," If the count is again within range of the header numele field,      set it.",0,0,0,0
3218, Return the listpack element pointed by 'p'.,0,0,0,0
3219,The function changes behavior depending on the passed 'intbuf' value.,0,0,0,0
3220,"Specifically, if 'intbuf' is NULL:   If the element is internally encoded as an integer, the function returns  NULL and populates the integer value by reference in 'count'.",0,0,0,0
3221,"Otherwise if  the element is encoded as a string a pointer to the string (pointing inside  the listpack itself) is returned, and 'count' is set to the length of the  string.",0,0,0,0
3222,"If instead 'intbuf' points to a buffer passed by the caller, that must be  at least LP_INTBUF_SIZE bytes, the function always returns the element as  it was a string (returning the pointer to the string and setting the  'count' argument to the string length by reference).",1,0,0,1
3223,"However if the element  is encoded as an integer, the 'intbuf' buffer is used in order to store  the string representation.",0,0,0,0
3224,The user should use one or the other form depending on what the value will  be used for.,1,0,0,1
3225,"If there is immediate usage for an integer value returned  by the function, than to pass a buffer (and convert it back to a number)  is of course useless.",1,0,0,1
3226,"If the function is called against a badly encoded ziplist, so that there  is no valid way to parse it, the function returns like if there was an  integer encoded with value 12345678900000000 + <unrecognized byte>, this may  be an hint to understand that something is wrong.",1,0,0,1
3227,To crash in this case is  not sensible because of the different requirements of the application using  this lib.,1,0,0,1
3228,"Similarly, there is no error returned since the listpack normally can be  assumed to be valid, so that would be a very high API cost.",1,0,0,1
3229,"However a function  in order to check the integrity of the listpack at load time is provided,  check lpIsValid().",0,0,0,0
3230, 7 bit ints are always positive.,1,0,0,1
3231, We reach this code path only for integer encodings.,1,0,0,1
3232,Convert the unsigned value to the signed one using two's complement      rule.,0,0,0,0
3233, This three steps conversion should avoid undefined behaviors          in the unsigned -> signed conversion.,0,0,0,0
3234, Return the string representation of the integer or the value itself      depending on intbuf being NULL or not.,0,0,0,0
3235," Insert, delete or replace the specified element 'ele' of lenght 'len' at  the specified position 'p', with 'p' being a listpack element pointer  obtained with lpFirst(), lpLast(), lpIndex(), lpNext(), lpPrev() or  lpSeek().",0,0,0,0
3236,"The element is inserted before, after, or replaces the element pointed  by 'p' depending on the 'where' argument, that can be LP_BEFORE, LP_AFTER  or LP_REPLACE.",0,0,0,0
3237,"If 'ele' is set to NULL, the function removes the element pointed by 'p'  instead of inserting one.",0,0,0,0
3238,"Returns NULL on out of memory or when the listpack total length would exceed  the max allowed size of 2^32-1, otherwise the new pointer to the listpack  holding the new element is returned (and the old pointer passed is no longer  considered valid)   If 'newp' is not NULL, at the end of a successful call 'newp' will be set  to the address of the element just added, so that it will be possible to  continue an interation with lpNext() and lpPrev().",1,0,0,1
3239,"For deletion operations ('ele' set to NULL) 'newp' is set to the next  element, on the right of the deleted one, or to NULL if the deleted element  was the last one.",1,0,0,1
3240, The length of the encoded element.,0,1,0,1
3241," An element pointer set to NULL means deletion, which is conceptually      replacing the element with a zero-length element.",0,0,0,0
3242,"So whatever we      get passed as 'where', set it to LP_REPLACE.",0,0,0,0
3243," If we need to insert after the current element, we just jump to the      next element (that could be the EOF one) and handle the case of      inserting before.",1,0,0,1
3244,So the function will actually deal with just two      cases: LP_BEFORE and LP_REPLACE.,1,0,0,1
3245," Store the offset of the element 'p', so that we can obtain its      address again after a reallocation.",0,0,0,0
3246," Calling lpEncodeGetType() results into the encoded version of the      element to be stored into 'intenc' in case it is representable as      an integer: in that case, the function returns LP_ENCODING_INT.",0,0,0,0
3247,"Otherwise if LP_ENCODING_STR is returned, we'll have to call      lpEncodeString() to actually write the encoded string on place later.",1,0,0,1
3248,"Whatever the returned encoding is, 'enclen' is populated with the      length of the encoded element.",0,0,0,0
3249, We need to also encode the backward-parsable length of the element      and append it to the end: this allows to traverse the listpack from      the end to the start.,0,0,0,0
3250, We now need to reallocate in order to make space or shrink the      allocation (in case 'when' value is LP_REPLACE and the new element is      smaller).,1,0,0,1
3251,"However we do that before memmoving the memory to      make room for the new element if the final allocation will get      larger, or we do it after if the final allocation will get smaller.",1,0,0,1
3252, May be updated after reallocation.,0,1,0,1
3253, Realloc before: we need more room.,1,0,0,1
3254, Setup the listpack relocating the elements to make the exact room      we need to store the new one.,1,0,0,1
3255, LP_REPLACE.,0,1,0,1
3256, Realloc after: we need to free space.,1,0,0,1
3257, Store the entry.,0,1,0,1
3258," In case of deletion, set 'newp' to NULL if the next element is          the EOF element.",0,0,0,0
3259, Update header.,0,1,0,1
3260, Append the specified element 'ele' of lenght 'len' at the end of the  listpack.,0,0,0,0
3261,"It is implemented in terms of lpInsert(), so the return value is  the same as lpInsert().",1,0,0,1
3262," Remove the element pointed by 'p', and return the resulting listpack.",0,0,0,0
3263,"If 'newp' is not NULL, the next element pointer (to the right of the  deleted one) is returned by reference.",1,0,0,1
3264,"If the deleted element was the  last one, 'newp' is set to NULL.",1,0,0,1
3265, Return the total number of bytes the listpack is composed of.,1,0,0,1
3266, Seek the specified element and returns the pointer to the seeked element.,0,0,0,0
3267,"Positive indexes specify the zero-based element to seek from the head to  the tail, negative indexes specify elements starting from the tail, where  -1 means the last element, -2 the penultimate and so forth.",1,0,0,1
3268,"If the index  is out of range, NULL is returned.",0,0,0,0
3269, Seek forward by default.,0,1,0,1
3270, We want to seek from left to right or the other way around      depending on the listpack length and the element position.,1,0,0,1
3271,"However if the listpack length cannot be obtained in constant time,      we always seek from left to right.",1,0,0,1
3272, Index still < 0 means out of range.,0,1,0,1
3273, Out of range the other side.,1,1,0,1
3274, We want to scan right-to-left if the element we are looking for          is past the half of the listpack.,1,0,0,1
3275, Left to right scanning always expects a negative index.,1,1,0,1
3276,Convert              our index to negative form.,1,0,0,1
3277," If the listpack length is unspecified, for negative indexes we          want to always scan left-to-right.",1,0,0,1
3278, Forward and backward scanning is trivially based on lpNext() or lpPrev().,0,0,0,0
3279,  don't play with this unless you benchmark!,0,0,0,0
3280,the data format is not dependent on the hash function.,0,0,0,0
3281,"the hash function might seem strange, just believe me,  it works ;)",1,0,0,1
3282,"  IDX works because it is very similar to a multiplicative hash, e.g.",1,0,0,1
3283,"((h  57321 >> (38 - HLOG)) & (HSIZE - 1))  the latter is also quite fast on newer CPUs, and compresses similarly.",1,0,0,1
3284,"the next one is also quite good, albeit slow ;)  (int)(cos(h & 0xffffff)  1e6)",1,0,0,1
3285," original lzv-like hash function, much worse and thus slower",1,0,0,1
3286,"  compressed format   000LLLLL <L+1>    ; literal, L+1=1..33 octets  LLLooooo oooooooo ; backref L+1=1..7 octets, o+1=1..4096 offset  111ooooo LLLLLLLL oooooooo ; backref L+8 octets, o+1=1..4096 offset",0,0,0,0
3287, off requires a type wide enough to hold a general pointer difference.,1,0,0,1
3288,ISO C doesn't have that (size_t might not be enough and ptrdiff_t only    works for differences within a single object).,1,0,0,1
3289,We also assume that no    no bit pattern traps.,0,0,0,0
3290,"Since the only platform that is both non-POSIX    and fails to support both assumptions is windows 64 bit, we make a    special workaround for it.",1,0,0,1
3291, workaround for missing POSIX compliance,1,0,0,1
3292, start run,0,0,0,0
3293," the next test will actually take care of this, but this is faster",1,0,0,1
3294, match found at ref++,0,0,0,0
3295, first a faster conservative test,1,0,0,1
3296, second the exact but rare test,1,0,0,1
3297, stop run,0,0,0,0
3298, undo run if length is zero,0,0,0,0
3299, len is now #octets - 1,0,0,0,0
3300, start run,0,0,0,0
3301, one more literal byte we must copy,1,0,0,1
3302, stop run,0,0,0,0
3303, start run,0,0,0,0
3304, at most 3 bytes can be missing here,1,0,0,1
3305, stop run,0,0,0,0
3306, start run,0,0,0,0
3307, end run,0,0,0,0
3308, undo run if length is zero,0,0,0,0
3309," small win on amd, big loss on intel",1,0,0,1
3310, literal run,0,0,0,0
3311, back reference,0,0,0,0
3312, disjunct areas,0,0,0,0
3313," overlapping, use octte by octte copying",0,0,0,0
3314, two octets more,1,0,0,1
3315, Printed chars in screen-wide progress bar.,0,1,0,1
3316, How many chars to write to fill the progress bar.,1,1,0,1
3317," Cursor home, clear screen.",1,1,0,1
3318, Fill with dots.,0,1,0,1
3319," Cursor home, clear current line.",1,1,0,1
3320, Print title.,0,1,0,1
3321," Cursor home, clear screen.",1,1,0,1
3322, Test that addressing is fine.,1,1,0,1
3323,"Every location is populated with its own  address, and finally verified.",1,0,0,1
3324,This test is very fast but may detect  ASAP big issues with the memory subsystem.,1,0,0,1
3325, Fill,0,1,0,1
3326, Test,0,1,0,1
3327," Fill words stepping a single page at every write, so we continue to  touch all the pages in the smallest amount of time reducing the  effectiveness of caches, and making it hard for the OS to transfer  pages on the swap.",1,0,0,1
3328,"In this test we can't call rand() since the system may be completely  unable to handle library calls, so we have to resort to our own  PRNG that only uses local state.",1,0,0,1
3329,We use an xorshift PRNG.,0,0,0,0
3330, words per iteration,0,0,0,0
3331, Just a random seed.,1,1,0,1
3332," Like memtest_fill_random() but uses the two specified values to fill  memory, in an alternated way (v1|v2|v1|v2|...)",0,0,0,0
3333, words per iteration,0,0,0,0
3334, Test the specified memory.,0,1,0,1
3335,The number of bytes must be multiple of 4096.,0,1,0,1
3336,If interactive is true the program exists with an error and prints  ASCII arts to show progresses.,1,0,0,1
3337,"Instead when interactive is 0, it can  be used as an API call, and returns 1 if memory errors were found or  0 if there were no errors detected.",0,0,0,0
3338, A version of memtest_test() that tests memory in small pieces  in order to restore the memory content at exit.,1,0,0,1
3339,"One problem we have with this approach, is that the cache can avoid  real memory accesses, and we can't test big chunks of memory at the  same time, because we need to backup them on the stack (the allocator  may not be usable or we may be already in an out of memory condition).",1,0,0,1
3340,So what we do is to try to trash the cache with useless memory accesses  between the fill and compare cycles.,1,0,0,1
3341, Random accesses of MEMTEST_DECACHE_SIZE are performed at the start and  end of the region between fill and compare cycles in order to trash  the cache.,1,0,0,1
3342, Can't test across 4k page boundaries.,0,1,0,1
3343, Can't test a single page.,1,1,0,1
3344," If we have to test a single final page, go back a single page          so that we can test two pages, since the code can't test a single          page but at least two.",1,0,0,1
3345, Always test an even number of pages.,0,1,0,1
3346, Backup.,0,1,0,1
3347, Restore.,0,1,0,1
3348, Perform an interactive test allocating the specified number of megabytes.,0,1,0,1
3349, --------------------------------------------------------------------------  Private data structures used by the modules system.,1,0,0,1
3350,"Those are data  structures that are never exposed to Redis Modules, if not as void  pointers that have an API the module can call with them)  --------------------------------------------------------------------------",0,0,0,0
3351, This structure represents a module inside the system.,0,1,0,1
3352, Module dlopen() handle.,0,0,0,0
3353, Module name.,0,1,0,1
3354, Module version.,0,1,0,1
3355,We use just progressive integers.,0,1,0,1
3356, Module API version as requested during initialization.,0,1,0,1
3357, Module data types.,0,1,0,1
3358, Hash table of modules.,0,1,0,1
3359,SDS -> RedisModule ptr.,0,0,0,0
3360," Entries in the context->amqueue array, representing objects to free  when the callback returns.",1,0,0,1
3361, AutMemEntry type field values.,0,1,0,1
3362, Explicitly freed by user already.,0,1,0,1
3363, The pool allocator block.,0,0,0,0
3364,Redis Modules can allocate memory via this special  allocator that will automatically release it all once the callback returns.,1,0,0,1
3365,This means that it can only be used for ephemeral allocations.,1,1,0,1
3366,However  there are two advantages for modules to use this API:   1) The memory is automatically released when the callback returns.,0,0,0,0
3367,"2) This allocator is faster for many small allocations since whole blocks     are allocated, and small pieces returned to the caller just advancing     the index of the allocation.",1,0,0,1
3368,Allocations are always rounded to the size of the void pointer in order  to always return aligned memory chunks.,0,0,0,0
3369, This structure represents the context in which Redis modules operate.,0,0,0,0
3370,"Most APIs module can access, get a pointer to the context, so that the API  implementation can hold state across calls, or remember what to free after  the call and so forth.",1,0,0,1
3371,Note that not all the context structure is always filled with actual values  but only the fields needed in a given context.,1,0,0,1
3372, NOTE: Must be the first field.,1,1,0,1
3373, Module reference.,0,1,0,1
3374, Client calling a command.,0,1,0,1
3375, Blocked client for                                                        thread safe context.,1,0,0,1
3376, Auto memory queue of objects to free.,1,1,0,1
3377, Number of slots in amqueue.,0,0,0,0
3378, Number of used slots in amqueue.,0,0,0,0
3379, REDISMODULE_CTX_... flags.,0,1,0,1
3380, To set with RM_ReplySetArrayLength().,0,0,0,0
3381, Number of entries in postponed_arrays.,0,0,0,0
3382, Privdata set when unblocking a client.,0,0,0,0
3383, Used if there is the REDISMODULE_CTX_KEYS_POS_REQUEST flag set.,0,1,0,1
3384, This represents a Redis key opened with RM_OpenKey().,1,0,0,1
3385, Key name object.,1,1,0,1
3386," Value object, or NULL if the key was not found.",1,1,0,1
3387, Iterator.,0,1,0,1
3388, Opening mode.,0,1,0,1
3389, Zset iterator.,0,0,0,0
3390, REDISMODULE_ZSET_RANGE_,0,1,0,1
3391, Score range.,0,1,0,1
3392, Lex range.,0,0,0,0
3393, Start pos for positional ranges.,0,0,0,0
3394, End pos for positional ranges.,0,0,0,0
3395, Zset iterator current node.,1,0,0,1
3396, Zset iterator end reached flag                               (true if end was reached).,1,0,0,1
3397, RedisModuleKey 'ztype' values.,0,0,0,0
3398, This must always be 0.,0,1,0,1
3399, Function pointer type of a function representing a command inside  a Redis module.,0,0,0,0
3400, This struct holds the information about a command registered by a module.,0,0,0,0
3401, Protocol must be parsed.,0,1,0,1
3402, Nested reply object.,0,1,0,1
3403,No proto                                                or struct free.,1,0,0,1
3404, Reply of RM_Call() function.,0,0,0,0
3405,The function is filled in a lazy  way depending on the function called on the reply structure.,1,0,0,1
3406,"By default  only the type, proto and protolen are filled.",1,0,0,1
3407, REDISMODULE_REPLY_...,0,1,0,1
3408, REDISMODULE_REPLYFLAG_...,0,1,0,1
3409, Len of strings or num of elements of arrays.,0,0,0,0
3410, Raw reply protocol.,1,1,0,1
3411,An SDS string at top-level object.,0,1,0,1
3412, Length of protocol.,0,1,0,1
3413, String pointer for string and error replies.,0,1,0,1
3414,"This                            does not need to be freed, always points inside                            a reply->proto buffer of the reply object or, in                            case of array elements, of parent reply objects.",0,0,0,0
3415, Reply value for integer reply.,0,1,0,1
3416, Array of sub-reply elements.,0,1,0,1
3417, Structure representing a blocked client.,0,1,0,1
3418,We get a pointer to such  an object when blocking from modules.,1,0,0,1
3419, Pointer to the blocked client.,0,1,0,1
3420,or NULL if the client                        was destroyed during the life of this object.,0,0,0,0
3421, Module blocking the client.,0,1,0,1
3422, Reply callback on normal completion.,1,1,0,1
3423, Reply callback on timeout.,0,1,0,1
3424, privdata cleanup callback.,0,0,0,0
3425, Module private data that may be used by the reply                           or timeout callback.,1,0,0,1
3426,It is set via the                           RedisModule_UnblockClient() API.,0,0,0,0
3427, Fake client used to accumulate replies                                       in thread safe contexts.,1,0,0,1
3428, Database number selected by the original client.,1,1,0,1
3429, We need a mutex that is unlocked  or  relocked in beforeSleep() in order to  allow thread safe contexts to execute commands at a safe moment.,1,0,0,1
3430, Function pointer type for keyspace event notification subscriptions from modules.,0,0,0,0
3431, Keyspace notification subscriber information.,0,0,0,0
3432,See RM_SubscribeToKeyspaceEvents() for more information.,1,0,0,1
3433, The module subscribed to the event,0,1,0,1
3434, Notification callback in the module,0,1,0,1
3435, A bit mask of the events the module is interested in,1,1,0,1
3436," Active flag set on entry, to avoid reentrant subscribers      calling themselves",1,0,0,1
3437, The module keyspace notification subscribers list,0,0,0,0
3438," Static client recycled for all notification clients, to avoid allocating  per round.",1,0,0,1
3439, --------------------------------------------------------------------------  Prototypes  --------------------------------------------------------------------------,0,0,0,0
3440, --------------------------------------------------------------------------  Heap allocation raw functions  --------------------------------------------------------------------------,1,0,0,1
3441, Use like malloc().,0,0,0,0
3442,"Memory allocated with this function is reported in  Redis INFO memory, used for keys eviction according to maxmemory settings  and in general is taken into account as memory allocated by Redis.",1,0,0,1
3443,You should avoid using malloc().,0,0,0,0
3444, Use like calloc().,0,0,0,0
3445,"Memory allocated with this function is reported in  Redis INFO memory, used for keys eviction according to maxmemory settings  and in general is taken into account as memory allocated by Redis.",1,0,0,1
3446,You should avoid using calloc() directly.,1,0,0,1
3447, Use like realloc() for memory obtained with RedisModule_Alloc().,0,0,0,0
3448, Use like free() for memory obtained by RedisModule_Alloc() and  RedisModule_Realloc().,1,0,0,1
3449,However you should never try to free with  RedisModule_Free() memory allocated with malloc() inside your module.,1,0,0,1
3450, Like strdup() but returns memory allocated with RedisModule_Alloc().,0,0,0,0
3451, --------------------------------------------------------------------------  Pool allocator  --------------------------------------------------------------------------,0,0,0,0
3452, Release the chain of blocks used for pool allocations.,0,1,0,1
3453, Return heap allocated memory that will be freed automatically when the  module callback function returns.,0,0,0,0
3454,Mostly suitable for small allocations  that are short living and must be released when the callback returns  anyway.,1,0,0,1
3455,"The returned memory is aligned to the architecture word size  if at least word size bytes are requested, otherwise it is just  aligned to the next power of two, so for example a 3 bytes request is  4 bytes aligned while a 2 bytes request is 2 bytes aligned.",1,0,0,1
3456,There is no realloc style function since when this is needed to use the  pool allocator is not a good idea.,1,0,0,1
3457,The function returns NULL if `bytes` is 0.,0,1,0,1
3458, Fix alignment.,0,1,0,1
3459, Create a new block if needed.,1,1,0,1
3460, --------------------------------------------------------------------------  Helpers for modules API implementation  --------------------------------------------------------------------------,0,0,0,0
3461, Create an empty key of the specified type.,1,1,0,1
3462,'kp' must point to a key object  opened for writing where the .value member is set to NULL because the  key was found to be non existing.,1,0,0,1
3463,On success REDISMODULE_OK is returned and the key is populated with  the value of the specified type.,1,0,0,1
3464,The function fails and returns  REDISMODULE_ERR if:   1) The key is not open for writing.,1,0,0,1
3465,2) The key is not empty.,1,1,0,1
3466,3) The specified type is unknown.,1,1,0,1
3467, The key must be open for writing and non existing to proceed.,1,1,0,1
3468, This function is called in low-level API implementation functions in order  to check if the value associated with the key remained empty after an  operation that removed elements from an aggregate data type.,1,0,0,1
3469,"If this happens, the key is deleted from the DB and the key object state  is set to the right one in order to be targeted again by write operations  possibly recreating the key if needed.",1,0,0,1
3470,"The function returns 1 if the key value object is found empty and is  deleted, otherwise 0 is returned.",1,0,0,1
3471, --------------------------------------------------------------------------  Service API exported to modules   Note that all the exported APIs are called RM_<funcname> in the core  and RedisModule_<funcname> in the module side (defined as function  pointers in redismodule.h).,0,0,0,0
3472,"In this way the dynamic linker does not  mess with our global function pointers, overriding it with the symbols  defined in the main executable having the same names.",1,0,0,1
3473, Lookup the requested module API and store the function pointer into the  target pointer.,0,0,0,0
3474,"The function returns REDISMODULE_ERR if there is no such  named API, otherwise REDISMODULE_OK.",1,0,0,1
3475,"This function is not meant to be used by modules developer, it is only  used implicitly by including redismodule.h.",1,0,0,1
3476, Free the context after the user function was called.,1,1,0,1
3477," Helper function for when a command callback is called, in order to handle  details needed to correctly replicate commands.",0,0,0,0
3478," Handle the replication of the final EXEC, since whatever a command      emits is always wrappered around MULTI or EXEC.",1,0,0,1
3479, This Redis command binds the normal Redis command invocation with commands  exported by modules.,1,0,0,1
3480," This function returns the list of keys, with the same interface as the  'getkeys' function of the native commands, for module commands that exported  the ""getkeys-api"" flag during the registration.",1,0,0,1
3481,"This is done when the  list of keys are not at fixed positions, so that first or last or step cannot  be used.",1,0,0,1
3482,"In order to accomplish its work, the module command is called, flagging  the context in a way that the command can recognize this is a special  ""get keys"" call by calling RedisModule_IsKeysPositionRequest(ctx).",1,0,0,1
3483," Return non-zero if a module command, that was declared with the  flag ""getkeys-api"", is called in a special way to get the keys positions  and not to get executed.",1,0,0,1
3484,Otherwise zero is returned.,0,0,0,0
3485," When a module command is called in order to obtain the position of  keys, since it was flagged as ""getkeys-api"" during the registration,  the command implementation checks for this special call using the  RedisModule_IsKeysPositionRequest() API and uses this function in  order to report keys, like in the following example:       if (RedisModule_IsKeysPositionRequest(ctx)) {          RedisModule_KeyAtPos(ctx,1);          RedisModule_KeyAtPos(ctx,2);      }    Note: in the example below the get keys API would not be needed since   keys are at fixed positions.",1,0,0,1
3486,This interface is only used for commands   with a more complex structure.,1,0,0,1
3487, Helper for RM_CreateCommand().,0,0,0,0
3488,Truns a string representing command  flags into the command flags used by the Redis core.,0,0,0,0
3489,"It returns the set of flags, or -1 if unknown flags are found.",1,1,0,1
3490, Some token not processed correctly.,0,1,0,1
3491," Register a new command in the Redis server, that will be handled by  calling the function pointer 'func' using the RedisModule calling  convention.",1,0,0,1
3492,"The function returns REDISMODULE_ERR if the specified command  name is already busy or a set of invalid flags were passed, otherwise  REDISMODULE_OK is returned and the new command is registered.",1,0,0,1
3493,This function must be called during the initialization of the module  inside the RedisModule_OnLoad() function.,0,0,0,0
3494,Calling this function outside  of the initialization function is not defined.,1,0,0,1
3495,"The command function type is the following:        int MyCommand_RedisCommand(RedisModuleCtx ctx, RedisModuleString argv, int argc);   And is supposed to always return REDISMODULE_OK.",1,0,0,1
3496,"The set of flags 'strflags' specify the behavior of the command, and should  be passed as a C string compoesd of space separated words, like for  example ""write deny-oom"".",0,0,0,0
3497,"The set of flags are:    ""write"":     The command may modify the data set (it may also read                     from it).",0,0,0,0
3498,"""readonly"":  The command returns data from keys but never writes.",0,0,0,0
3499,"""admin"":     The command is an administrative command (may change                     replication or perform similar tasks).",1,0,0,1
3500,"""deny-oom"":  The command may use additional memory and should be                     denied during out of memory conditions.",0,0,0,0
3501,"""deny-script"":   Don't allow this command in Lua scripts.",0,0,0,0
3502,"""allow-loading"": Allow this command while the server is loading data.",0,0,0,0
3503,Only commands not interacting with the data set                         should be allowed to run in this mode.,1,0,0,1
3504,If not sure                         don't use this flag.,1,0,0,1
3505,"""pubsub"":    The command publishes things on Pub or Sub channels.",0,0,0,0
3506,"""random"":    The command may have different outputs even starting                     from the same input arguments and key values.",1,0,0,1
3507,"""allow-stale"": The command is allowed to run on slaves that don't                       serve stale data.",1,0,0,1
3508,Don't use if you don't know what                       this means.,0,0,0,0
3509,"""no-monitor"": Don't propoagate the command on monitor.",0,0,0,0
3510,Use this if                      the command has sensible data among the arguments.,0,0,0,0
3511,"""fast"":      The command time complexity is not greater                     than O(log(N)) where N is the size of the collection or                     anything else representing the normal scalability                     issue with the command.",1,0,0,1
3512,"""getkeys-api"": The command implements the interface to return                       the arguments that are keys.",0,0,0,0
3513,Used when start or stop or step                       is not enough because of the command syntax.,1,0,0,1
3514,"""no-cluster"": The command should not register in Redis Cluster                      since is not designed to work with it because, for                      example, is unable to report the position of the                      keys, programmatically creates key names, or any                      other reason.",1,0,0,1
3515, Check if the command name is busy.,1,1,0,1
3516," Create a command ""proxy"", which is a structure that is referenced      in the command table, so that the generic command that works as      binding between modules and Redis, can know what function to call      and what the module is.",0,0,0,0
3517,Note that we use the Redis command table 'getkeys_proc' in order to      pass a reference to the command proxy structure.,0,0,0,0
3518, Called by RM_Init() to setup the `ctx->module` structure.,0,0,0,0
3519,"This is an internal function, Redis modules developers don't need  to use it.",0,0,0,0
3520, Return non-zero if the module name is busy.,1,1,0,1
3521,Otherwise zero is returned.,0,0,0,0
3522, Return the current UNIX time in milliseconds.,1,1,0,1
3523, --------------------------------------------------------------------------  Automatic memory management for modules  --------------------------------------------------------------------------,0,0,0,0
3524, Enable automatic memory management.,0,1,0,1
3525,See API.md for more information.,1,0,0,1
3526,The function must be called as the first function of a command implementation  that wants to use automatic memory.,1,0,0,1
3527, Add a new object to release automatically when the callback returns.,1,1,0,1
3528," Mark an object as freed in the auto release queue, so that users can still  free things manually if they want.",1,0,0,1
3529,"The function returns 1 if the object was actually found in the auto memory  pool, otherwise 0 is returned.",1,0,0,1
3530," For side = 0 check right side of the array, for              side = 1 check the left side instead (zig-zag scanning).",1,0,0,1
3531," Switch the freed element and the last element, to avoid growing                  the queue unnecessarily if we allocate or free in a loop",1,0,0,1
3532, Reduce the size of the queue because we either moved the top                  element elsewhere or freed it,1,0,0,1
3533, Release all the objects in queue.,0,1,0,1
3534," Clear the AUTO_MEMORY flag from the context, otherwise the functions      we call to free the resources, will try to scan the auto release      queue to mark the entries as freed.",1,0,0,1
3535, --------------------------------------------------------------------------  String objects APIs  --------------------------------------------------------------------------,0,0,0,0
3536, Create a new module string object.,1,1,0,1
3537,"The returned string must be freed  with RedisModule_FreeString(), unless automatic memory is enabled.",0,0,0,0
3538,The string is created by copying the `len` bytes starting  at `ptr`.,1,0,0,1
3539,No reference is retained to the passed buffer.,0,1,0,1
3540, Create a new module string object from a printf format and arguments.,1,0,0,1
3541,"The returned string must be freed with RedisModule_FreeString(), unless  automatic memory is enabled.",0,0,0,0
3542,The string is created using the sds formatter function sdscatvprintf().,0,0,0,0
3543," Like RedisModule_CreatString(), but creates a string starting from a long long  integer instead of taking a buffer and its length.",1,0,0,1
3544,The returned string must be released with RedisModule_FreeString() or by  enabling automatic memory management.,0,0,0,0
3545," Like RedisModule_CreatString(), but creates a string starting from another  RedisModuleString.",1,0,0,1
3546,The returned string must be released with RedisModule_FreeString() or by  enabling automatic memory management.,0,0,0,0
3547, Free a module string object obtained with one of the Redis modules API calls  that return new string objects.,1,0,0,1
3548,It is possible to call this function even when automatic memory management  is enabled.,1,0,0,1
3549,In that case the string will be released ASAP and removed  from the pool of string to release at the end.,0,0,0,0
3550," Every call to this function, will make the string 'str' requiring  an additional call to RedisModule_FreeString() in order to really  free the string.",1,0,0,1
3551,Note that the automatic freeing of the string obtained  enabling modules automatic memory management counts for one  RedisModule_FreeString() call (it is just executed automatically).,0,0,0,0
3552,"Normally you want to call this function when, at the same time  the following conditions are true:   1) You have automatic memory management enabled.",1,0,0,1
3553,2) You want to create string objects.,0,1,0,1
3554,3) Those string objects you create need to live after the callback     function(for example a command implementation) creating them returns.,1,0,0,1
3555,"Usually you want this in order to store the created string object  into your own data structure, for example when implementing a new data  type.",1,0,0,1
3556,"Note that when memory management is turned off, you don't need  any call to RetainString() since creating a string will always result  into a string that lives after the callback function returns, if  no FreeString() call is performed.",0,0,0,0
3557, Increment the string reference counting only if we can't          just remove the object from the list of objects that should          be reclaimed.,1,0,0,1
3558,"Why we do that, instead of just incrementing          the refcount in any case, and let the automatic FreeString()          call at the end to bring the refcount back at the desired          value?",0,0,0,0
3559,Because this way we ensure that the object refcount          value is 1 (instead of going to 2 to be dropped later to 1)          after the call to this function.,0,0,0,0
3560,This is needed for functions          like RedisModule_StringAppendBuffer() to work.,0,0,0,0
3561," Given a string module object, this function returns the string pointer  and length of the string.",0,0,0,0
3562,The returned pointer and length should only  be used for read only accesses and never modified.,1,0,0,1
3563, --------------------------------------------------------------------------  Higher level string operations  -------------------------------------------------------------------------,1,0,0,1
3564," Convert the string into a long long integer, storing it at `ll`.",1,0,0,1
3565,Returns REDISMODULE_OK on success.,1,1,0,1
3566,"If the string can't be parsed  as a valid, strict long long (no spaces before or after), REDISMODULE_ERR  is returned.",1,0,0,1
3567," Convert the string into a double, storing it at `d`.",0,1,0,1
3568,Returns REDISMODULE_OK on success or REDISMODULE_ERR if the string is  not a valid string representation of a double value.,1,0,0,1
3569," Compare two string objects, returning -1, 0 or 1 respectively if  a < b, a == b, a > b. Strings are compared byte by byte as two  binary blobs without any encoding care  or  collation attempt.",1,0,0,1
3570," Return the (possibly modified in encoding) input 'str' object if  the string is unshared, otherwise NULL is returned.",1,0,0,1
3571," Note: here we ""leak"" the additional allocation that was          used in order to store the embedded string in the object.",0,0,0,0
3572, Convert the string from integer to raw encoding.,1,1,0,1
3573, Append the specified buffere to the string 'str'.,0,0,0,0
3574,"The string must be a  string created by the user that is referenced only a single time, otherwise  REDISMODULE_ERR is returend and the operation is not performed.",1,0,0,1
3575," --------------------------------------------------------------------------  Reply APIs   Most functions always return REDISMODULE_OK so you can use it with  'return' in order to return from the command implementation with:       if (... some condition ...)          return RM_ReplyWithLongLong(ctx,mycount);  --------------------------------------------------------------------------",1,0,0,1
3576," Send an error about the number of arguments given to the command,  citing the command name in the error message.",0,0,0,0
3577,Example:       if (argc != 3) return RedisModule_WrongArity(ctx);,0,0,0,0
3578, Return the client object the `RM_Reply` functions should target.,0,0,0,0
3579,"Normally this is just `ctx->client`, that is the client that called  the module command, however in the case of thread safe contexts there  is no directly associated client (since it would not be safe to access  the client from a thread), so instead the blocked client object referenced  in the thread safe context, has a fake client that we just use to accumulate  the replies.",1,0,0,1
3580,"Later, when the client is unblocked, the accumulated replies  are appended to the actual client.",1,0,0,1
3581,"The function returns the client pointer depending on the context, or  NULL if there is no potential client.",1,0,0,1
3582,This happens when we are in the  context of a thread safe context that was not initialized with a blocked  client object.,1,0,0,1
3583," Send an integer reply to the client, with the specified long long value.",1,0,0,1
3584,The function always returns REDISMODULE_OK.,0,1,0,1
3585, Reply with an error or simple string (status message).,1,1,0,1
3586,Used to implement  ReplyWithSimpleString() and ReplyWithError().,0,0,0,0
3587,The function always returns REDISMODULE_OK.,0,1,0,1
3588, Reply with the error 'err'.,0,1,0,1
3589,"Note that 'err' must contain all the error, including  the initial error code.",0,0,0,0
3590,"The function only provides the initial ""-"", so  the usage is, for example:       RedisModule_ReplyWithError(ctx,""ERR Wrong Type"");   and not just:       RedisModule_ReplyWithError(ctx,""Wrong Type"");   The function always returns REDISMODULE_OK.",1,0,0,1
3591, Reply with a simple string (+... \r\n in RESP protocol).,1,1,0,1
3592,"This replies  are suitable only when sending a small non-binary string with small  overhead, like ""OK"" or similar replies.",1,0,0,1
3593,The function always returns REDISMODULE_OK.,0,1,0,1
3594, Reply with an array type of 'len' elements.,0,0,0,0
3595,However 'len' other calls  to `ReplyWith` style functions must follow in order to emit the elements  of the array.,1,0,0,1
3596,"When producing arrays with a number of element that is not known beforehand  the function can be called with the special count  REDISMODULE_POSTPONED_ARRAY_LEN, and the actual number of elements can be  later set with RedisModule_ReplySetArrayLength() (which will set the  latest ""open"" count if there are multiple ones).",1,0,0,1
3597,The function always returns REDISMODULE_OK.,0,1,0,1
3598," When RedisModule_ReplyWithArray() is used with the argument  REDISMODULE_POSTPONED_ARRAY_LEN, because we don't know beforehand the number  of items we are going to output as elements of the array, this function  will take care to set the array length.",0,0,0,0
3599,"Since it is possible to have multiple array replies pending with unknown  length, this function guarantees to always set the latest array length  that was created in a postponed way.",1,0,0,1
3600,"For example in order to output an array like [1,[10,20,30]] we  could write:        RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_ARRAY_LEN);       RedisModule_ReplyWithLongLong(ctx,1);       RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_ARRAY_LEN);       RedisModule_ReplyWithLongLong(ctx,10);       RedisModule_ReplyWithLongLong(ctx,20);       RedisModule_ReplyWithLongLong(ctx,30);       RedisModule_ReplySetArrayLength(ctx,3);  or  or  Set len of 10,20,30 array.",0,0,0,0
3601,"RedisModule_ReplySetArrayLength(ctx,2);  or  or  Set len of top array   Note that in the above example there is no reason to postpone the array  length, since we produce a fixed number of elements, but in the practice  the code may use an interator or other ways of creating the output so  that is not easy to calculate in advance the number of elements.",1,0,0,1
3602," Reply with a bulk string, taking in input a C buffer pointer and length.",0,1,0,1
3603,The function always returns REDISMODULE_OK.,0,1,0,1
3604," Reply with a bulk string, taking in input a RedisModuleString object.",0,1,0,1
3605,The function always returns REDISMODULE_OK.,0,1,0,1
3606, Reply to the client with a NULL.,0,1,0,1
3607,"In the RESP protocol a NULL is encoded  as the string ""$-1\r\n"".",0,0,0,0
3608,The function always returns REDISMODULE_OK.,0,1,0,1
3609, Reply exactly what a Redis command returned us with RedisModule_Call().,1,0,0,1
3610,"This function is useful when we use RedisModule_Call() in order to  execute some command, as we want to reply to the client exactly the  same reply we obtained by the command.",1,0,0,1
3611,The function always returns REDISMODULE_OK.,0,1,0,1
3612, Send a string reply obtained converting the double 'd' into a bulk string.,0,1,0,1
3613,"This function is basically equivalent to converting a double into  a string into a C buffer, and then calling the function  RedisModule_ReplyWithStringBuffer() with the buffer and length.",0,0,0,0
3614,The function always returns REDISMODULE_OK.,0,1,0,1
3615, --------------------------------------------------------------------------  Commands replication API  --------------------------------------------------------------------------,0,0,0,0
3616, Helper function to replicate MULTI the first time we replicate something  in the context of a command execution.,1,0,0,1
3617,EXEC will be handled by the  RedisModuleCommandDispatcher() function.,0,0,0,0
3618," Skip this if client explicitly wrap the command with MULTI, or if      the module command was called by a script.",0,0,0,0
3619, If we already emitted MULTI return ASAP.,0,0,0,0
3620," If this is a thread safe context, we do not want to wrap commands      executed into MUTLI or EXEC, they are executed as single commands      from an external client in essence.",1,0,0,1
3621," Replicate the specified command and arguments to slaves and AOF, as effect  of execution of the calling command implementation.",0,0,0,0
3622,The replicated commands are always wrapped into the MULTI or EXEC that  contains all the commands replicated in a given module command  execution.,0,0,0,0
3623,"However the commands replicated with RedisModule_Call()  are the first items, the ones replicated with RedisModule_Replicate()  will all follow before the EXEC.",1,0,0,1
3624,Modules should try to use one interface or the other.,1,1,0,1
3625,"This command follows exactly the same interface of RedisModule_Call(),  so a set of format specifiers must be passed, followed by arguments  matching the provided format specifiers.",1,0,0,1
3626,Please refer to RedisModule_Call() for more information.,1,1,0,1
3627,The command returns REDISMODULE_ERR if the format specifiers are invalid  or the command name does not belong to a known command.,0,0,0,0
3628, Create the client and dispatch the command.,0,1,0,1
3629, Replicate!,0,1,0,1
3630, Release the argv.,0,0,0,0
3631, This function will replicate the command exactly as it was invoked  by the client.,1,0,0,1
3632,"Note that this function will not wrap the command into  a MULTI or EXEC stanza, so it should not be mixed with other replication  commands.",1,0,0,1
3633,"Basically this form of replication is useful when you want to propagate  the command to the slaves and AOF file exactly as it was called, since  the command can just be re-executed to deterministically re-create the  new state starting from the old one.",1,0,0,1
3634,The function always returns REDISMODULE_OK.,0,1,0,1
3635, --------------------------------------------------------------------------  DB and Key APIs -- Generic API  --------------------------------------------------------------------------,1,0,0,1
3636, Return the ID of the current client calling the currently active module  command.,1,0,0,1
3637,The returned ID has a few guarantees:   1.,1,0,0,1
3638,"The ID is different for each different client, so if the same client     executes a module command multiple times, it can be recognized as     having the same ID, otherwise the ID will be different.",1,0,0,1
3639,The ID increases monotonically.,0,1,0,1
3640,Clients connecting to the server later     are guaranteed to get IDs greater than any past ID previously seen.,1,0,0,1
3641,Valid IDs are from 1 to 2^64-1.,0,1,0,1
3642,If 0 is returned it means there is no way  to fetch the ID in the context the function was currently called.,1,0,0,1
3643, Return the currently selected DB.,1,1,0,1
3644, Return the current context's flags.,1,1,0,1
3645,"The flags provide information on the  current request context (whether the client is a Lua script or in a MULTI),  and about the Redis instance in general, i.e replication and persistence.",1,0,0,1
3646,The available flags are:     REDISMODULE_CTX_FLAGS_LUA: The command is running in a Lua script     REDISMODULE_CTX_FLAGS_MULTI: The command is running inside a transaction     REDISMODULE_CTX_FLAGS_MASTER: The Redis instance is a master     REDISMODULE_CTX_FLAGS_SLAVE: The Redis instance is a slave     REDISMODULE_CTX_FLAGS_READONLY: The Redis instance is read-only     REDISMODULE_CTX_FLAGS_CLUSTER: The Redis instance is in cluster mode     REDISMODULE_CTX_FLAGS_AOF: The Redis instance has AOF enabled     REDISMODULE_CTX_FLAGS_RDB: The instance has RDB enabled     REDISMODULE_CTX_FLAGS_MAXMEMORY:  The instance has Maxmemory set     REDISMODULE_CTX_FLAGS_EVICT:  Maxmemory is set and has an eviction     policy that may delete keys     REDISMODULE_CTX_FLAGS_OOM: Redis is out of memory according to the     maxmemory setting.,1,0,0,1
3647,REDISMODULE_CTX_FLAGS_OOM_WARNING: Less than 25% of memory remains before                                        reaching the maxmemory level.,1,0,0,1
3648, Client specific flags,1,1,0,1
3649, Maxmemory and eviction policy,0,0,0,0
3650, Persistence flags,0,1,0,1
3651, Replication flags,0,1,0,1
3652, OOM flag.,0,1,0,1
3653, Change the currently selected DB.,1,1,0,1
3654,Returns an error if the id  is out of range.,0,0,0,0
3655,Note that the client will retain the currently selected DB even after  the Redis command implemented by the module calling this function  returns.,1,0,0,1
3656,"If the module command wishes to change something in a different DB and  returns back to the original one, it should call RedisModule_GetSelectedDb()  before in order to restore the old DB number before returning.",1,0,0,1
3657," Return an handle representing a Redis key, so that it is possible  to call other APIs with the key handle as argument to perform  operations on the key.",1,0,0,1
3658,"The return value is the handle repesenting the key, that must be  closed with RM_CloseKey().",1,0,0,1
3659,"If the key does not exist and WRITE mode is requested, the handle  is still returned, since it is possible to perform operations on  a yet not existing key (that will be created, for example, after  a list push operation).",1,0,0,1
3660,"If the mode is just READ instead, and the  key does not exist, NULL is returned.",1,0,0,1
3661,However it is still safe to  call RedisModule_CloseKey() and RedisModule_KeyType() on a NULL  value.,1,0,0,1
3662, Setup the key handle.,1,1,0,1
3663, Close a key handle.,1,1,0,1
3664, TODO: if (key->iter) RM_KeyIteratorStop(kp);,0,0,0,0
3665, Return the type of the key.,1,1,0,1
3666,If the key pointer is NULL then  REDISMODULE_KEYTYPE_EMPTY is returned.,1,0,0,1
3667, We map between defines so that we are free to change the internal      defines as desired.,1,0,0,1
3668, Return the length of the value associated with the key.,1,1,0,1
3669,For strings this is the length of the string.,0,1,0,1
3670,For all the other types  is the number of elements (just counting keys for hashes).,1,0,0,1
3671,"If the key pointer is NULL or the key is empty, zero is returned.",1,1,0,1
3672," If the key is open for writing, remove it, and setup the key to  accept new writes as an empty key (that will be created on demand).",1,0,0,1
3673,On success REDISMODULE_OK is returned.,1,1,0,1
3674,If the key is not open for  writing REDISMODULE_ERR is returned.,1,0,0,1
3675," If the key is open for writing, unlink it (that is delete it in a   non-blocking way, not reclaiming memory immediately) and setup the key to  accept new writes as an empty key (that will be created on demand).",1,0,0,1
3676,On success REDISMODULE_OK is returned.,1,1,0,1
3677,If the key is not open for  writing REDISMODULE_ERR is returned.,1,0,0,1
3678," Return the key expire value, as milliseconds of remaining TTL.",1,1,0,1
3679,"If no TTL is associated with the key or if the key is empty,  REDISMODULE_NO_EXPIRE is returned.",1,0,0,1
3680, Set a new expire for the key.,1,1,0,1
3681,"If the special expire  REDISMODULE_NO_EXPIRE is set, the expire is cancelled if there was  one (the same as the PERSIST command).",1,0,0,1
3682,Note that the expire must be provided as a positive integer representing  the number of milliseconds of TTL the key should have.,1,0,0,1
3683,The function returns REDISMODULE_OK on success or REDISMODULE_ERR if  the key was not open for writing or is an empty key.,1,0,0,1
3684, --------------------------------------------------------------------------  Key API for String type  --------------------------------------------------------------------------,1,0,0,1
3685," If the key is open for writing, set the specified string 'str' as the  value of the key, deleting the old value if any.",1,0,0,1
3686,On success REDISMODULE_OK is returned.,1,1,0,1
3687,"If the key is not open for  writing or there is an active iterator, REDISMODULE_ERR is returned.",1,0,0,1
3688," Prepare the key associated string value for DMA access, and returns  a pointer and size (by reference), that the user can use to read or  modify the string in-place accessing it directly via pointer.",1,0,0,1
3689,"The 'mode' is composed by bitwise OR-ing the following flags:       REDISMODULE_READ -- Read access      REDISMODULE_WRITE -- Write access   If the DMA is not requested for writing, the pointer returned should  only be accessed in a read-only fashion.",1,0,0,1
3690,On error (wrong type) NULL is returned.,1,1,0,1
3691,DMA access rules:   1.,0,0,0,0
3692,"No other key writing function should be called since the moment  the pointer is obtained, for all the time we want to use DMA access  to read or modify the string.",1,0,0,1
3693,"Each time RM_StringTruncate() is called, to continue with the DMA  access, RM_StringDMA() should be called again to re-obtain  a new pointer and length.",1,0,0,1
3694,"If the returned pointer is not NULL, but the length is zero, no  byte can be touched (the string is empty, or the key itself is empty)  so a RM_StringTruncate() call should be used if there is to enlarge  the string, and later call StringDMA() again to get the pointer.",1,0,0,1
3695," We need to return some pointer for empty keys, we just return      a string literal pointer, that is the advantage to be mapped into      a read only memory page, so the module will segfault if a write      attempt is performed.",1,0,0,1
3696," For write access, and even for read access if the object is encoded,      we unshare the string (that has the side effect of decoding it).",0,0,0,0
3697," If the string is open for writing and is of string type, resize it, padding  with zero bytes if the new length is greater than the old one.",1,0,0,1
3698,"After this call, RM_StringDMA() must be called again to continue  DMA access with the new pointer.",1,0,0,1
3699,"The function returns REDISMODULE_OK on success, and REDISMODULE_ERR on  error, that is, the key is not open for writing, is not a string  or resizing for more than 512 MB is requested.",1,0,0,1
3700,"If the key is empty, a string key is created with the new string value  unless the new length value requested is zero.",1,0,0,1
3701, Empty key and new len set to 0.,1,0,0,1
3702,Just return REDISMODULE_OK without      doing anything.,0,0,0,0
3703, Empty key: create it with the new size.,1,1,0,1
3704, Unshare and resize.,0,0,0,0
3705," If the string is too wasteful, reallocate it.",0,1,0,1
3706, --------------------------------------------------------------------------  Key API for List type  --------------------------------------------------------------------------,1,0,0,1
3707," Push an element into a list, on head or tail depending on 'where' argumnet.",0,0,0,0
3708,"If the key pointer is about an empty key opened for writing, the key  is created.",1,0,0,1
3709,"On error (key opened for read-only operations or of the wrong  type) REDISMODULE_ERR is returned, otherwise REDISMODULE_OK is returned.",1,0,0,1
3710," Pop an element from the list, and returns it as a module string object  that the user should be free with RM_FreeString() or by enabling  automatic memory.",1,0,0,1
3711,'where' specifies if the element should be popped from  head or tail.,0,0,0,0
3712,The command returns NULL if:  1) The list is empty.,1,0,0,1
3713,2) The key was not open for writing.,1,1,0,1
3714,3) The key is not a list.,1,1,0,1
3715, --------------------------------------------------------------------------  Key API for Sorted Set type  --------------------------------------------------------------------------,1,0,0,1
3716," Conversion from or to public flags of the Modules API and our private flags,  so that we have everything decoupled.",1,0,0,1
3717, See previous function comment.,1,1,0,1
3718," Add a new element into a sorted set, with the specified 'score'.",1,1,0,1
3719,"If the element already exists, the score is updated.",0,1,0,1
3720,A new sorted set is created at value if the key is an empty open key  setup for writing.,1,0,0,1
3721,"Additional flags can be passed to the function via a pointer, the flags  are both used to receive input and to communicate state when the function  returns.",0,0,0,0
3722,'flagsptr' can be NULL if no special flags are used.,1,0,0,1
3723,The input flags are:       REDISMODULE_ZADD_XX: Element must already exist.,0,0,0,0
3724,Do nothing otherwise.,0,1,0,1
3725,REDISMODULE_ZADD_NX: Element must not exist.,0,1,0,1
3726,Do nothing otherwise.,0,1,0,1
3727,The output flags are:       REDISMODULE_ZADD_ADDED: The new element was added to the sorted set.,1,0,0,1
3728,REDISMODULE_ZADD_UPDATED: The score of the element was updated.,0,1,0,1
3729,REDISMODULE_ZADD_NOP: No operation was performed because XX or NX flags.,0,1,0,1
3730,On success the function returns REDISMODULE_OK.,1,1,0,1
3731,On the following errors  REDISMODULE_ERR is returned:    The key was not opened for writing.,1,0,0,1
3732,The key is of the wrong type.,1,1,0,1
3733,'score' double value is not a number (NaN).,0,0,0,0
3734," This function works exactly like RM_ZsetAdd(), but instead of setting  a new score, the score of the existing element is incremented, or if the  element does not already exist, it is added assuming the old score was  zero.",1,0,0,1
3735,"The input and output flags, and the return value, have the same exact  meaning, with the only difference that this function will return  REDISMODULE_ERR even when 'score' is a valid double number, but adding it  to the existing score resuts into a NaN (not a number) condition.",1,0,0,1
3736,"This function has an additional field 'newscore', if not NULL is filled  with the new score of the element after the increment, if no error  is returned.",1,0,0,1
3737, zsetAdd() may signal back that the resulting score is not a number.,0,0,0,0
3738, Remove the specified element from the sorted set.,0,1,0,1
3739,"The function returns REDISMODULE_OK on success, and REDISMODULE_ERR  on one of the following conditions:    The key was not opened for writing.",1,0,0,1
3740,The key is of the wrong type.,1,1,0,1
3741,"The return value does NOT indicate the fact the element was really  removed (since it existed) or not, just if the function was executed  with success.",1,0,0,1
3742,"In order to know if the element was removed, the additional argument  'deleted' must be passed, that populates the integer by reference  setting it to 1 or 0 depending on the outcome of the operation.",0,0,0,0
3743,The 'deleted' argument can be NULL if the caller is not interested  to know if the element was really removed.,1,0,0,1
3744,Empty keys will be handled correctly by doing nothing.,1,1,0,1
3745, On success retrieve the double score associated at the sorted set element  'ele' and returns REDISMODULE_OK.,1,0,0,1
3746,Otherwise REDISMODULE_ERR is returned  to signal one of the following conditions:    There is no such element 'ele' in the sorted set.,1,0,0,1
3747,The key is not a sorted set.,1,1,0,1
3748,The key is an open empty key.,1,1,0,1
3749, --------------------------------------------------------------------------  Key API for Sorted Set iterator  --------------------------------------------------------------------------,1,0,0,1
3750, Stop a sorted set iteration.,0,1,0,1
3751, Free resources if needed.,1,1,0,1
3752, Setup sensible values so that misused iteration API calls when an      iterator is not active will result into something more sensible      than crashing.,1,0,0,1
3753," Return the ""End of range"" flag value to signal the end of the iteration.",0,0,0,0
3754, Helper function for RM_ZsetFirstInScoreRange() and RM_ZsetLastInScoreRange().,0,0,0,0
3755,Setup the sorted set iteration according to the specified score range  (see the functions calling it for more info).,1,0,0,1
3756,If 'first' is true the  first element in the range is used as a starting point for the iterator  otherwise the last.,1,0,0,1
3757,Return REDISMODULE_OK on success otherwise  REDISMODULE_ERR.,1,0,0,1
3758, Setup the range structure used by the sorted set core implementation      in order to seek at the specified element.,0,0,0,0
3759, Setup a sorted set iterator seeking the first element in the specified  range.,1,0,0,1
3760,Returns REDISMODULE_OK if the iterator was correctly initialized  otherwise REDISMODULE_ERR is returned in the following conditions:   1.,1,0,0,1
3761,The value stored at key is not a sorted set or the key is empty.,1,1,0,1
3762,The range is specified according to the two double values 'min' and 'max'.,0,1,0,1
3763,"Both can be infinite using the following two macros:   REDISMODULE_POSITIVE_INFINITE for positive infinite value  REDISMODULE_NEGATIVE_INFINITE for negative infinite value   'minex' and 'maxex' parameters, if true, respectively setup a range  where the min and max value are exclusive (not included) instead of  inclusive.",1,0,0,1
3764, Exactly like RedisModule_ZsetFirstInScoreRange() but the last element of  the range is selected for the start of the iteration instead.,1,0,0,1
3765, Helper function for RM_ZsetFirstInLexRange() and RM_ZsetLastInLexRange().,0,0,0,0
3766,Setup the sorted set iteration according to the specified lexicographical  range (see the functions calling it for more info).,1,0,0,1
3767,If 'first' is true the  first element in the range is used as a starting point for the iterator  otherwise the last.,1,0,0,1
3768,Return REDISMODULE_OK on success otherwise  REDISMODULE_ERR.,1,0,0,1
3769,Note that this function takes 'min' and 'max' in the same form of the  Redis ZRANGEBYLEX command.,1,0,0,1
3770, Setup the range structure used by the sorted set core implementation      in order to seek at the specified element.,0,0,0,0
3771," Set the range type to lex only after successfully parsing the range,      otherwise we don't want the zlexrangespec to be freed.",1,0,0,1
3772, Setup a sorted set iterator seeking the first element in the specified  lexicographical range.,1,0,0,1
3773,Returns REDISMODULE_OK if the iterator was correctly  initialized otherwise REDISMODULE_ERR is returned in the  following conditions:   1.,1,0,0,1
3774,The value stored at key is not a sorted set or the key is empty.,1,1,0,1
3775,The lexicographical range 'min' and 'max' format is invalid.,0,1,0,1
3776,'min' and 'max' should be provided as two RedisModuleString objects  in the same format as the parameters passed to the ZRANGEBYLEX command.,1,0,0,1
3777,"The function does not take ownership of the objects, so they can be released  ASAP after the iterator is setup.",0,0,0,0
3778, Exactly like RedisModule_ZsetFirstInLexRange() but the last element of  the range is selected for the start of the iteration instead.,1,0,0,1
3779, Return the current sorted set element of an active sorted set iterator  or NULL if the range specified in the iterator does not include any  element.,1,0,0,1
3780, Go to the next element of the sorted set iterator.,0,1,0,1
3781,"Returns 1 if there was  a next element, 0 if we are already at the latest element or the range  does not include any item at all.",1,0,0,1
3782, No active iterator.,1,1,0,1
3783, Skip element.,0,1,0,1
3784, Skip score.,0,1,0,1
3785, Are we still within the range?,0,1,0,1
3786, Fetch the next element score for the                  range check.,0,0,0,0
3787, Skip next element.,0,1,0,1
3788, Obtain the next score.,0,1,0,1
3789, Are we still within the range?,0,1,0,1
3790, Go to the previous element of the sorted set iterator.,1,1,0,1
3791,"Returns 1 if there was  a previous element, 0 if we are already at the first element or the range  does not include any item at all.",1,0,0,1
3792, No active iterator.,1,1,0,1
3793, Go back to previous score.,1,1,0,1
3794, Back to previous ele.,1,0,0,1
3795, Are we still within the range?,0,1,0,1
3796, Fetch the previous element score for the                  range check.,1,0,0,1
3797, Skip element to get the score.,0,1,0,1
3798, Obtain the prev score.,0,0,0,0
3799, Are we still within the range?,0,1,0,1
3800, --------------------------------------------------------------------------  Key API for Hash type  --------------------------------------------------------------------------,1,0,0,1
3801, Set the field of the specified hash field to the specified value.,0,1,0,1
3802,"If the key is an empty key open for writing, it is created with an empty  hash value, in order to set the specified field.",1,0,0,1
3803,"The function is variadic and the user must specify pairs of field  names and values, both as RedisModuleString pointers (unless the  CFIELD option is set, see later).",0,0,0,0
3804,"Example to set the hash argv[1] to the value argv[2]:        RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[1],argv[2],NULL);   The function can also be used in order to delete fields (if they exist)  by setting them to the specified value of REDISMODULE_HASH_DELETE:        RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[1],                           REDISMODULE_HASH_DELETE,NULL);   The behavior of the command changes with the specified flags, that can be  set to REDISMODULE_HASH_NONE if no special behavior is needed.",1,0,0,1
3805,REDISMODULE_HASH_NX: The operation is performed only if the field was not                           already existing in the hash.,1,0,0,1
3806,"REDISMODULE_HASH_XX: The operation is performed only if the field was                           already existing, so that a new value could be                           associated to an existing filed, but no new fields                           are created.",1,0,0,1
3807,REDISMODULE_HASH_CFIELDS: The field names passed are null terminated C                                strings instead of RedisModuleString objects.,0,0,0,0
3808,"Unless NX is specified, the command overwrites the old field value with  the new one.",1,0,0,1
3809,"When using REDISMODULE_HASH_CFIELDS, field names are reported using  normal C strings, so for example to delete the field ""foo"" the following  code can be used:        RedisModule_HashSet(key,REDISMODULE_HASH_CFIELDS,""foo"",                           REDISMODULE_HASH_DELETE,NULL);   Return value:   The number of fields updated (that may be less than the number of fields  specified because of the XX or NX options).",1,0,0,1
3810,In the following case the return value is always zero:    The key was not open for writing.,1,0,0,1
3811,The key was associated with a non Hash value.,1,1,0,1
3812, Get the field and value objects.,0,1,0,1
3813, Handle XX and NX,0,1,0,1
3814, Handle deletion if value is REDISMODULE_HASH_DELETE.,0,1,0,1
3815," If CFIELDS is active, we can pass the ownership of the          SDS object to the low level function that sets the field          to avoid a useless copy.",1,0,0,1
3816," If CFIELDS is active, SDS string ownership is now of hashTypeSet(),          however we still have to release the 'field' object shell.",1,0,0,1
3817, Prevent the SDS string from being freed.,0,1,0,1
3818, Get fields from an hash value.,0,0,0,0
3819,"This function is called using a variable  number of arguments, alternating a field name (as a StringRedisModule  pointer) with a pointer to a StringRedisModule pointer, that is set to the  value of the field if the field exist, or NULL if the field did not exist.",0,0,0,0
3820,"At the end of the field or value-ptr pairs, NULL must be specified as last  argument to signal the end of the arguments in the variadic function.",1,0,0,1
3821,"This is an example usage:        RedisModuleString first, second;       RedisModule_HashGet(mykey,REDISMODULE_HASH_NONE,argv[1],&first,                       argv[2],&second,NULL);   As with RedisModule_HashSet() the behavior of the command can be specified  passing flags different than REDISMODULE_HASH_NONE:   REDISMODULE_HASH_CFIELD: field names as null terminated C strings.",1,0,0,1
3822,"REDISMODULE_HASH_EXISTS: instead of setting the value of the field  expecting a RedisModuleString pointer to pointer, the function just  reports if the field esists or not and expects an integer pointer  as the second element of each pair.",0,0,0,0
3823,"Example of REDISMODULE_HASH_CFIELD:        RedisModuleString username, hashedpass;       RedisModule_HashGet(mykey,""username"",&username,""hp"",&hashedpass, NULL);   Example of REDISMODULE_HASH_EXISTS:        int exists;       RedisModule_HashGet(mykey,argv[1],&exists,NULL);   The function returns REDISMODULE_OK on success and REDISMODULE_ERR if  the key is not an hash value.",1,0,0,1
3824,"Memory management:   The returned RedisModuleString objects should be released with  RedisModule_FreeString(), or by enabling automatic memory management.",0,0,0,0
3825, Get the field object and the value pointer to pointer.,0,1,0,1
3826, Query the hash for existence or value object.,0,1,0,1
3827, Cleanup,0,1,0,1
3828, --------------------------------------------------------------------------  Redis <-> Modules generic Call() API  --------------------------------------------------------------------------,0,0,0,0
3829, Create a new RedisModuleCallReply object.,1,1,0,1
3830,"The processing of the reply  is lazy, the object is just populated with the raw protocol and later  is processed as needed.",1,0,0,1
3831,"Initially we just make sure to set the right  reply type, which is extremely cheap to do.",1,0,0,1
3832, Lazy parsing.,1,1,0,1
3833," Do nothing if REDISMODULE_REPLYFLAG_TOPARSE is false, otherwise  use the protcol of the reply in reply->proto in order to fill the  reply with parsed data according to the reply type.",1,0,0,1
3834, handled by next item.,0,0,0,0
3835, Free a Call reply and all the nested replies it contains if it's an  array.,1,0,0,1
3836, Don't free nested replies by default: the user must always free the      toplevel reply.,1,0,0,1
3837,However be gentle and don't crash if the module      misuses the API.,1,0,0,1
3838," For nested replies, we don't free reply->proto (which if not NULL      references the parent reply->proto buffer), nor the structure      itself which is allocated as an array of structures, and is freed      when the array value is released.",1,0,0,1
3839, Wrapper for the recursive free reply function.,1,1,0,1
3840,"This is needed in order  to have the first level function to return on nested replies, but only  if called by the module API.",1,0,0,1
3841, Return the reply type.,0,1,0,1
3842," Return the reply type length, where applicable.",0,1,0,1
3843," Return the 'idx'-th nested call reply element of an array reply, or NULL  if the reply type is wrong or the index is out of range.",1,0,0,1
3844, Return the long long of an integer reply.,1,0,0,1
3845, Return the pointer and length of a string or error reply.,0,1,0,1
3846," Return a new string object from a call reply of type string, error or  integer.",1,0,0,1
3847,Otherwise (wrong reply type) return NULL.,1,0,0,1
3848," Returns an array of robj pointers, and populates argc with the number  of items, by parsing the format specifier ""fmt"" as described for  the RM_Call(), RM_Replicate() and other module APIs.",1,0,0,1
3849,"The integer pointed by 'flags' is populated with flags according  to special modifiers in ""fmt"".",1,0,0,1
3850,"For now only one exists:       ""!""",1,0,0,1
3851,-> REDISMODULE_ARGV_REPLICATE   On error (format specifier error) NULL is returned and nothing is  allocated.,0,0,0,0
3852,On success the argument vector is returned.,1,1,0,1
3853," As a first guess to avoid useless reallocations, size argv to      hold one argument for each char specifier in 'fmt'.",1,0,0,1
3854, +1 because of the command name.,0,1,0,1
3855, Build the arguments vector based on the format specifier.,0,1,0,1
3856, Create the client and dispatch the command.,0,1,0,1
3857, A vector of strings,0,1,0,1
3858, We need to grow argv to hold the vector's elements.,0,0,0,0
3859,"We resize by vector_len-1 elements, because we held               one element in argv for the vector already",0,0,0,0
3860, Exported API to call any Redis command from modules.,0,0,0,0
3861,"On success a RedisModuleCallReply object is returned, otherwise  NULL is returned and errno is set to the following values:   EINVAL: command non existing, wrong arity, wrong format specifier.",1,0,0,1
3862,EPERM:  operation in Cluster instance with key in non local slot.,1,0,0,1
3863, Replicate this command?,0,1,0,1
3864, Create the client and dispatch the command.,0,1,0,1
3865, Setup our fake client for command execution.,1,1,0,1
3866, We handle the above format error only when the client is setup so that      we can free it normally.,1,0,0,1
3867, Basic arity checks.,1,0,0,1
3868," If this is a Redis Cluster node, we need to make sure the module is not      trying to access non-local keys, with the exception of commands      received from our master.",1,0,0,1
3869, Duplicate relevant flags in the module client.,1,1,0,1
3870," If we are using single commands replication, we need to wrap what      we propagate into a MULTI or EXEC block, so that it will be atomic like      a Lua script in the context of AOF and slaves.",1,0,0,1
3871, Run the command,0,1,0,1
3872, Convert the result of the Redis command into a suitable Lua type.,1,0,0,1
3873,The first thing we need is to create a single string from the client      output buffers.,1,0,0,1
3874," Return a pointer, and a length, to the protocol returned by the command  that returned the reply object.",0,0,0,0
3875," --------------------------------------------------------------------------  Modules data types   When String DMA or using existing data structures is not enough, it is  possible to create new data types from scratch and export them to  Redis.",1,0,0,1
3876,"The module must provide a set of callbacks for handling the  new values exported (for example in order to provide RDB saving or loading,  AOF rewrite, and so forth).",1,0,0,1
3877,In this section we define this API.,0,1,0,1
3878, Turn a 9 chars name in the specified charset and a 10 bit encver into  a single 64 bit unsigned integer that represents this exact module name  and version.,1,0,0,1
3879,"This final number is called a ""type ID"" and is used when  writing module exported values to RDB files, in order to re-associate the  value to the right module to load them during RDB loading.",1,0,0,1
3880,"If the string is not of the right length or the charset is wrong, or  if encver is outside the unsigned 10 bit integer range, 0 is returned,  otherwise the function returns the right type ID.",1,0,0,1
3881,"The resulting 64 bit integer is composed as follows:       (high order bits) 6|6|6|6|6|6|6|6|6|10 (low order bits)   The first 6 bits value is the first character, name[0], while the last  6 bits value, immediately before the 10 bits integer, is name[8].",1,0,0,1
3882,The last 10 bits are the encoding version.,1,1,0,1
3883,"Note that a name and encver combo of ""AAAAAAAAA"" and 0, will produce  zero as return value, that is the same we use to signal errors, thus  this combination is invalid, and also useless since type names should  try to be vary to avoid collisions.",1,0,0,1
3884, We use 64 symbols so that we can map each character into 6 bits      of the final output.,1,0,0,1
3885," Search, in the list of exported data types of all the modules registered,  a type with the same name as the one given.",1,0,0,1
3886,"Returns the moduleType  structure pointer if such a module is found, or NULL otherwise.",1,0,0,1
3887," Lookup a module by ID, with caching.",0,0,0,0
3888,This function is used during RDB  loading.,0,0,0,0
3889,"Modules exporting data types should never be able to unload, so  our cache does not need to expire.",1,0,0,1
3890, Search in cache to start.,0,1,0,1
3891, Slow module by module lookup.,1,0,0,1
3892, Compare only the 54 bit module identifier and not the              encoding version.,1,0,0,1
3893, Add to cache if possible.,1,1,0,1
3894," Turn an (unresolved) module ID into a type name, to show the user an  error when RDB files contain module data we can't load.",0,0,0,0
3895,The buffer pointed by 'name' must be 10 bytes at least.,1,1,0,1
3896,The function will  fill it with a null terminated module name.,0,0,0,0
3897, Register a new data type exported by the module.,1,1,0,1
3898,The parameters are the  following.,1,0,0,1
3899,"Please for in depth documentation check the modules API  documentation, especially the TYPES.md file.",1,0,0,1
3900,name: A 9 characters data type name that MUST be unique in the Redis    Modules ecosystem.,1,0,0,1
3901,Be creative... and there will be no collisions.,1,1,0,1
3902,"Use    the charset A-Z a-z 9-0, plus the two ""-_"" characters.",0,0,0,0
3903,"A good    idea is to use, for example `<typename>-<vendor>`.",1,0,0,1
3904,"For example    ""tree-AntZ"" may mean ""Tree data structure by @antirez"".",1,0,0,1
3905,To use both    lower case and upper case letters helps in order to prevent collisions.,0,0,0,0
3906,"encver: Encoding version, which is, the version of the serialization    that a module used in order to persist data.",0,0,0,0
3907,"As long as the ""name""    matches, the RDB loading will be dispatched to the type callbacks    whatever 'encver' is used, however the module can understand if    the encoding it must load are of an older version of the module.",1,0,0,1
3908,"For example the module ""tree-AntZ"" initially used encver=0.",0,0,0,0
3909,"Later    after an upgrade, it started to serialize data in a different format    and to register the type with encver=1.",1,0,0,1
3910,However this module may    still load old data produced by an older version if the rdb_load    callback is able to check the encver value and act accordingly.,1,0,0,1
3911,"The encver must be a positive value between 0 and 1023.   typemethods_ptr is a pointer to a RedisModuleTypeMethods structure    that should be populated with the methods callbacks and structure    version, like in the following example:        RedisModuleTypeMethods tm = {           .version = REDISMODULE_TYPE_METHOD_VERSION,           .rdb_load = myType_RDBLoadCallBack,           .rdb_save = myType_RDBSaveCallBack,           .aof_rewrite = myType_AOFRewriteCallBack,           .free = myType_FreeCallBack,             or  or  Optional fields           .digest = myType_DigestCallBack,           .mem_usage = myType_MemUsageCallBack,       }    rdb_load: A callback function pointer that loads data from RDB files.",1,0,0,1
3912,rdb_save: A callback function pointer that saves data to RDB files.,0,0,0,0
3913,aof_rewrite: A callback function pointer that rewrites data as commands.,0,0,0,0
3914,digest: A callback function pointer that is used for `DEBUG DIGEST`.,0,0,0,0
3915,free: A callback function pointer that can free a type value.,1,0,0,1
3916,The digest and mem_usage methods should currently be omitted since  they are not yet implemented inside the Redis modules core.,1,0,0,1
3917,"Note: the module name ""AAAAAAAAA"" is reserved and produces an error, it  happens to be pretty lame as well.",1,0,0,1
3918,"If there is already a module registering a type with the same name,  and if the module name or encver is invalid, NULL is returned.",1,0,0,1
3919,"Otherwise the new type is registered into Redis, and a reference of  type RedisModuleType is returned: the caller of the function should store  this reference into a gobal variable to make future use of it in the  modules type API, since a single module may register multiple types.",1,0,0,1
3920,Example code fragment:        static RedisModuleType BalancedTreeType;        int RedisModule_OnLoad(RedisModuleCtx ctx) {            or  or  some code here ...           BalancedTreeType = RM_CreateDataType(...);       },1,0,0,1
3921," If the key is open for writing, set the specified module type object  as the value of the key, deleting the old value if any.",1,0,0,1
3922,On success REDISMODULE_OK is returned.,1,1,0,1
3923,"If the key is not open for  writing or there is an active iterator, REDISMODULE_ERR is returned.",1,0,0,1
3924," Assuming RedisModule_KeyType() returned REDISMODULE_KEYTYPE_MODULE on  the key, returns the moduel type pointer of the value stored at key.",1,0,0,1
3925,"If the key is NULL, is not associated with a module type, or is empty,  then NULL is returned instead.",1,0,0,1
3926," Assuming RedisModule_KeyType() returned REDISMODULE_KEYTYPE_MODULE on  the key, returns the module type low-level value stored at key, as  it was set by the user via RedisModule_ModuleTypeSet().",1,0,0,1
3927,"If the key is NULL, is not associated with a module type, or is empty,  then NULL is returned instead.",1,0,0,1
3928, --------------------------------------------------------------------------  RDB loading and saving functions  --------------------------------------------------------------------------,0,0,0,0
3929, Called when there is a load error in the context of a module.,0,1,0,1
3930,This cannot  be recovered like for the built-in types.,0,0,0,0
3931, Save an unsigned 64 bit value into the RDB file.,0,1,0,1
3932,This function should only  be called in the context of the rdb_save method of modules implementing new  data types.,1,0,0,1
3933, Save opcode.,0,0,0,0
3934, Save value.,0,1,0,1
3935, Load an unsigned 64 bit value from the RDB file.,0,1,0,1
3936,This function should only  be called in the context of the rdb_load method of modules implementing  new data types.,1,0,0,1
3937, Never reached.,0,1,0,1
3938, Like RedisModule_SaveUnsigned() but for signed 64 bit values.,0,1,0,1
3939, Like RedisModule_LoadUnsigned() but for signed 64 bit values.,0,1,0,1
3940," In the context of the rdb_save method of a module type, saves a  string into the RDB file taking as input a RedisModuleString.",0,0,0,0
3941,The string can be later loaded with RedisModule_LoadString() or  other Load family functions expecting a serialized string inside  the RDB file.,1,0,0,1
3942, Save opcode.,0,0,0,0
3943, Save value.,0,1,0,1
3944, Like RedisModule_SaveString() but takes a raw C pointer and length  as input.,1,0,0,1
3945, Save opcode.,0,0,0,0
3946, Save value.,0,1,0,1
3947, Implements RM_LoadString() and RM_LoadStringBuffer(),0,0,0,0
3948, Never reached.,0,1,0,1
3949," In the context of the rdb_load method of a module data type, loads a string  from the RDB file, that was previously saved with RedisModule_SaveString()  functions family.",1,0,0,1
3950,"The returned string is a newly allocated RedisModuleString object, and  the user should at some point free it with a call to RedisModule_FreeString().",1,0,0,1
3951,"If the data structure does not store strings as RedisModuleString objects,  the similar function RedisModule_LoadStringBuffer() could be used instead.",1,0,0,1
3952," Like RedisModule_LoadString() but returns an heap allocated string that  was allocated with RedisModule_Alloc(), and can be resized or freed with  RedisModule_Realloc() or RedisModule_Free().",0,0,0,0
3953,The size of the string is stored at 'lenptr' if not NULL.,0,0,0,0
3954,"The returned string is not automatically NULL termianted, it is loaded  exactly as it was stored inisde the RDB file.",1,0,0,1
3955," In the context of the rdb_save method of a module data type, saves a double  value to the RDB file.",0,0,0,0
3956,"The double can be a valid number, a NaN or infinity.",0,1,0,1
3957,It is possible to load back the value with RedisModule_LoadDouble().,1,1,0,1
3958, Save opcode.,0,0,0,0
3959, Save value.,0,1,0,1
3960," In the context of the rdb_save method of a module data type, loads back the  double value saved by RedisModule_SaveDouble().",0,0,0,0
3961, Never reached.,0,1,0,1
3962," In the context of the rdb_save method of a module data type, saves a float  value to the RDB file.",0,0,0,0
3963,"The float can be a valid number, a NaN or infinity.",0,1,0,1
3964,It is possible to load back the value with RedisModule_LoadFloat().,1,1,0,1
3965, Save opcode.,0,0,0,0
3966, Save value.,0,1,0,1
3967," In the context of the rdb_save method of a module data type, loads back the  float value saved by RedisModule_SaveFloat().",0,0,0,0
3968, Never reached.,0,1,0,1
3969, --------------------------------------------------------------------------  Key digest API (DEBUG DIGEST interface for modules types)  --------------------------------------------------------------------------,1,0,0,1
3970, Add a new element to the digest.,1,1,0,1
3971,"This function can be called multiple times  one element after the other, for all the elements that constitute a given  data structure.",1,0,0,1
3972,"The function call must be followed by the call to  `RedisModule_DigestEndSequence` eventually, when all the elements that are  always in a given order are added.",0,0,0,0
3973,See the Redis Modules data types  documentation for more info.,1,0,0,1
3974,However this is a quick example that uses Redis  data types as an example.,1,0,0,1
3975,"To add a sequence of unordered elements (for example in the case of a Redis  Set), the pattern to use is:       foreach element {          AddElement(element);          EndSequence();      }   Because Sets are not ordered, so every element added has a position that  does not depend from the other.",1,0,0,1
3976,"However if instead our elements are  ordered in pairs, like field-value pairs of an Hash, then one should  use:       foreach key,value {          AddElement(key);          AddElement(value);          EndSquence();      }   Because the key and value will be always in the above order, while instead  the single key-value pairs, can appear in any position into a Redis hash.",1,0,0,1
3977,A list of ordered elements would be implemented with:       foreach element {          AddElement(element);      }      EndSequence();,0,0,0,0
3978, Like `RedisModule_DigestAddStringBuffer()` but takes a long long as input  that gets converted into a string before adding it to the digest.,1,0,0,1
3979, See the doucmnetation for `RedisModule_DigestAddElement()`.,0,0,0,0
3980, --------------------------------------------------------------------------  AOF API for modules data types  --------------------------------------------------------------------------,0,0,0,0
3981, Emits a command into the AOF during the AOF rewriting process.,0,1,0,1
3982,This function  is only called in the context of the aof_rewrite method of data types exported  by a module.,1,0,0,1
3983,"The command works exactly like RedisModule_Call() in the way  the parameters are passed, but it does not return anything as the error  handling is performed by Redis itself.",1,0,0,1
3984, Emit the arguments into the AOF in Redis protocol format.,0,0,0,0
3985, Bulk count.,0,1,0,1
3986, Arguments.,0,1,0,1
3987, --------------------------------------------------------------------------  IO context handling  --------------------------------------------------------------------------,0,0,0,0
3988, Can't have more than one...,1,1,0,1
3989, --------------------------------------------------------------------------  Logging  --------------------------------------------------------------------------,0,0,0,0
3990, This is the low level function implementing both:        RM_Log()       RM_LogIOError(),1,0,0,1
3991, Default.,0,1,0,1
3992," Produces a log message to the standard Redis log, the format accepts  printf-alike specifiers, while level is a string describing the log  level to use when emitting the log, and must be one of the following:    ""debug""   ""verbose""   ""notice""   ""warning""   If the specified log level is invalid, verbose is used by default.",1,0,0,1
3993,"There is a fixed limit to the length of the log line this function is able  to emit, this limti is not specified but is guaranteed to be more than  a few lines of text.",1,0,0,1
3994, Can only log if module is initialized,1,1,0,1
3995, Log errors from RDB  or  AOF serialization callbacks.,0,0,0,0
3996,This function should be used when a callback is returning a critical  error to the caller since cannot load or save the data for some  critical reason.,1,0,0,1
3997, --------------------------------------------------------------------------  Blocking clients from modules  --------------------------------------------------------------------------,0,0,0,0
3998, Readable handler for the awake pipe.,0,1,0,1
3999,"We do nothing here, the awake bytes  will be actually read in a more appropriate place in the  moduleHandleBlockedClients() function that is where clients are actually  served.",1,0,0,1
4000," This is called from blocked.c in order to unblock a client: may be called  for multiple reasons while the client is in the middle of being blocked  because the client is terminated, but is also called for cleanup when a  client is unblocked in a clean way after replaying.",1,0,0,1
4001,What we do here is just to set the client to NULL in the redis module  blocked client handle.,0,0,0,0
4002,"This way if the client is terminated while there  is a pending threaded operation involving the blocked client, we'll know  that the client no longer exists and no reply callback should be called.",0,0,0,0
4003,The structure RedisModuleBlockedClient will be always deallocated when  running the list of clients blocked by a module that need to be unblocked.,0,0,0,0
4004," Reset the client for a new query since, for blocking commands implemented      into modules, we do not it immediately after the command returns (and      the client blocks) in order to be still able to access the argument      vector from callbacks.",1,0,0,1
4005," Block a client in the context of a blocking command, returning an handle  which will be used, later, in order to unblock the client with a call to  RedisModule_UnblockClient().",0,0,0,0
4006,The arguments specify callback functions  and a timeout after which the client is unblocked.,0,0,0,0
4007,The callbacks are called in the following contexts:       reply_callback:  called after a successful RedisModule_UnblockClient()                       call in order to reply to the client and unblock it.,1,0,0,1
4008,reply_timeout:   called when the timeout is reached in order to send an                       error to the client.,0,0,0,0
4009,free_privdata:   called in order to free the privata data that is passed                       by RedisModule_UnblockClient() call.,1,0,0,1
4010, We need to handle the invalid operation of calling modules blocking      commands from Lua or MULTI.,0,0,0,0
4011,"We actually create an already aborted      (client set to NULL) blocked client handle, and actually reply with      an error.",1,0,0,1
4012, Unblock a client blocked by `RedisModule_BlockedClient`.,0,1,0,1
4013,This will trigger  the reply callbacks to be called in order to reply to the client.,0,0,0,0
4014,"The 'privdata' argument will be accessible by the reply callback, so  the caller of this function can pass any value that is needed in order to  actually reply to the client.",1,0,0,1
4015,"A common usage for 'privdata' is a thread that computes something that  needs to be passed to the client, included but not limited some slow  to compute reply or some reply obtained via networking.",1,0,0,1
4016,Note: this function can be called from threads spawned by the module.,0,1,0,1
4017," Ignore the error, this is best-effort.",0,1,0,1
4018, Abort a blocked client blocking operation: the client will be unblocked  without firing the reply callback.,0,0,0,0
4019, This function will check the moduleUnblockedClients queue in order to  call the reply callback and really unblock the client.,1,0,0,1
4020,"Clients end into this list because of calls to RM_UnblockClient(),  however it is possible that while the module was doing work for the  blocked client, it was terminated by Redis (for timeout or other reasons).",1,0,0,1
4021,When this happens the RedisModuleBlockedClient structure in the queue  will have the 'client' field set to NULL.,0,0,0,0
4022," Here we unblock all the pending clients blocked in modules operations      so we can read every pending ""awake byte"" in the pipe.",0,0,0,0
4023," Release the lock during the loop, as long as we don't          touch the shared list.",1,0,0,1
4024, Call the reply callback if the client is valid and we have          any callback.,0,0,0,0
4025, Free privdata if any.,1,0,0,1
4026, It is possible that this blocked client object accumulated          replies to send to the client in a thread safe context.,1,0,0,1
4027,We need to glue such replies to the client output buffer and          free the temporary client we just used for the replies.,1,0,0,1
4028, Put the client in the list of clients that need to write              if there are pending replies here.,0,0,0,0
4029,This is needed since              during a non blocking command the client may receive output.,0,0,0,0
4030," Free 'bc' only after unblocking the client, since it is          referenced in the client blocking context, and must be valid          when calling unblockClient().",1,0,0,1
4031, Lock again before to iterate the loop.,0,1,0,1
4032, Called when our client timed out.,0,1,0,1
4033,"After this function unblockClient()  is called, and it will invalidate the blocked client.",0,0,0,0
4034,So this function  does not need to do any cleanup.,0,0,0,0
4035,Eventually the module will call the  API to unblock the client and the memory will be released.,0,0,0,0
4036, Return non-zero if a module command was called in order to fill the  reply for a blocked client.,0,0,0,0
4037, Return non-zero if a module command was called in order to fill the  reply for a blocked client that timed out.,0,0,0,0
4038, Get the privata data set by RedisModule_UnblockClient(),0,0,0,0
4039," Return true if when the free callback of a blocked client is called,  the reason for the client to be unblocked is that it disconnected  while it was blocked.",1,0,0,1
4040, --------------------------------------------------------------------------  Thread Safe Contexts  --------------------------------------------------------------------------,1,0,0,1
4041, Return a context which can be used inside threads to make Redis context  calls with certain modules APIs.,1,0,0,1
4042,"If 'bc' is not NULL then the module will  be bound to a blocked client, and it will be possible to use the  `RedisModule_Reply` family of functions to accumulate a reply for when the  client will be unblocked.",1,0,0,1
4043,Otherwise the thread safe context will be  detached by a specific client.,1,0,0,1
4044,"To call non-reply APIs, the thread safe context must be prepared with:       RedisModule_ThreadSafeCallStart(ctx);      ... make your call here ...      RedisModule_ThreadSafeCallStop(ctx);   This is not needed when using `RedisModule_Reply` functions, assuming  that a blocked client was used when the context was created, otherwise  no RedisModule_Reply call should be made at all.",1,0,0,1
4045,TODO: thread safe contexts do not inherit the blocked client  selected database.,1,0,0,1
4046," Even when the context is associated with a blocked client, we can't      access it safely from another thread, so we create a fake client here      in order to keep things like the currently selected database and similar      things.",1,0,0,1
4047, Release a thread safe context.,1,1,0,1
4048, Acquire the server lock before executing a thread safe API call.,1,1,0,1
4049,This is not needed for `RedisModule_Reply` calls when there is  a blocked client connected to the thread safe context.,1,0,0,1
4050, Release the server lock after a thread safe API call was executed.,1,1,0,1
4051, --------------------------------------------------------------------------  Module Keyspace Notifications API  --------------------------------------------------------------------------,0,0,0,0
4052, Subscribe to keyspace notifications.,0,0,0,0
4053,This is a low-level version of the  keyspace-notifications API.,0,0,0,0
4054,A module cand register callbacks to be notified  when keyspce events occur.,0,0,0,0
4055,"Notification events are filtered by their type (string events, set events,  etc), and the subsriber callback receives only events that match a specific  mask of event types.",1,0,0,1
4056,"When subscribing to notifications with RedisModule_SubscribeToKeyspaceEvents   the module must provide an event type-mask, denoting the events the subscriber  is interested in.",1,0,0,1
4057,"This can be an ORed mask of any of the following flags:    - REDISMODULE_NOTIFY_GENERIC: Generic commands like DEL, EXPIRE, RENAME   - REDISMODULE_NOTIFY_STRING: String events   - REDISMODULE_NOTIFY_LIST: List events   - REDISMODULE_NOTIFY_SET: Set events   - REDISMODULE_NOTIFY_HASH: Hash events   - REDISMODULE_NOTIFY_ZSET: Sorted Set events   - REDISMODULE_NOTIFY_EXPIRED: Expiration events   - REDISMODULE_NOTIFY_EVICTED: Eviction events   - REDISMODULE_NOTIFY_STREAM: Stream events   - REDISMODULE_NOTIFY_ALL: All events   We do not distinguish between key events and keyspace events, and it is up  to the module to filter the actions taken based on the key.",1,0,0,1
4058,"The subscriber signature is:     int (RedisModuleNotificationFunc) (RedisModuleCtx ctx, int type,                                        const char event,                                        RedisModuleString key);   `type` is the event type bit, that must match the mask given at registration  time.",1,0,0,1
4059,"The event string is the actual command being executed, and key is the  relevant Redis key.",1,0,0,1
4060,"Notification callback gets executed with a redis context that can not be  used to send anything to the client, and has the db number where the event  occured as its selected db number.",0,0,0,0
4061,Notice that it is not necessary to enable norifications in redis.conf for  module notifications to work.,1,0,0,1
4062,"Warning: the notification callbacks are performed in a synchronous manner,  so notification callbacks must to be fast, or they would slow Redis down.",1,0,0,1
4063,"If you need to take long actions, use threads to offload them.",1,1,0,1
4064,See https: or  or redis.io or topics or notifications for more information.,1,0,0,1
4065, Dispatcher for keyspace notifications to module subscriber functions.,0,0,0,0
4066,This gets called  only if at least one module requested to be notified on  keyspace notifications,1,0,0,1
4067, Don't do anything if there aren't any subscribers,0,1,0,1
4068, Remove irrelevant flags from the type mask,1,1,0,1
4069," Only notify subscribers on events matching they registration,          and avoid subscribers triggering themselves",1,0,0,1
4070, mark the handler as activer to avoid reentrant loops.,0,0,0,0
4071,"If the subscriber performs an action triggering itself,              it will not be notified about it.",1,0,0,1
4072, Unsubscribe any notification subscirbers this module has upon unloading,0,0,0,0
4073, --------------------------------------------------------------------------  Modules Cluster API  --------------------------------------------------------------------------,0,0,0,0
4074, The Cluster message callback function pointer type.,0,1,0,1
4075," This structure identifies a registered caller: it must match a given module  ID, for a given message type.",0,0,0,0
4076,The callback function is just the function  that was registered as receiver.,0,0,0,0
4077, Only if flags & REDISMODULE_NODE_MASTER is true.,1,1,0,1
4078, We have an array of message types: each bucket is a linked list of  configured receivers.,0,0,0,0
4079, Dispatch the message to the right module receiver.,1,1,0,1
4080, Register a callback receiver for cluster messages of type 'type'.,0,1,0,1
4081,"If there  was already a registered callback, this will replace the callback function  with the one provided, otherwise if the callback is set to NULL and there  is already a callback for this function, the callback is unregistered  (so this API call is also used in order to delete the receiver).",0,0,0,0
4082, Found!,0,1,0,1
4083,Set or delete.,0,1,0,1
4084, Delete the receiver entry if the user is setting                  it to NULL.,0,0,0,0
4085,Just unlink the receiver node from the                  linked list.,0,0,0,0
4086," Not found, let's add it.",0,1,0,1
4087," Send a message to all the nodes in the cluster if `target` is NULL, otherwise  at the specified target, which is a REDISMODULE_NODE_ID_LEN bytes node ID, as  returned by the receiver callback or by the nodes iteration functions.",0,0,0,0
4088,"The function returns REDISMODULE_OK if the message was successfully sent,  otherwise if the node is not connected or such node ID does not map to any  known cluster node, REDISMODULE_ERR is returned.",1,0,0,1
4089," Return an array of string pointers, each string pointer points to a cluster  node ID of exactly REDISMODULE_NODE_ID_SIZE bytes (without any null term).",1,0,0,1
4090,The number of returned node IDs is stored into `numnodes`.,0,0,0,0
4091,"However if this function is called by a module not running an a Redis  instance with Redis Cluster enabled, NULL is returned instead.",0,0,0,0
4092,The IDs returned can be used with RedisModule_GetClusterNodeInfo() in order  to get more information about single nodes.,1,0,0,1
4093,The array returned by this function must be freed using the function  RedisModule_FreeClusterNodesList().,0,0,0,0
4094,"Example:       size_t count, j;      char ids = RedisModule_GetClusterNodesList(ctx,&count);      for (j = 0; j < count; j++) {          RedisModule_Log(""notice"",""Node %.s"",              REDISMODULE_NODE_ID_LEN,ids[j]);      }      RedisModule_FreeClusterNodesList(ids);",0,0,0,0
4095, Null term so that FreeClusterNodesList does not need                     to also get the count argument.,0,0,0,0
4096, Free the node list obtained with RedisModule_GetClusterNodesList.,1,1,0,1
4097, Return this node ID (REDISMODULE_CLUSTER_ID_LEN bytes) or NULL if the cluster  is disabled.,1,0,0,1
4098," Return the number of nodes in the cluster, regardless of their state  (handshake, noaddress, ...) so that the number of active nodes may actually  be smaller, but not greater than this number.",1,0,0,1
4099,"If the instance is not in  cluster mode, zero is returned.",0,0,0,0
4100," Populate the specified info for the node having as ID the specified 'id',  then returns REDISMODULE_OK.",0,0,0,0
4101,"Otherwise if the node ID does not exist from  the POV of this local node, REDISMODULE_ERR is returned.",0,0,0,0
4102,"The arguments ip, master_id, port and flags can be NULL in case we don't  need to populate back certain info.",1,0,0,1
4103,"If an ip and master_id (only populated  if the instance is a slave) are specified, they point to buffers holding  at least REDISMODULE_NODE_ID_LEN bytes.",1,0,0,1
4104,The strings written back as ip  and master_id are not null terminated.,0,0,0,0
4105,The list of flags reported is the following:    REDISMODULE_NODE_MYSELF        This node   REDISMODULE_NODE_MASTER        The node is a master   REDISMODULE_NODE_SLAVE         The ndoe is a slave   REDISMODULE_NODE_PFAIL         We see the node as failing   REDISMODULE_NODE_FAIL          The cluster agrees the node is failing   REDISMODULE_NODE_NOFAILOVER    The slave is configured to never failover,1,0,0,1
4106, We need access to internals,0,1,0,1
4107," If the information is not available, the function will set the          field to zero bytes, so that when the field can't be populated the          function kinda remains predictable.",1,0,0,1
4108," As usually we have to remap flags for modules, in order to ensure      we can provide binary compatibility.",1,0,0,1
4109," --------------------------------------------------------------------------  Modules Timers API   Module timers are an high precision ""green timers"" abstraction where  every module can register even millions of timers without problems, even if  the actual event loop will just have a single timer that is used to awake the  module timers subsystem in order to process the next event.",1,0,0,1
4110,"All the timers are stored into a radix tree, ordered by expire time, when  the main Redis event loop timer callback is called, we try to process all  the timers already expired one after the other.",1,0,0,1
4111,Then we re-enter the event  loop registering a timer that will expire when the next to process module  timer will expire.,0,0,0,0
4112,"Every time the list of active timers drops to zero, we unregister the  main event loop timer, so that there is no overhead when such feature is  not used.",1,0,0,1
4113, The radix tree of all the timers sorted by expire.,0,0,0,0
4114, Main event loop (ae.c) timer identifier.,1,0,0,1
4115," The timer descriptor, stored as value in the radix tree.",0,0,0,0
4116, Module reference.,0,1,0,1
4117, The callback to invoke on expire.,0,1,0,1
4118, Private data for the callback.,1,1,0,1
4119, This is the timer handler that is called by the main event loop.,1,1,0,1
4120,We schedule  this timer to be called when the nearest of our module timers will expire.,0,0,0,0
4121, To start let's try to fire all the timers already expired.,0,1,0,1
4122, Scale to milliseconds.,0,1,0,1
4123, Reschedule the next timer or cancel it.,0,1,0,1
4124," Create a new timer that will fire after `period` milliseconds, and will call  the specified function using `data` as argument.",1,0,0,1
4125,The returned timer ID can be  used to get information from the timer or to stop it before it fires.,0,0,0,0
4126," We need to install the main event loop timer if it's not already      installed, or we may need to refresh its period if we just installed      a timer that will expire sooner than any other else.",1,0,0,1
4127," This is the first key, we need to re-install the timer according              to the just added event.",1,0,0,1
4128," If we have no main timer (the old one was invalidated, or this is the      first module timer we have), install one.",1,0,0,1
4129," Stop a timer, returns REDISMODULE_OK if the timer was found, belonged to the  calling module, and was stoped, otherwise REDISMODULE_ERR is returned.",0,0,0,0
4130,"If not NULL, the data pointer is set to the value of the data argument when  the timer was created.",0,0,0,0
4131," Obtain information about a timer: its remaining time before firing  (in milliseconds), and the private data pointer associated with the timer.",1,0,0,1
4132,"If the timer specified does not exist or belongs to a different module  no information is returned and the function returns REDISMODULE_ERR, otherwise  REDISMODULE_OK is returned.",1,0,0,1
4133,The argumnets remaining or data can be NULL if  the caller does not need certain information.,1,0,0,1
4134, Scale to milliseconds.,0,1,0,1
4135, --------------------------------------------------------------------------  Modules utility APIs  --------------------------------------------------------------------------,0,0,0,0
4136, Return random bytes using SHA1 in counter mode with a  or dev or urandom  initialized seed.,1,0,0,1
4137,This function is fast so can be used to generate  many bytes without any effect on the operating system entropy pool.,1,0,0,1
4138,Currently this function is not thread safe.,1,1,0,1
4139, Like RedisModule_GetRandomBytes() but instead of setting the string to  random bytes the string is set to random characters in the in the  hex charset [0-9a-f].,1,0,0,1
4140, --------------------------------------------------------------------------  Modules API internals  --------------------------------------------------------------------------,0,0,0,0
4141, server.moduleapi dictionary type.,0,0,0,0
4142,Only uses plain C strings since  this gets queries from modules.,1,0,0,1
4143, hash function,0,0,0,0
4144, key dup,1,0,0,1
4145, val dup,0,0,0,0
4146, key compare,1,0,0,1
4147, key destructor,1,0,0,1
4148, val destructor,0,0,0,0
4149, Global initialization at Redis startup.,0,0,0,0
4150, Set up the keyspace notification susbscriber list and static client,1,0,0,1
4151, Make the pipe non blocking.,0,1,0,1
4152,This is just a best effort aware mechanism      and we do not want to block not in the read nor in the write half.,1,0,0,1
4153, Create the timers radix tree.,0,0,0,0
4154, Our thread-safe contexts GIL must start with already locked:      it is just unlocked when it's safe.,1,0,0,1
4155," Load all the modules in the server.loadmodule_queue list, which is  populated by `loadmodule` directives in the configuration file.",0,0,0,0
4156,We can't load modules directly when processing the configuration file  because the server must be fully initialized before loading modules.,1,0,0,1
4157,"The function aborts the server on errors, since to start with missing  modules is not considered sane: clients may rely on the existance of  given commands, loading AOF also may need some modules to exist, and  if this instance is a slave, it must understand commands from master.",1,0,0,1
4158, Unregister all the commands registered by this module.,0,0,0,0
4159, Load a module and initialize it.,0,1,0,1
4160,"On success C_OK is returned, otherwise  C_ERR is returned.",1,0,0,1
4161, Redis module loaded!,0,0,0,0
4162,Register it.,0,1,0,1
4163, Unload the module registered with the specified name.,0,1,0,1
4164,"On success  C_OK is returned, otherwise C_ERR is returned and errno is set  to the following values depending on the type of error:    ENONET: No such module having the specified name.",1,0,0,1
4165,EBUSY: The module exports a new data type and can only be reloaded.,1,1,0,1
4166, Remvoe any noification subscribers this module might have,0,0,0,0
4167, Unregister all the hooks.,0,0,0,0
4168,TODO: Yet no hooks support here.,0,1,0,1
4169, Unload the dynamic library.,1,1,0,1
4170, Remove from list of modules.,0,1,0,1
4171, The name was already freed by dictDelete().,0,0,0,0
4172, Redis MODULE command.,0,0,0,0
4173,MODULE LOAD <path> [args...],0,0,0,0
4174, Return the number of registered modules.,0,1,0,1
4175, Register all the APIs we export.,0,0,0,0
4176,Keep this function at the end of the  file so that's easy to seek it to add new entries.,1,0,0,1
4177, Reply callback for blocking command HELLO.BLOCK,0,1,0,1
4178, Timeout callback for blocking command HELLO.BLOCK,0,1,0,1
4179, Private data freeing callback for HELLO.BLOCK command.,1,1,0,1
4180, The thread entry point that actually executes the blocking part  of the command HELLO.BLOCK.,1,0,0,1
4181," HELLO.BLOCK <delay> <timeout> -- Block for <count> seconds, then reply with  a random number.",1,0,0,1
4182,"Timeout is the command timeout, so that you can test  what happens when the delay is greater than the timeout.",1,0,0,1
4183," Now that we setup a blocking client, we need to pass the control      to the thread.",0,0,0,0
4184,However we need to pass arguments to the thread:      the delay and a reference to the blocked client handle.,0,0,0,0
4185, The thread entry point that actually executes the blocking part  of the command HELLO.KEYS.,1,0,0,1
4186,"Note: this implementation is very simple on purpose, so no duplicated  keys (returned by SCAN) are filtered.",1,0,0,1
4187,However adding such a functionality  would be trivial just using any data structure implementing a dictionary  in order to filter the duplicated items.,1,0,0,1
4188, HELLO.KEYS -- Return all the keys in the current database without blocking  the server.,1,0,0,1
4189,The keys do not represent a point-in-time state so only the keys  that were in the database from the start to the end are guaranteed to be  there.,1,0,0,1
4190," Note that when blocking the client we do not set any callback: no      timeout is possible since we passed '0', nor we need a reply callback      because we'll use the thread safe context to accumulate a reply.",1,0,0,1
4191," Now that we setup a blocking client, we need to pass the control      to the thread.",0,0,0,0
4192,However we need to pass arguments to the thread:      the reference to the blocked client handle.,0,0,0,0
4193, This function must be present on each Redis module.,0,0,0,0
4194,It is used in order to  register the commands into the Redis server.,0,0,0,0
4195, HELLOCLUSTER.PINGALL,0,1,0,1
4196, HELLOCLUSTER.LIST,0,1,0,1
4197, Callback for message MSGTYPE_PING,0,1,0,1
4198, Callback for message MSGTYPE_PONG.,0,1,0,1
4199, This function must be present on each Redis module.,0,0,0,0
4200,It is used in order to  register the commands into the Redis server.,0,0,0,0
4201, Timer callback.,0,1,0,1
4202, HELLOTIMER.TIMER,0,1,0,1
4203, This function must be present on each Redis module.,0,0,0,0
4204,It is used in order to  register the commands into the Redis server.,0,0,0,0
4205," ========================== Internal data structure  =======================  This is just a linked list of 64 bit integers where elements are inserted  in-place, so it's ordered.",0,0,0,0
4206,There is no pop or push operation but just insert  because it is enough to show the implementation of new data types without  making things complex.,1,0,0,1
4207, Number of elements added.,0,1,0,1
4208," ========================= ""hellotype"" type commands =======================",0,0,0,0
4209, HELLOTYPE.INSERT key value,1,1,0,1
4210, Use automatic memory management.,0,1,0,1
4211, Create an empty value object if the key is currently empty.,1,1,0,1
4212, Insert the new element.,1,1,0,1
4213, HELLOTYPE.RANGE key first count,1,1,0,1
4214, Use automatic memory management.,0,1,0,1
4215, HELLOTYPE.LEN key,1,1,0,1
4216, Use automatic memory management.,0,1,0,1
4217," ========================== ""hellotype"" type methods =======================",0,0,0,0
4218," RedisModule_Log(""warning"",""Can't load data with version %d"", encver);",0,0,0,0
4219, The goal of this function is to return the amount of memory used by  the HelloType value.,0,0,0,0
4220, This function must be present on each Redis module.,0,0,0,0
4221,It is used in order to  register the commands into the Redis server.,0,0,0,0
4222, HELLO.SIMPLE is among the simplest commands you can implement.,0,1,0,1
4223,"It just returns the currently selected DB id, a functionality which is  missing in Redis.",1,0,0,1
4224,"The command uses two important API calls: one to  fetch the currently selected DB, the other in order to send the client  an integer reply as response.",1,0,0,1
4225," HELLO.PUSH.NATIVE re-implements RPUSH, and shows the low level modules API  where you can ""open"" keys, make low level operations, create new keys by  pushing elements into non-existing keys, and so forth.",1,0,0,1
4226,You'll find this command to be roughly as fast as the actual RPUSH  command.,1,0,0,1
4227," HELLO.PUSH.CALL implements RPUSH using an higher level approach, calling  a Redis command instead of working with the key in a low level way.",1,0,0,1
4228,"This  approach is useful when you need to call Redis commands that are not  available as low level APIs, or when you don't need the maximum speed  possible but instead prefer implementation simplicity.",1,0,0,1
4229," HELLO.PUSH.CALL2  This is exaxctly as HELLO.PUSH.CALL, but shows how we can reply to the  client using directly a reply object that Call() returned.",1,0,0,1
4230," HELLO.LIST.SUM.LEN returns the total length of all the items inside  a Redis list, by using the high level Call() API.",1,0,0,1
4231,This command is an example of the array reply access.,0,1,0,1
4232, HELLO.LIST.SPLICE srclist dstlist count  Moves 'count' elements from the tail of 'srclist' to the head of  'dstlist'.,0,0,0,0
4233,"If less than count elements are available, it moves as much  elements as possible.",1,0,0,1
4234, Src and dst key must be empty or lists.,1,0,0,1
4235," Like the HELLO.LIST.SPLICE above, but uses automatic memory management  in order to avoid freeing stuff.",1,0,0,1
4236, Src and dst key must be empty or lists.,1,0,0,1
4237, HELLO.RAND.ARRAY <count>  Shows how to generate arrays as commands replies.,0,0,0,0
4238,It just outputs <count> random numbers.,1,1,0,1
4239," To reply with an array, we call RedisModule_ReplyWithArray() followed      by other ""count"" calls to other reply functions in order to generate      the elements of the array.",1,0,0,1
4240, This is a simple command to test replication.,1,1,0,1
4241,"Because of the ""!""",0,0,0,0
4242,"modified  in the RedisModule_Call() call, the two INCRs get replicated.",0,0,0,0
4243,Also note how the ECHO is replicated in an unexpected position (check  comments the function implementation).,1,0,0,1
4244," This will be replicated after the two INCR statements, since      the Call() replication has precedence, so the actual replication      stream will be:           MULTI      INCR foo      INCR bar      ECHO c foo      EXEC",1,0,0,1
4245," Using the ""!""",0,0,0,0
4246,modifier we replicate the command if it      modified the dataset in some way.,0,0,0,0
4247, Another command to show replication.,0,1,0,1
4248,"In this case, we call  RedisModule_ReplicateVerbatim() to mean we want just the command to be  propagated to slaves  or  AOF exactly as it was called by the user.",1,0,0,1
4249,This command also shows how to work with string objects.,0,1,0,1
4250,"It takes a list, and increments all the elements (that must have  a numerical value) by 1, returning the sum of all the elements  as reply.",0,0,0,0
4251,Usage: HELLO.REPL2 <list-key>,0,1,0,1
4252, Use automatic memory management.,0,1,0,1
4253, Rotate and increment.,0,1,0,1
4254, This is an example of strings DMA access.,0,1,0,1
4255,Given a key containing a string  it toggles the case of each character from lower to upper case or the  other way around.,1,0,0,1
4256,No automatic memory management is used in this example (for the sake  of variety).,0,0,0,0
4257,HELLO.TOGGLE.CASE key,1,1,0,1
4258, HELLO.MORE.EXPIRE key milliseconds.,1,1,0,1
4259,"If they key has already an associated TTL, extends it by ""milliseconds""  milliseconds.",1,0,0,1
4260,Otherwise no operation is performed.,0,0,0,0
4261, Use automatic memory management.,0,1,0,1
4262, HELLO.ZSUMRANGE key startscore endscore  Return the sum of all the scores elements between startscore and endscore.,1,0,0,1
4263,"The computation is performed two times, one time from start to end and  another time backward.",0,0,0,0
4264,"The two scores, returned as a two element array,  should match.",0,0,0,0
4265, HELLO.LEXRANGE key min_lex max_lex min_age max_age  This command expects a sorted set stored at key in the following form:  - All the elements have score 0.,1,0,0,1
4266,"- Elements are pairs of ""<name>:<age>"", for example ""Anna:52"".",0,0,0,0
4267,The command will return all the sorted set items that are lexicographically  between the specified range (using the same format as ZRANGEBYLEX)  and having an age between min_age and max_age.,1,0,0,1
4268, Use automatic memory management.,0,1,0,1
4269, HELLO.HCOPY key srcfield dstfield  This is just an example command that sets the hash field dstfield to the  same value of srcfield.,1,0,0,1
4270,If srcfield does not exist no operation is  performed.,0,0,0,0
4271,The command returns 1 if the copy is performed (srcfield exists) otherwise  0 is returned.,0,0,0,0
4272, Use automatic memory management.,0,1,0,1
4273, Get the old field value.,1,1,0,1
4274," HELLO.LEFTPAD str len ch  This is an implementation of the infamous LEFTPAD function, that  was at the center of an issue with the npm modules system in March 2016.",1,0,0,1
4275,"LEFTPAD is a good example of using a Redis Modules API called  ""pool allocator"", that was a famous way to allocate memory in yet another  open source project, the Apache web server.",1,0,0,1
4276,"The concept is very simple: there is memory that is useful to allocate  only in the context of serving a request, and must be freed anyway when  the callback implementing the command returns.",1,0,0,1
4277,"So in that case the module  does not need to retain a reference to these allocations, it is just  required to free the memory before returning.",1,0,0,1
4278,"When this is the case the  module can call RedisModule_PoolAlloc() instead, that works like malloc()  but will automatically free the memory when the module callback returns.",1,0,0,1
4279,Note that PoolAlloc() does not necessarily require AutoMemory to be  active.,1,0,0,1
4280, Use automatic memory management.,0,1,0,1
4281," If the string is already larger than the target len, just return      the string itself.",1,0,0,1
4282, Padding must be a single character in this simple implementation.,1,1,0,1
4283," Here we use our pool allocator, for our throw-away allocation.",0,0,0,0
4284, This function must be present on each Redis module.,0,0,0,0
4285,It is used in order to  register the commands into the Redis server.,0,0,0,0
4286, Log the list of parameters passing loading the module.,0,1,0,1
4287, --------------------------------- Helpers --------------------------------,0,1,0,1
4288, Return true if the reply and the C null term string matches.,1,1,0,1
4289, ------------------------------- Test units -------------------------------,0,1,0,1
4290, TEST.CALL -- Test Call() API.,0,1,0,1
4291, TEST.STRING.APPEND -- Test appending to an existing string object.,0,1,0,1
4292, TEST.STRING.APPEND.AM -- Test append with retain when auto memory is on.,0,0,0,0
4293, TEST.STRING.PRINTF -- Test string formatting.,0,1,0,1
4294, Increment a counter on the notifications: for each key notified we    increment a counter,1,0,0,1
4295, TEST.NOTIFICATIONS -- Test Keyspace Notifications.,0,0,0,0
4296, LPUSH should be ignored and not increment any counters,0,1,0,1
4297, For l we expect nothing since we didn't subscribe to list events,0,1,0,1
4298, TEST.CTXFLAGS -- Test GetContextFlags.,0,1,0,1
4299, Enable AOF to test AOF flags,0,1,0,1
4300, Enable RDB to test RDB flags,0,1,0,1
4301, Revert config changes,0,0,0,0
4302, ----------------------------- Test framework -----------------------------,0,1,0,1
4303," Return 1 if the reply matches the specified string, otherwise log errors  in the server log and return 0.",0,0,0,0
4304," Return 1 if the reply matches the specified integer, otherwise log errors  in the server log and return 0.",0,0,0,0
4305, TEST.IT -- Run all the tests.,0,1,0,1
4306, Make sure the DB is empty before to proceed.,1,1,0,1
4307, ================================ MULTI or EXEC ==============================,0,1,0,1
4308, Client state initialization for MULTI or EXEC,0,1,0,1
4309, Release all the resources associated with MULTI or EXEC state,0,1,0,1
4310, Add a new command into the MULTI commands queue,1,1,0,1
4311, Flag the transacation as DIRTY_EXEC so that EXEC will fail.,1,0,0,1
4312,Should be called every time there is an error while queueing a command.,0,0,0,0
4313, Send a MULTI command to all the slaves and AOF file.,0,1,0,1
4314,Check the execCommand  implementation for more information.,1,0,0,1
4315, Need to propagate MULTI or EXEC to AOF  or  slaves?,0,0,0,0
4316, Check if we need to abort the EXEC because:      1) Some WATCHed key was touched.,1,0,0,1
4317,2) There was a previous error while queueing commands.,1,0,0,1
4318,"A failed EXEC in the first case returns a multi bulk nil object      (technically it is not an error but a special behavior), while      in the second an EXECABORT error is returned.",1,0,0,1
4319, Exec all the queued commands,0,1,0,1
4320, Unwatch ASAP otherwise we'll waste CPU cycles,0,0,0,0
4321, Propagate a MULTI request once we encounter the first command which          is not readonly nor an administrative one.,1,0,0,1
4322,This way we'll deliver the MULTI or .... or EXEC block as a whole and          both the AOF and the replication link will have the same consistency          and atomicity guarantees.,1,0,0,1
4323," Commands may alter argc or argv, restore mstate.",0,0,0,0
4324, Make sure the EXEC command will be propagated as well if MULTI      was already propagated.,1,0,0,1
4325," If inside the MULTI or EXEC block this instance was suddenly          switched from master to slave (using the SLAVEOF command), the          initial MULTI was propagated into the replication backlog, but the          rest was not.",1,0,0,1
4326,We need to make sure to at least terminate the          backlog with the final EXEC.,1,0,0,1
4327, Send EXEC to clients waiting data from MONITOR.,0,1,0,1
4328,"We do it here      since the natural order of commands execution is actually:      MUTLI, EXEC, ... commands inside transaction ...",1,0,0,1
4329,"Instead EXEC is flagged as CMD_SKIP_MONITOR in the command      table, and we do it here with correct ordering.",0,0,0,0
4330," ===================== WATCH (CAS alike for MULTI or EXEC) ===================   The implementation uses a per-DB hash table mapping keys to list of clients  WATCHing those keys, so that given a key that is going to be modified  we can mark all the associated clients as dirty.",1,0,0,1
4331,Also every client contains a list of WATCHed keys so that's possible to  un-watch such keys when the client is freed or when UNWATCH is called.,1,0,0,1
4332, In the client->watched_keys list we need to use watchedKey structures  as in order to identify a key in Redis we need both the key name and the  DB,1,0,0,1
4333, Watch for the specified key,1,1,0,1
4334, Check if we are already watching for this key,1,1,0,1
4335, Key already watched,1,1,0,1
4336, This key is not already watched in this DB.,1,1,0,1
4337,Let's add it,0,1,0,1
4338, Add the new key to the list of keys watched by this client,1,1,0,1
4339, Unwatch all the keys watched by this client.,0,0,0,0
4340,To clean the EXEC dirty  flag is up to the caller.,1,0,0,1
4341, Lookup the watched key -> clients list and remove the client          from the list,1,0,0,1
4342, Kill the entry at all if this was the only client,1,1,0,1
4343, Remove this watched key from the client->watched list,1,1,0,1
4344," ""Touch"" a key, so that if this key is being WATCHed by some client the  next EXEC will fail.",1,0,0,1
4345, Mark all the clients watching this key as CLIENT_DIRTY_CAS,1,1,0,1
4346, Check if we are already watching for this key,1,1,0,1
4347, On FLUSHDB or FLUSHALL all the watched keys that are present before the  flush but will be deleted as effect of the flushing operation should  be touched.,0,0,0,0
4348,"""dbid"" is the DB that's getting the flush.",0,0,0,0
4349,-1 if it is  a FLUSHALL operation (all the DBs flushed).,0,0,0,0
4350," For every client, check all the waited keys",0,1,0,1
4351," For every watched key matching the specified DB, if the              key exists, mark the client as dirty, as the key will be              removed.",1,0,0,1
4352," Return the size consumed from the allocator, for the specified SDS string,  including internal fragmentation.",0,0,0,0
4353,This function is used in order to compute  the client output buffer size.,0,0,0,0
4354, Return the amount of memory used by the sds string at object->ptr  for a string object.,0,0,0,0
4355, Just integer encoding for now.,0,1,0,1
4356, Client.reply list dup and free methods.,1,0,0,1
4357, This function links the client to the global linked list of clients.,0,1,0,1
4358,"unlinkClient() does the opposite, among other things.",1,0,0,1
4359," Note that we remember the linked list node where the client is stored,      this way removing the client in unlinkClient() will not require      a linear scan, but just a constant time operation.",1,0,0,1
4360, passing -1 as fd it is possible to create a non connected client.,1,0,0,1
4361,This is useful since all the commands needs to be executed      in the context of a client.,1,0,0,1
4362,When commands are executed in other      contexts (for instance a Lua script) we need a non connected client.,1,0,0,1
4363, This function is called every time we are going to transmit new data  to the client.,1,0,0,1
4364,"The behavior is the following:   If the client should receive new data (normal clients will) the function  returns C_OK, and make sure to install the write handler in our event  loop so that when the socket is writable new data gets written.",1,0,0,1
4365,"If the client should not receive new data, because it is a fake client  (used to load AOF in memory), a master or because the setup of the write  handler failed, the function returns C_ERR.",1,0,0,1
4366,The function may return C_OK without actually installing the write  event handler in the following cases:   1) The event handler should already be installed since the output buffer     already contains something.,1,0,0,1
4367,"2) The client is a slave but not yet online, so we want to just accumulate     writes in the buffer but not actually sending them yet.",1,0,0,1
4368,"Typically gets called every time a reply is built, before adding more  data to the clients output buffers.",1,0,0,1
4369,If the function returns C_ERR no  data should be appended to the output buffers.,0,0,0,0
4370, If it's the Lua client we always return ok without installing any      handler since there is no socket at all.,1,0,0,1
4371, CLIENT REPLY OFF  or  SKIP handling: don't send replies.,0,0,0,0
4372," Masters don't receive replies, unless CLIENT_MASTER_FORCE_REPLY flag      is set.",0,0,0,0
4373, Fake client for AOF loading.,1,1,0,1
4374," Schedule the client to write the output buffers to the socket only      if not already done (there were no pending writes already and the client      was yet not flagged), and, for slaves, if the slave can actually      receive writes at this stage.",1,0,0,1
4375," Here instead of installing the write handler, we just flag the          client and put it into a list of clients that have something          to write to the socket.",0,0,0,0
4376,"This way before re-entering the event          loop, we can try to directly write to the client sockets avoiding          a system call.",1,0,0,1
4377,We'll only really install the write handler if          we'll not be able to write the whole reply at once.,1,0,0,1
4378, Authorize the caller to queue in the output buffer of this client.,0,1,0,1
4379, -----------------------------------------------------------------------------  Low level functions to add more data to output buffers.,1,0,0,1
4380," If there already are entries in the reply list, we cannot      add anything more to the static buffer.",1,0,0,1
4381, Check that the buffer has enough space available for this string.,1,1,0,1
4382, Append to this object when possible.,1,1,0,1
4383,If tail == NULL it was          set via addDeferredMultiBulkLength().,0,0,0,0
4384, -----------------------------------------------------------------------------  Higher level functions to queue data on the client output buffer.,1,0,0,1
4385,The following functions are the ones that commands implementations will call.,1,1,0,1
4386, Add the object 'obj' string representation to the client output buffer.,0,1,0,1
4387," For integer encoded strings we just convert it into a string          using our optimized function, and attach the resulting string          to the output buffer.",0,0,0,0
4388," Add the SDS 's' string to the client output buffer, as a side effect  the SDS string is freed.",0,0,0,0
4389, The caller expects the sds to be free'd.,1,0,0,1
4390," This low level function just adds whatever protocol you send it to the  client buffer, trying the static buffer initially, and using the string  of objects if not possible.",1,0,0,1
4391,It is efficient because does not create an SDS object nor an Redis object  if not needed.,0,0,0,0
4392,The object will only be created by calling  _addReplyStringToList() if we fail to extend the existing tail object  in the list of objects.,1,0,0,1
4393, Low level function called by the addReplyError...() functions.,1,0,0,1
4394,"It emits the protocol for a Redis error, in the form:   -ERRORCODE Error Message<CR><LF>   If the error code is already passed in the string 's', the error  code provided is used, otherwise the string ""-ERR "" for the generic  error code is automatically added.",0,0,0,0
4395," If the string already starts with ""-..."" then the error code      is provided by the caller.",0,0,0,0
4396,"Otherwise we use ""-ERR"".",0,0,0,0
4397," Make sure there are no newlines in the string, otherwise invalid protocol      is emitted.",1,0,0,1
4398," Adds an empty object to the reply list that will contain the multi bulk  length, which is not known when this function is called.",1,0,0,1
4399," Note that we install the write event here even if the object is not      ready to be sent, since we are sure that before returning to the      event loop setDeferredMultiBulkLength() will be called.",1,0,0,1
4400, NULL is our placeholder.,0,1,0,1
4401, Populate the length object and try gluing it to the next chunk.,0,1,0,1
4402, Abort when node is NULL: when the client should not accept writes      we return NULL in addDeferredMultiBulkLength(),0,0,0,0
4403, Only glue when the next node is non-NULL (an sds in this case),1,0,0,1
4404, No need to update c->reply_bytes: we are just moving the same              amount of bytes from one node to another.,1,0,0,1
4405, Add a double as a bulk reply,0,1,0,1
4406, Libc in odd systems (Hi Solaris!),1,0,0,1
4407,"will format infinite in a          different way, so better to handle it in an explicit way.",1,0,0,1
4408," Add a long double as a bulk reply, but uses a human readable formatting  of the double instead of exposing the crude behavior of doubles to the  dear user.",1,0,0,1
4409, Add a long long as integer reply or bulk len  or  multi bulk count.,1,0,0,1
4410,Basically this is used to output <prefix><long long><crlf>.,0,0,0,0
4411, Things like $3\r\n or 2\r\n are emitted very often by the protocol      so we have a few shared objects to use if the integer is small      like it is most of the times.,1,0,0,1
4412," Create the length prefix of a bulk reply, example: $2234",0,1,0,1
4413, Compute how many bytes will take this integer as a radix 10 string,1,0,0,1
4414, Add a Redis Object as a bulk reply,0,0,0,0
4415, Add a C buffer as bulk reply,0,1,0,1
4416, Add sds to reply (takes ownership of sds and frees it),0,0,0,0
4417, Add a C null term string as bulk reply,0,1,0,1
4418, Add a long long as a bulk reply,1,0,0,1
4419, Add an array of C strings as status replies with a heading.,0,1,0,1
4420,This function is typically invoked by from commands that support  subcommands in response to the 'help' subcommand.,1,0,0,1
4421,The help array  is terminated by NULL sentinel.,0,0,0,0
4422, Account for the header line(s).,0,1,0,1
4423, Copy 'src' client output buffers into 'dst' client output buffers.,0,0,0,0
4424,The function takes care of freeing the old output buffers of the  destination client.,1,0,0,1
4425, Return true if the specified client has pending reply buffers to write to  the socket.,1,0,0,1
4426," May be already closed, just ignore errors",1,1,0,1
4427, If maxclient directive is set and this is one client more... close the      connection.,1,0,0,1
4428,"Note that we create the client instead to check before      for this condition, since now the socket is already set in non-blocking      mode and we can send an error for free using the Kernel I or O",1,0,0,1
4429," That's a best effort error message, don't check write errors",1,0,0,1
4430," Nothing to do, Just to avoid the warning...",0,1,0,1
4431," If the server is running in protected mode (the default) and there      is no password set, nor a specific interface is bound, we don't accept      requests from non loopback interfaces.",1,0,0,1
4432,Instead we try to explain the      user what to do to fix it if needed.,0,0,0,0
4433," Nothing to do, Just to avoid the warning...",0,1,0,1
4434, Close all the slaves connections.,0,1,0,1
4435,This is useful in chained replication  when we resync with our own master and want to force all our slaves to  resync with us as well.,1,0,0,1
4436," Remove the specified client from global lists where the client could  be referenced, not including the Pub or Sub channels.",0,0,0,0
4437,This is used by freeClient() and replicationCacheMaster().,0,0,0,0
4438, If this is marked as current client unset it.,1,1,0,1
4439, Certain operations must be done only if the client has an active socket.,1,1,0,1
4440,"If the client was already unlinked or if it's a ""fake client"" the      fd is already set to -1.",1,0,0,1
4441, Remove from the list of active clients.,1,1,0,1
4442, Unregister async I or O handlers and close the socket.,0,0,0,0
4443, Remove from the list of pending writes if needed.,0,1,0,1
4444," When client was just unblocked because of a blocking operation,      remove it from the list of unblocked clients.",0,0,0,0
4445, If it is our master that's beging disconnected we should make sure      to cache the state to try a partial resynchronization later.,1,0,0,1
4446,"Note that before doing this we make sure that the client is not in      some unexpected state, by checking its flags.",1,0,0,1
4447, Log link disconnection with slave,0,1,0,1
4448, Free the query buffer,1,1,0,1
4449, Deallocate structures used to block on blocking ops.,0,0,0,0
4450, UNWATCH all the keys,0,1,0,1
4451, Unsubscribe from all the pubsub channels,0,0,0,0
4452, Free data structures.,1,1,0,1
4453," Unlink the client: this will close the socket, remove the I or O      handlers, and remove references of the client from different      places where active clients may be referenced.",1,0,0,1
4454, Master or slave cleanup Case 1:      we lost the connection with a slave.,0,0,0,0
4455," We need to remember the time when we started to have zero          attached slaves, as after some time we'll free the replication          backlog.",1,0,0,1
4456, Master or slave cleanup Case 2:      we lost the connection with the master.,0,0,0,0
4457, If this client was scheduled for async freeing we need to remove it      from the queue.,0,0,0,0
4458," Release other dynamically allocated client structure fields,      and finally release the client structure itself.",1,0,0,1
4459, Schedule a client to free it at a safe time in the serverCron() function.,1,0,0,1
4460,"This function is useful when we need to terminate a client but we are in  a context where calling freeClient() is not possible, because the client  should be valid for the continuation of the flow of the program.",1,0,0,1
4461, Write data in output buffers to client.,0,1,0,1
4462,"Return C_OK if the client  is still valid after the call, C_ERR if it was freed.",0,0,0,0
4463," If the buffer was sent, set bufpos to zero to continue with              the remainder of the reply.",0,0,0,0
4464, If we fully sent the object on head go to the next one,0,0,0,0
4465," If there are no longer objects in the list, we expect                  the count of reply bytes to be exactly zero.",1,0,0,1
4466," Note that we avoid to send more than NET_MAX_WRITES_PER_EVENT          bytes, in a single threaded server it's a good idea to serve          other clients as well, even if a very large request comes from          super fast link that is always able to accept data (in real world          scenario think about 'KEYS ' against the loopback interface).",1,0,0,1
4467,However if we are over the maxmemory limit we ignore that and          just deliver as much data as it is possible to deliver.,1,0,0,1
4468,"Moreover, we also send as much as possible if the client is          a slave (otherwise, on high-speed traffic, the replication          buffer will grow indefinitely)",1,0,0,1
4469," For clients representing masters we don't count sending data          as an interaction, since we always send REPLCONF ACK commands          that take some time to just fill the socket output buffer.",0,0,0,0
4470,We just rely on data  or  pings received for timeout detection.,0,0,0,0
4471, Close connection after entire reply has been sent.,1,1,0,1
4472, Write event handler.,0,1,0,1
4473,Just send data to the client.,0,1,0,1
4474," This function is called just before entering the event loop, in the hope  we can just write the replies to the client output buffer without any  need to use a syscall in order to install the writable event handler,  get it called, and so forth.",0,0,0,0
4475, Try to write buffers to the client socket.,0,1,0,1
4476," If after the synchronous writes above we still have data to          output to the client, we need to install the writable handler.",1,0,0,1
4477," For the fsync=always policy, we want that a given FD is never              served for reading and writing in the same event loop iteration,              so that in the middle of receiving the query, and serving it              to the client, we'll call beforeSleep() that will do the              actual fsync of AOF to disk.",1,0,0,1
4478,AE_BARRIER ensures that.,0,1,0,1
4479, resetClient prepare the client to process the next command,0,0,0,0
4480," We clear the ASKING flag as well if we are not inside a MULTI, and      if what we just executed is not the ASKING command itself.",1,0,0,1
4481," Remove the CLIENT_REPLY_SKIP flag if any so that the reply      to the next command will be sent, but set the flag if the command      we just processed was ""CLIENT REPLY SKIP"".",0,0,0,0
4482," Like processMultibulkBuffer(), but for the inline protocol instead of RESP,  this function consumes the client query buffer and creates a command ready  to be executed inside the client structure.",1,0,0,1
4483,"Returns C_OK if the command  is ready to be executed, or C_ERR if there is still protocol to read to  have a well formed command.",1,0,0,1
4484,The function also returns C_ERR when there is  a protocol error: in such a case the client structure is setup to reply  with the error and close the connection.,1,0,0,1
4485, Search for end of line,0,1,0,1
4486, Nothing to do without a \r\n,0,1,0,1
4487, Handle the \r\n case.,0,1,0,1
4488, Split the input buffer up to the \r\n,0,1,0,1
4489, Newline from slaves can be used to refresh the last ACK time.,1,1,0,1
4490,This is useful for a slave to ping back while loading a big      RDB file.,1,0,0,1
4491, Leave data after the first line of the query in the buffer,1,1,0,1
4492, Setup argv array on client structure,0,0,0,0
4493, Create redis objects for all arguments.,0,0,0,0
4494, Helper function.,0,1,0,1
4495,Trims query buffer to make the function that processes  multi bulk requests idempotent.,0,0,0,0
4496, Sample some protocol to given an idea about what was inside.,0,1,0,1
4497, Remove non printable chars.,0,1,0,1
4498, Log all the client and protocol info.,0,1,0,1
4499," Process the query buffer for client 'c', setting up the client argument  vector for command execution.",0,0,0,0
4500,"Returns C_OK if after running the function  the client has a well-formed ready to be processed command, otherwise  C_ERR if there is still to read more buffer to get the full command.",1,0,0,1
4501,The function also returns C_ERR when there is a protocol error: in such a  case the client structure is setup to reply with the error and close  the connection.,1,0,0,1
4502,"This function is called if processInputBuffer() detects that the next  command is in RESP format, so the first byte in the command is found  to be ''.",1,0,0,1
4503,Otherwise for inline commands processInlineBuffer() is called.,0,0,0,0
4504, The client should have been reset,0,1,0,1
4505, Multi bulk length cannot be read without a \r\n,0,0,0,0
4506, Buffer should also contain \n,0,1,0,1
4507," We know for sure there is a whole line since newline != NULL,          so go ahead and find out the multi bulk length.",1,0,0,1
4508, Setup argv array on client structure,0,0,0,0
4509, Read bulk length if unknown,1,1,0,1
4510, Buffer should also contain \n,0,1,0,1
4511, If we are going to read a large object from network                  try to make it likely that it will start at c->querybuf                  boundary so that we can optimize object creation                  avoiding a large copy of data.,1,0,0,1
4512, Hint the sds library about the amount of bytes this string is                  going to contain.,0,0,0,0
4513, Read bulk argument,0,1,0,1
4514, Not enough data (+2 == trailing \r\n),1,1,0,1
4515, Optimization: if the buffer contains JUST our bulk element              instead of creating a new object by copying the sds we              just use the current sds string.,1,0,0,1
4516, remove CRLF,0,0,0,0
4517, Assume that if we saw a fat argument we'll see another one                  likely...,1,0,0,1
4518, Trim to pos,0,0,0,0
4519, We're done when c->multibulk == 0,0,0,0,0
4520, Still not ready to process the command,1,0,0,1
4521," This function is called every time, in the client structure 'c', there is  more query buffer to process, because we read more data from the socket  or because a client was blocked and later reactivated, so there could be  pending query buffer, already representing a full command, to process.",1,0,0,1
4522, Keep processing while there is something in the input buffer,0,1,0,1
4523, Return if clients are paused.,0,1,0,1
4524, Immediately abort if the client is in the middle of something.,0,1,0,1
4525, CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is          written to the client.,0,0,0,0
4526,Make sure to not let the reply grow after          this flag has been set (i.e.,1,0,0,1
4527,don't process more commands).,1,0,0,1
4528,The same applies for clients we want to terminate ASAP.,1,1,0,1
4529, Determine request type when unknown.,1,1,0,1
4530, Multibulk processing could see a <= 0 length.,0,0,0,0
4531, Only reset the client when the command was executed.,1,1,0,1
4532, Update the applied replication offset of our master.,0,1,0,1
4533," Don't reset the client structure for clients blocked in a                  module blocking command, so that the reply callback will                  still be able to access the client argv and argc field.",1,0,0,1
4534,The client will be reset in unblockClientFromModule().,0,0,0,0
4535, freeMemoryIfNeeded may flush slave output buffers.,0,0,0,0
4536,"This may              result into a slave, that may be the active client, to be              freed.",1,0,0,1
4537," If this is a multi bulk request, and we are processing a bulk reply      that is large enough, try to maximize the probability that the query      buffer contains exactly the SDS string representing the object, even      at the risk of requiring more read(2) calls.",1,0,0,1
4538,This way the function      processMultiBulkBuffer() can avoid copying buffers to create the      Redis Object representing the argument.,0,0,0,0
4539, Append the query buffer to the pending (not applied) buffer          of the master.,0,0,0,0
4540,We'll use this buffer later in order to have a          copy of the string applied by the last command executed.,1,0,0,1
4541, Time to process the buffer.,0,1,0,1
4542,"If the client is a master we need to      compute the difference between the applied offset before and after      processing the buffer, to understand how much of the replication stream      was actually applied to the master state: this quantity, and its      corresponding part of the replication stream, will be propagated to      the sub-slaves and to the replication backlog.",1,0,0,1
4543," A Redis ""Peer ID"" is a colon separated ip:port pair.",0,0,0,0
4544,"For IPv4 it's in the form x.y.z.k:port, example: ""127.0.0.1:1234"".",0,0,0,0
4545,"For IPv6 addresses we use [] around the IP part, like in ""[::1]:1234"".",0,0,0,0
4546,"For Unix sockets we use path:0, like in "" or tmp or redis:0"".",0,0,0,0
4547,"A Peer ID always fits inside a buffer of NET_PEER_ID_LEN bytes, including  the null term.",0,0,0,0
4548,"On failure the function still populates 'peerid' with the ""?",1,0,0,1
4549,":0"" string  in case you want to relax error checking or need to display something  anyway (see anetPeerToString implementation for more info).",1,0,0,1
4550, Unix socket client.,0,1,0,1
4551, TCP client.,0,1,0,1
4552," This function returns the client peer id, by creating and caching it  if client->peerid is NULL, otherwise returning the cached value.",0,0,0,0
4553,"The Peer ID never changes during the life of the client, however it  is expensive to compute.",1,0,0,1
4554," Concatenate a string representing the state of a client in an human  readable format, into the sds string 's'.",1,0,0,1
4555, CLIENT LIST,0,1,0,1
4556, CLIENT REPLY ON|OFF|SKIP,0,1,0,1
4557, CLIENT KILL <ip:port>          CLIENT KILL <option> [value] ... <option> [value],0,0,0,0
4558, Old style syntax: CLIENT KILL <addr>,1,0,0,1
4559," With the old form, you can kill yourself.",1,1,0,1
4560, Next option index.,0,0,0,0
4561, New style syntax: parse options.,1,1,0,1
4562, Iterate clients killing all the matching clients.,0,1,0,1
4563, Kill it.,0,1,0,1
4564, Reply according to old or new format.,1,1,0,1
4565," If this client has to be closed, flag it as CLOSE_AFTER_REPLY          only after we queued the reply to its output buffers.",1,0,0,1
4566, Setting the client name to an empty string actually removes          the current name.,1,0,0,1
4567, Otherwise check if the charset is ok. We need to do this otherwise          CLIENT LIST format will break.,1,0,0,1
4568,You should always be able to          split by space to get the different fields.,1,0,0,1
4569, ASCII is assumed.,0,1,0,1
4570," This callback is bound to POST and ""Host:"" command names.",0,0,0,0
4571,"Those are not  really commands, but are used in security attacks in order to talk to  Redis instances via HTTP, with a technique called ""cross protocol scripting""  which exploits the fact that services like Redis will discard invalid  HTTP headers and will process what follows.",1,0,0,1
4572,"As a protection against this attack, Redis will terminate the connection  when a POST or ""Host:"" header is seen, and will log the event from  time to time (to avoid creating a DOS as a result of too many logs).",1,0,0,1
4573, Rewrite the command vector of the client.,0,1,0,1
4574,All the new objects ref count  is incremented.,1,0,0,1
4575,"The old command vector is freed, and the old objects  ref count is decremented.",1,0,0,1
4576, The new argument vector,1,1,0,1
4577," We free the objects in the original vector at the end, so we are      sure that if the same objects are reused in the new vector the      refcount gets incremented before it gets decremented.",1,0,0,1
4578, Replace argv and argc with our new versions.,1,0,0,1
4579, Completely replace the client command vector with the provided one.,1,1,0,1
4580, Rewrite a single item in the command vector.,1,1,0,1
4581,"The new val ref count is incremented, and the old decremented.",1,1,0,1
4582,It is possible to specify an argument over the current size of the  argument vector: in this case the array of objects gets reallocated  and c->argc set to the max value.,1,0,0,1
4583,However it's up to the caller to   1.,0,0,0,0
4584,"Make sure there are no ""holes"" and all the arguments are set.",1,0,0,1
4585,"If the original argument vector was longer than the one we     want to end with, it's up to the caller to set c->argc and     free the no longer used objects on c->argv.",1,0,0,1
4586, If this is the command name make sure to fix c->cmd.,1,0,0,1
4587, This function returns the number of bytes that Redis is virtually  using to store the reply still not read by the client.,0,0,0,0
4588,"It is ""virtual"" since the reply output list may contain objects that  are shared and are not really using additional memory.",1,0,0,1
4589,"The function returns the total sum of the length of all the objects  stored in the output list, plus the memory used to allocate every  list node.",1,0,0,1
4590,The static reply buffer is not taken into account since it  is allocated anyway.,1,0,0,1
4591,Note: this function is very fast so can be called as many time as  the caller wishes.,1,0,0,1
4592,The main usage of this function currently is  enforcing the client output length limits.,1,0,0,1
4593," The +5 above means we assume an sds16 hdr, may not be true      but is not going to be a problem.",1,0,0,1
4594," Get the class of a client, used in order to enforce limits to different  classes of clients.",1,0,0,1
4595,The function will return one of the following:  CLIENT_TYPE_NORMAL -> Normal client  CLIENT_TYPE_SLAVE  -> Slave or client executing MONITOR command  CLIENT_TYPE_PUBSUB -> Client subscribed to Pub or Sub channels  CLIENT_TYPE_MASTER -> The client representing our replication master.,1,0,0,1
4596," The function checks if the client reached output buffer soft or hard  limit, and also update the state needed to check the soft limit as  a side effect.",1,0,0,1
4597,Return value: non-zero if the client reached the soft or the hard limit.,1,1,0,1
4598,Otherwise zero is returned.,0,0,0,0
4599," For the purpose of output buffer limiting, masters are handled      like normal clients.",1,0,0,1
4600, We need to check if the soft limit is reached continuously for the      specified amount of seconds.,1,0,0,1
4601, First time we see the soft limit reached,1,1,0,1
4602, The client still did not reached the max number of                             seconds for the soft limit to be considered                             reached.,1,0,0,1
4603, Asynchronously close a client if soft or hard limit is reached on the  output buffer size.,1,0,0,1
4604,The caller can check if the client will be closed  checking if the client CLIENT_CLOSE_ASAP flag is set.,1,0,0,1
4605,"Note: we need to close the client asynchronously because this function is  called from contexts where the client can't be freed safely, i.e.",1,0,0,1
4606,from the  lower level functions pushing data inside the client output buffers.,0,0,0,0
4607, Helper function used by freeMemoryIfNeeded() in order to flush slaves  output buffers without returning control to the event loop.,0,0,0,0
4608,This is also called by SHUTDOWN for a best-effort attempt to send  slaves the latest writes.,1,0,0,1
4609," Note that the following will not flush output buffers of slaves          in STATE_ONLINE but having put_online_on_ack set to true: in this          case the writable event is never installed, since the purpose          of put_online_on_ack is to postpone the moment it is installed.",1,0,0,1
4610,This is what we want since slaves in this state should not receive          writes before the first ACK.,1,0,0,1
4611, Pause clients up to the specified unixtime (in ms).,0,0,0,0
4612,"While clients  are paused no command is processed from clients, so the data set can't  change during that time.",0,0,0,0
4613,"However while this function pauses normal and Pub or Sub clients, slaves are  still served, so this function can be used on server upgrades where it is  required that slaves process the latest bytes from the replication stream  before being turned to masters.",1,0,0,1
4614,This function is also internally used by Redis Cluster for the manual  failover procedure implemented by CLUSTER FAILOVER.,0,0,0,0
4615,"The function always succeed, even if there is already a pause in progress.",0,1,0,1
4616,"In such a case, the pause is extended if the duration is more than the  time left for the previous duration.",1,0,0,1
4617,"However if the duration is smaller  than the time left for the previous pause, no change is made to the  left duration.",1,0,0,1
4618, Return non-zero if clients are currently paused.,1,1,0,1
4619,As a side effect the  function checks if the pause time was reached and clear it.,1,0,0,1
4620, Put all the clients in the unblocked clients queue in order to          force the re-processing of the input buffer if any.,0,0,0,0
4621, Don't touch slaves and blocked clients.,0,1,0,1
4622,The latter pending              requests be processed when unblocked.,0,0,0,0
4623, This function is called by Redis in order to process a few events from  time to time while blocked into some not interruptible operation.,1,0,0,1
4624,This allows to reply to clients with the -LOADING error while loading the  data set at startup or after a full resynchronization with the master  and so forth.,1,0,0,1
4625,It calls the event loop in order to process a few events.,1,1,0,1
4626,"Specifically we  try to call the event loop 4 times as long as we receive acknowledge that  some event was processed, in order to go forward with the accept, read,  write, close sequence needed to serve a client.",1,0,0,1
4627,The function returns the total number of events processed.,1,1,0,1
4628, See the function top-comment.,0,1,0,1
4629, This file implements keyspace events notification via Pub or Sub ad  described at http: or  or redis.io or topics or keyspace-events.,0,0,0,0
4630, Turn a string representing notification classes into an integer  representing notification classes flags xored.,0,0,0,0
4631,The function returns -1 if the input contains characters not mapping to  any class.,0,0,0,0
4632, This function does exactly the revese of the function above: it gets  as input an integer with the xored flags and returns a string representing  the selected classes.,1,0,0,1
4633,The string returned is an sds string that needs to  be released with sdsfree().,0,0,0,0
4634," The API provided to the rest of the Redis core is a simple function:   notifyKeyspaceEvent(char event, robj key, int dbid);   'event' is a C string representing the event name.",1,0,0,1
4635,'key' is a Redis object representing the key name.,1,0,0,1
4636,'dbid' is the database ID where the key lives.,1,0,0,1
4637," If any modules are interested in events, notify the module system now.",1,1,0,1
4638,"This bypasses the notifications configuration, but the module engine      will only call event subscribers if the event type matches the types      they are interested in.",1,0,0,1
4639," If notifications for this class of events are off, return ASAP.",0,1,0,1
4640, __keyspace@<db>__:<key> <event> notifications.,0,0,0,0
4641, __keyevent@<db>__:<event> <key> notifications.,0,0,0,0
4642, ===================== Creation and parsing of objects ====================,0,1,0,1
4643," Set the LRU to the current lruclock (minutes resolution), or      alternatively the LFU counter.",1,0,0,1
4644," Set a special refcount in the object to make it ""shared"":  incrRefCount and decrRefCount() will test for this special refcount  and will not touch the object.",1,0,0,1
4645,This way it is free to access shared  objects such as small integers from different threads without any  mutex.,1,0,0,1
4646,A common patter to create shared objects:   robj myobject = makeObjectShared(createObject(...));,1,0,0,1
4647," Create a string object with encoding OBJ_ENCODING_RAW, that is a plain  string object where o->ptr points to a proper sds string.",1,0,0,1
4648," Create a string object with encoding OBJ_ENCODING_EMBSTR, that is  an object where the sds string is actually an unmodifiable string  allocated in the same chunk as the object itself.",1,0,0,1
4649," Create a string object with EMBSTR encoding if it is smaller than  OBJ_ENCODING_EMBSTR_SIZE_LIMIT, otherwise the RAW encoding is  used.",1,0,0,1
4650,The current limit of 44 is chosen so that the biggest string object  we allocate as EMBSTR will still fit into the 64 byte arena of jemalloc.,1,0,0,1
4651, Create a string object from a long double.,1,1,0,1
4652,"If humanfriendly is non-zero  it does not use exponential format and trims trailing zeroes at the end,  however this results in loss of precision.",0,0,0,0
4653,Otherwise exp format is used  and the output of snprintf() is not modified.,0,0,0,0
4654,The 'humanfriendly' option is used for INCRBYFLOAT and HINCRBYFLOAT.,0,0,0,0
4655," Duplicate a string object, with the guarantee that the returned object  has the same encoding as the original one.",1,0,0,1
4656,This function also guarantees that duplicating a small integere object  (or a string object that contains a representation of a small integer)  will always result in a fresh object that is unshared (refcount == 1).,1,0,0,1
4657,The resulting object always has refcount set to 1.,0,0,0,0
4658," This variant of decrRefCount() gets its argument as void, and is useful  as free method in data structures that expect a 'void free_object(void)'  prototype for the free method.",1,0,0,1
4659, This function set the ref count to zero without freeing the object.,0,1,0,1
4660,It is useful in order to pass a new object to functions incrementing  the ref count of the received object.,1,0,0,1
4661,Example:      functionThatWillIncrementRefCount(resetRefCount(CreateObject(...)));   Otherwise you need to resort to the less elegant pattern:      obj = createObject(...);     functionThatWillIncrementRefCount(obj);     decrRefCount(obj);,1,0,0,1
4662, Try to encode a string object in order to save space,0,1,0,1
4663," Make sure this is a string object, the only type we encode      in this function.",1,0,0,1
4664,Other types use encoded memory efficient      representations but are handled by the commands implementing      the type.,1,0,0,1
4665," We try some specialized encoding only for objects that are      RAW or EMBSTR encoded, in other words objects that are still      in represented by an actually array of chars.",1,0,0,1
4666," It's not safe to encode shared objects: shared objects can be shared      everywhere in the ""object space"" of Redis and may end in places where      they are not handled.",1,0,0,1
4667,We handle them only as values in the keyspace.,1,0,0,1
4668, Check if we can represent this string as a long integer.,1,1,0,1
4669,Note that we are sure that a string larger than 20 chars is not      representable as a 32 nor 64 bit integer.,1,0,0,1
4670, This object is encodable as a long.,1,0,0,1
4671,Try to use a shared object.,0,1,0,1
4672,Note that we avoid using shared integers when maxmemory is used          because every object needs to have a private LRU field for the LRU          algorithm to work well.,1,0,0,1
4673," If the string is small and is still RAW encoded,      try the EMBSTR encoding which is more efficient.",1,0,0,1
4674,In this representation the object and the SDS string are allocated      in the same chunk of memory to save space and cache misses.,1,0,0,1
4675," We can't encode the object...           Do the last try, and at least optimize the SDS string inside      the string object to require little space, in case there      is more than 10% of free space at the end of the SDS string.",1,0,0,1
4676,We do that only for relatively large strings as this branch      is only entered if the length of the string is greater than      OBJ_ENCODING_EMBSTR_SIZE_LIMIT.,1,0,0,1
4677, Return the original object.,1,1,0,1
4678, Get a decoded version of an encoded object (returned as a new object).,1,1,0,1
4679,If the object is already raw-encoded just increment the ref count.,0,0,0,0
4680, Compare two string objects via strcmp() or strcoll() depending on flags.,0,0,0,0
4681,Note that the objects may be integer-encoded.,0,1,0,1
4682,"In such a case we  use ll2string() to get a string representation of the numbers on the stack  and compare the strings, it's much faster than calling getDecodedObject().",1,0,0,1
4683,Important note: when REDIS_COMPARE_BINARY is used a binary-safe comparison  is used.,1,0,0,1
4684, Wrapper for compareStringObjectsWithFlags() using binary comparison.,0,0,0,0
4685, Wrapper for compareStringObjectsWithFlags() using collation.,0,0,0,0
4686," Equal string objects return 1 if the two objects are the same from the  point of view of a string comparison, otherwise 0 is returned.",1,0,0,1
4687,"Note that  this function is faster then checking for (compareStringObject(a,b) == 0)  because it can perform some more optimization.",1,0,0,1
4688, If both strings are integer encoded just check if the stored          long is the same.,1,0,0,1
4689, =========================== Memory introspection =========================,0,1,0,1
4690, This is an helper function with the goal of estimating the memory  size of a radix tree that is used to store Stream IDs.,0,0,0,0
4691,"Note: to guess the size of the radix tree is not trivial, so we  approximate it considering 128 bytes of data overhead for each  key (the ID), and then adding the number of bare nodes, plus some  overhead due by the data and child pointers.",1,0,0,1
4692,"This secret recipe  was obtained by checking the average radix tree created by real  workloads, and then adjusting the constants to get numbers that  more or less match the real memory usage.",1,0,0,1
4693,Actually the number of nodes and keys may be different depending  on the insertion speed and thus the ability of the radix tree  to compress prefixes.,1,0,0,1
4694," Add a fixed overhead due to the aux data pointer, children, ...",1,1,0,1
4695, Returns the size in bytes consumed by the key's value in RAM.,1,1,0,1
4696,"Note that the returned value is just an approximation, especially in the  case of aggregated data types where only ""sample_size"" elements  are checked and averaged to estimate the total size.",1,0,0,1
4697, Default sample size.,0,1,0,1
4698, Now we have to add the listpacks.,0,0,0,0
4699,"The last listpack is often non          complete, so we estimate the size of the first N listpacks, and          use the average to compute the size of the first N-1 listpacks, and          finally add the real size of the last node.",1,0,0,1
4700, Compute the average.,1,1,0,1
4701," No need to check if seek succeeded, we enter this branch only              if there are a few elements in the radix tree.",1,0,0,1
4702," Consumer groups also have a non trivial memory overhead if there          are many consumers and many groups, let's count at least the          overhead of the pending entries in the groups and consumers          PELs.",1,0,0,1
4703, For each consumer we also need to add the basic data                  structures and the PEL memory usage.,1,0,0,1
4704," Don't count NACKs again, they are shared with the                      consumer group PEL.",0,0,0,0
4705, Release data obtained with getMemoryOverheadData().,0,0,0,0
4706, Return a struct redisMemOverhead filled with memory overhead  information used for the MEMORY OVERHEAD and INFO command.,1,0,0,1
4707,The returned  structure pointer should be freed calling freeMemoryOverheadData().,0,0,0,0
4708, Metrics computed after subtracting the startup memory from      the total memory.,1,0,0,1
4709," Helper for ""MEMORY allocator-stats"", used as a callback for the jemalloc  stats output.",0,0,0,0
4710," result is actually a (sds ), so re-cast it here",1,0,0,1
4711, This implements MEMORY DOCTOR.,0,1,0,1
4712,An human readable analysis of the Redis  memory condition.,1,0,0,1
4713, Instance is empty or almost empty.,1,1,0,1
4714, Memory peak is much larger than used mem.,1,0,0,1
4715, High fragmentation.,1,1,0,1
4716, High allocator fragmentation.,1,0,0,1
4717, High process rss overhead.,1,0,0,1
4718, High rss overhead.,1,0,0,1
4719, Slave buffers are too big.,1,1,0,1
4720, Client buffers are too big.,1,1,0,1
4721, Peak is > 150% of current used memory?,1,1,0,1
4722, Fragmentation is higher than 1.4 and 10MB ?,1,1,0,1
4723, External fragmentation is higher than 1.1 and 10MB?,1,1,0,1
4724, Allocator fss is higher than 1.1 and 10MB ?,1,0,0,1
4725, Non-Allocator fss is higher than 1.1 and 10MB ?,1,0,0,1
4726, Clients using more than 200k each average?,1,1,0,1
4727, Slaves using more than 10 MB each?,1,1,0,1
4728, ======================= The OBJECT and MEMORY commands ===================,0,1,0,1
4729, This is a helper function for the OBJECT command.,0,1,0,1
4730,We need to lookup keys  without any modification of LRU or other parameters.,1,0,0,1
4731, Object command allows to inspect the internals of an Redis Object.,0,0,0,0
4732,Usage: OBJECT <refcount|encoding|idletime|freq> <key>,0,0,0,0
4733," LFUDecrAndReturn should be called          in case of the key has not been accessed for a long time,          because we update the access time only          when the key is read or overwritten.",1,0,0,1
4734, The memory command will eventually be a complete interface for the  memory introspection capabilities of Redis.,1,0,0,1
4735,Usage: MEMORY usage <key>,0,1,0,1
4736, skip option argument.,0,0,0,0
4737," this is the total RSS overhead, including fragmentation",1,0,0,1
4738, it is kept here for backwards compatibility,0,0,0,0
4739, Nothing to do for other allocators.,1,0,0,1
4740,"$NetBSD: qsort.c,v 1.19 2009 or 01 or 30 23:38:44 lukem Exp $",0,0,0,0
4741,"-  Copyright (c) 1992, 1993 The Regents of the University of California.",0,0,0,0
4742,All rights reserved.,0,1,0,1
4743,"Redistribution and use in source and binary forms, with or without  modification, are permitted provided that the following conditions  are met:  1.",1,0,0,1
4744,"Redistributions of source code must retain the above copyright     notice, this list of conditions and the following disclaimer.",1,0,0,1
4745,"Redistributions in binary form must reproduce the above copyright     notice, this list of conditions and the following disclaimer in the     documentation and or or other materials provided with the distribution.",1,0,0,1
4746,Neither the name of the University nor the names of its contributors     may be used to endorse or promote products derived from this software     without specific prior written permission.,1,0,0,1
4747,"THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  ARE DISCLAIMED.",1,0,0,1
4748,"IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  SUCH DAMAGE.",1,0,0,1
4749,"  Qsort routine from Bentley & McIlroy's ""Engineering a Sort Function"".",0,0,0,0
4750, Iterate rather than recurse to save stack space,0,0,0,0
4751,"qsort(pn - r, r  or  es, es, cmp);",0,0,0,0
4752,-----------------------------------------------------------------------------  Pubsub low level API ----------------------------------------------------------------------------,1,0,0,1
4753, Return the number of channels + patterns a client is subscribed to.,0,1,0,1
4754, Subscribe a client to a channel.,0,1,0,1
4755,"Returns 1 if the operation succeeded, or  0 if the client was already subscribed to that channel.",0,0,0,0
4756, Add the channel to the client -> channels hash table,0,1,0,1
4757, Add the client to the channel -> list of clients hash table,0,1,0,1
4758, Notify the client,0,1,0,1
4759, Unsubscribe a client from a channel.,0,1,0,1
4760,"Returns 1 if the operation succeeded, or  0 if the client was not subscribed to the specified channel.",0,0,0,0
4761, Remove the channel from the client -> channels hash table,0,1,0,1
4762, channel may be just a pointer to the same object                            we have in the hash tables.,1,0,0,1
4763,Protect it...,0,1,0,1
4764, Remove the client from the channel -> clients list hash table,0,1,0,1
4765," Free the list and associated hash entry at all if this was              the latest client, so that it will be possible to abuse              Redis PUBSUB creating millions of channels.",1,0,0,1
4766, Notify the client,0,1,0,1
4767, it is finally safe to release it,1,0,0,1
4768, Subscribe a client to a pattern.,0,1,0,1
4769,"Returns 1 if the operation succeeded, or 0 if the client was already subscribed to that pattern.",0,1,0,1
4770, Notify the client,0,1,0,1
4771, Unsubscribe a client from a channel.,0,1,0,1
4772,"Returns 1 if the operation succeeded, or  0 if the client was not subscribed to the specified channel.",0,0,0,0
4773, Protect the object.,0,1,0,1
4774,May be the same we remove,1,0,0,1
4775, Notify the client,0,1,0,1
4776, Unsubscribe from all the channels.,0,1,0,1
4777,Return the number of channels the  client was subscribed to.,0,0,0,0
4778, We were subscribed to nothing?,0,1,0,1
4779,Still reply to the client.,0,1,0,1
4780, Unsubscribe from all the patterns.,0,1,0,1
4781,Return the number of patterns the  client was subscribed from.,0,0,0,0
4782, We were subscribed to nothing?,0,1,0,1
4783,Still reply to the client.,0,1,0,1
4784, Publish a message,0,1,0,1
4785, Send to clients listening for that channel,0,1,0,1
4786, Send to clients listening to matching channels,0,1,0,1
4787,-----------------------------------------------------------------------------  Pubsub commands implementation ----------------------------------------------------------------------------,0,0,0,0
4788, PUBSUB command for Pub or Sub introspection.,0,1,0,1
4789, PUBSUB CHANNELS [<pattern>],0,1,0,1
4790, PUBSUB NUMSUB [Channel_1 ... Channel_N],0,1,0,1
4791, PUBSUB NUMPAT,0,1,0,1
4792, for memcpy,0,0,0,0
4793, for ll2string,0,0,0,0
4794," for printf (debug printing), snprintf (genstr)",0,0,0,0
4795, Optimization levels for size-based filling,0,1,0,1
4796, Maximum size in bytes of any multi-element ziplist.,0,0,0,0
4797,Larger values will live in their own isolated ziplists.,1,0,0,1
4798, Minimum ziplist size in bytes for attempting compression.,0,0,0,0
4799, Minimum size reduction in bytes to store compressed quicklistNode data.,0,0,0,0
4800,This also prevents us from storing compression if the compression  resulted in a larger size than the original data.,1,0,0,1
4801," If not verbose testing, remove all debug printing.",0,1,0,1
4802, Simple way to give quicklistEntry structs default values with one call.,1,0,0,1
4803, Create a new quicklist.,1,0,0,1
4804,Free with quicklistRelease().,1,0,0,1
4805, Create a new quicklist with some default parameters.,1,0,0,1
4806, Return cached quicklist count,0,0,0,0
4807, Free entire quicklist.,1,0,0,1
4808, Compress the ziplist in 'node' and update encoding details.,0,0,0,0
4809,Returns 1 if ziplist compressed successfully.,1,0,0,1
4810,Returns 0 if compression failed or if ziplist too small to compress.,1,0,0,1
4811, Don't bother compressing small values,1,1,0,1
4812, Cancel if compression fails or doesn't compress small enough,1,1,0,1
4813, lzf_compress aborts or rejects compression if value not compressable.,0,0,0,0
4814, Compress only uncompressed nodes.,1,1,0,1
4815, Uncompress the ziplist in 'node' and update encoding details.,0,0,0,0
4816,"Returns 1 on successful decode, 0 on failure to decode.",1,1,0,1
4817," Someone requested decompress, but we can't decompress.",0,1,0,1
4818,Not good.,1,1,0,1
4819, Decompress only compressed nodes.,1,1,0,1
4820, Force node to not be immediately re-compresable,0,0,0,0
4821, Extract the raw LZF data from this quicklistNode.,1,0,0,1
4822,Pointer to LZF data is assigned to 'data'.,0,1,0,1
4823,Return value is the length of compressed LZF data.,0,1,0,1
4824, Force 'quicklist' to meet compression guidelines set by compress depth.,0,0,0,0
4825,"The only way to guarantee interior nodes get compressed is to iterate  to our ""interior"" compress depth then compress the next node we find.",1,0,0,1
4826,"If compress depth is larger than the entire list, we return immediately.",1,1,0,1
4827," If length is less than our compress depth (from both sides),      we can't compress anything.",1,0,0,1
4828, Optimized cases for small depth counts,1,1,0,1
4829," Iterate until we reach compress depth for both sides of the list.a      Note: because we do length checks at the top of this function,            we can skip explicit null checks below.",1,0,0,1
4830,Everything exists.,0,1,0,1
4831," At this point, forward and reverse are one node beyond depth",0,1,0,1
4832," If we previously used quicklistDecompressNodeForUse(), just recompress.",1,0,0,1
4833, Insert 'new_node' after 'old_node' if 'after' is 1.,0,0,0,0
4834,Insert 'new_node' before 'old_node' if 'after' is 0.,0,0,0,0
4835,"Note: 'new_node' is always uncompressed, so if we assign it to        head or tail, we do not need to uncompress it.",0,0,0,0
4836," If this insert creates the only element so far, initialize head or tail.",1,1,0,1
4837, Wrappers for node inserting around existing node.,0,1,0,1
4838, size of previous offset,1,0,0,1
4839, size of forward offset,0,0,0,0
4840, new_sz overestimates if 'sz' encodes to an integer type,0,0,0,0
4841, approximate merged ziplist size (- 11 to remove one ziplist      header or trailer),1,0,0,1
4842, Add new entry to head node of quicklist.,1,0,0,1
4843,Returns 0 if used existing head.,0,1,0,1
4844,Returns 1 if new head created.,1,1,0,1
4845, Add new entry to tail node of quicklist.,1,0,0,1
4846,Returns 0 if used existing tail.,0,1,0,1
4847,Returns 1 if new tail created.,1,1,0,1
4848, Create new node consisting of a pre-formed ziplist.,1,0,0,1
4849,Used for loading RDBs where entire ziplists have been stored  to be retrieved later.,1,0,0,1
4850, Append all values of ziplist 'zl' individually into 'quicklist'.,1,0,0,1
4851,This allows us to restore old RDB ziplists into new quicklists  with smaller ziplist sizes than the saved RDB ziplist.,1,0,0,1
4852,Returns 'quicklist' argument.,0,0,0,0
4853,Frees passed-in ziplist 'zl',0,0,0,0
4854, Write the longval as a string so we can re-add it,0,0,0,0
4855, Create new (potentially multi-node) quicklist from a single existing ziplist.,1,0,0,1
4856,Returns new quicklist.,1,0,0,1
4857,Frees passed-in ziplist 'zl'.,0,0,0,0
4858," If we deleted a node within our compress depth, we      now have compressed nodes needing to be decompressed.",0,0,0,0
4859, Delete one entry from list given the node for the entry and a pointer  to the entry in the node.,0,0,0,0
4860,Note: quicklistDelIndex() requires uncompressed nodes because you        already had to get p from an uncompressed node somewhere.,0,0,0,0
4861,"Returns 1 if the entire node was deleted, 0 if node still exists.",1,1,0,1
4862,Also updates in or out param 'p' with the next offset in the ziplist.,0,0,0,0
4863," If we deleted the node, the original node is no longer valid",1,1,0,1
4864, Delete one element represented by 'entry'   'entry' stores enough metadata to delete the proper position in  the correct ziplist in the correct quicklist node.,1,0,0,1
4865," after delete, the zi is now invalid for any future usage.",1,0,0,1
4866," If current node is deleted, we must update iterator node and offset.",1,1,0,1
4867," else if (!deleted_node), no changes needed.",0,0,0,0
4868,"we already reset iter->zi above, and the existing iter->offset      doesn't move again because:        - [1, 2, 3] => delete offset 1 => [1, 3]: next element still offset 1        - [1, 2, 3] => delete offset 0 => [2, 3]: next element still offset 0       if we deleted the last element at offet N and now       length of this ziplist is N-1, the next call into       quicklistNext() will jump to the next node.",1,0,0,1
4869, Replace quicklist entry at offset 'index' by 'data' with length 'sz'.,0,0,0,0
4870,Returns 1 if replace happened.,0,1,0,1
4871,Returns 0 if replace failed and no changes happened.,1,1,0,1
4872, quicklistIndex provides an uncompressed node,0,0,0,0
4873," Given two nodes, try to merge their ziplists.",0,0,0,0
4874,This helps us not have a quicklist with 3 element ziplists if  our fill factor can handle much higher levels.,1,0,0,1
4875,Note: 'a' must be to the LEFT of 'b'.,0,1,0,1
4876,"After calling this function, both 'a' and 'b' should be considered  unusable.",0,0,0,0
4877,The return value from this function must be used  instead of re-using any of the quicklistNode input arguments.,0,0,0,0
4878,Returns the input node picked to merge against or NULL if  merging was not possible.,1,0,0,1
4879, We merged ziplists!,0,0,0,0
4880,Now remove the unused quicklistNode.,0,0,0,0
4881," else, the merge returned NULL and nothing changed.",0,0,0,0
4882, Attempt to merge ziplists within two nodes on either side of 'center'.,1,0,0,1
4883,"We attempt to merge:    - (center->prev->prev, center->prev)    - (center->next, center->next->next)    - (center->prev, center)    - (center, center->next)",1,0,0,1
4884, Try to merge prev_prev and prev,0,0,0,0
4885," they could have moved, invalidate them.",0,0,0,0
4886, Try to merge next and next_next,0,0,0,0
4887," they could have moved, invalidate them.",0,0,0,0
4888, Try to merge center node and previous node,1,1,0,1
4889," center could have been deleted, invalidate it.",1,0,0,1
4890," else, we didn't merge here, but target needs to be valid below.",0,0,0,0
4891, Use result of center merge (or original) to merge with next node.,1,1,0,1
4892," Split 'node' into two parts, parameterized by 'offset' and 'after'.",0,0,0,0
4893,The 'after' argument controls which quicklistNode gets returned.,0,0,0,0
4894,"If 'after'==1, returned node has elements after 'offset'.",0,1,0,1
4895,"input node keeps elements up to 'offset', including 'offset'.",0,0,0,0
4896,"If 'after'==0, returned node has elements up to 'offset', including 'offset'.",0,1,0,1
4897,input node keeps elements after 'offset'.,0,0,0,0
4898,"If 'after'==1, returned node will have elements _after_ 'offset'.",0,0,0,0
4899,"The returned node will have elements [OFFSET+1, END].",0,1,0,1
4900,"The input node keeps elements [0, OFFSET].",0,1,0,1
4901,"If 'after'==0, returned node will keep elements up to and including 'offset'.",0,1,0,1
4902,"The returned node will have elements [0, OFFSET].",0,1,0,1
4903,"The input node keeps elements [OFFSET+1, END].",0,1,0,1
4904,The input node keeps all elements not taken by the returned node.,0,1,0,1
4905,Returns newly created node or NULL if split not possible.,1,1,0,1
4906, Copy original ziplist so we can split it,1,0,0,1
4907," -1 here means ""continue deleting until the list ends""",0,0,0,0
4908, Insert a new entry before or after existing entry 'entry'.,1,1,0,1
4909,"If after==1, the new value is inserted after 'entry', otherwise  the new value is inserted before 'entry'.",1,0,0,1
4910," we have no reference node, so let's create only node in the list",1,0,0,1
4911, Populate accounting flags for easier boolean checks later,0,0,0,0
4912, Now determine where and how to insert the new element,1,1,0,1
4913," If we are: at tail, next has free space, and inserting after:            - insert entry at head of next node.",1,0,0,1
4914," If we are: at head, previous has free space, and inserting before:            - insert entry at tail of previous node.",1,0,0,1
4915," If we are: full, and our prev or next is full, then:            - create new node and attach to quicklist",1,0,0,1
4916," else, node is full we need to split it.",1,0,0,1
4917, covers both after and !after cases,0,0,0,0
4918, Delete a range of elements from the quicklist.,0,0,0,0
4919,"elements may span across multiple quicklistNodes, so we  have to be careful about tracking where we start and end.",1,0,0,1
4920,"Returns 1 if entries were deleted, 0 if nothing was deleted.",0,1,0,1
4921, range is inclusive of start position,0,0,0,0
4922," if requesting delete more elements than exist, limit to list size.",1,0,0,1
4923," else, if at negative offset, limit max size to rest of list.",1,0,0,1
4924, c.f.,0,1,0,1
4925,LREM -29 29; just delete until end.,0,1,0,1
4926, iterate over next nodes until everything is deleted.,0,0,0,0
4927," If we are deleting more than the count of this node, we              can just delete the entire node without ziplist math.",1,0,0,1
4928," If deleting more nodes after this one, calculate delete based              on size of current node.",1,0,0,1
4929," If offset is negative, we are in the first run of this loop              and we are deleting the entire range              from this start offset to end of list.",1,0,0,1
4930,"Since the Negative              offset is the number of elements until the tail of the list,              just use it directly as the deletion count.",1,0,0,1
4931," If the positive offset is greater than the remaining extent,              we only delete the remaining extent, not the entire offset.",1,0,0,1
4932," else, we are deleting less than the extent of this node, so              use extent directly.",1,0,0,1
4933, Passthrough to ziplistCompare(),0,0,0,0
4934, Returns a quicklist iterator 'iter'.,0,0,0,0
4935,After the initialization every  call to quicklistNext() will return the next element of the quicklist.,0,0,0,0
4936, Initialize an iterator at a specific offset 'idx' and make the iterator  return nodes in 'direction' direction.,1,0,0,1
4937, Release iterator.,0,1,0,1
4938,"If we still have a valid current node, then re-encode current node.",1,1,0,1
4939, Get next element in iterator.,0,1,0,1
4940,Note: You must NOT insert into the list while iterating over it.,0,1,0,1
4941,You may delete from the list while iterating using the  quicklistDelEntry() function.,0,0,0,0
4942,"If you insert into the quicklist while iterating, you should  re-create the iterator after your addition.",0,0,0,0
4943,"iter = quicklistGetIterator(quicklist,<direction>);  quicklistEntry entry;  while (quicklistNext(iter, &entry)) {      if (entry.value)           [[ use entry.value with entry.sz ]]      else           [[ use entry.longval ]]  }   Populates 'entry' with values for this iteration.",0,0,0,0
4944,Returns 0 when iteration is complete or if iteration not possible.,1,1,0,1
4945,"If return value is 0, the contents of 'entry' are not valid.",0,1,0,1
4946," If !zi, use current index.",1,0,0,1
4947," else, use existing iterator offset and get prev or next as necessary.",1,0,0,1
4948, Populate value from existing ziplist position,0,0,0,0
4949, We ran out of ziplist entries.,0,0,0,0
4950,"Pick next node, update offset, then re-run retrieval.",0,1,0,1
4951, Forward traversal,0,1,0,1
4952, Reverse traversal,0,1,0,1
4953, Duplicate the quicklist.,0,0,0,0
4954,On success a copy of the original quicklist is returned.,1,0,0,1
4955,The original quicklist both on success or error is never modified.,1,0,0,1
4956,Returns newly allocated quicklist.,1,0,0,1
4957, copy->count must equal orig->count here,1,0,0,1
4958," Populate 'entry' with the element at the specified zero-based index  where 0 is the head, 1 is the element next to head  and so on.",0,0,0,0
4959,"Negative integers are used in order to count  from the tail, -1 is the last element, -2 the penultimate  and so on.",1,0,0,1
4960,If the index is out of range 0 is returned.,0,0,0,0
4961,Returns 1 if element found  Returns 0 if element not found,0,0,0,0
4962," < 0 -> reverse, 0+ -> forward",0,1,0,1
4963, forward = normal head-to-tail offset.,1,0,0,1
4964," reverse = need negative offset for tail-to-head, so undo          the result of the original if (index < 0) above.",1,0,0,1
4965," The caller will use our result, so we don't re-compress here.",0,1,0,1
4966,The caller can recompress or delete the node as needed.,0,0,0,0
4967, Rotate quicklist by moving the tail element to the head.,0,0,0,0
4968," First, get the tail entry",1,1,0,1
4969," If value found is NULL, then ziplistGet populated longval instead",0,0,0,0
4970, Write the longval as a string so we can re-add it,0,0,0,0
4971, Add tail entry to head (must happen before tail is deleted).,0,1,0,1
4972," If quicklist has only one node, the head ziplist is also the      tail ziplist and PushHead() could have reallocated our single ziplist,      which would make our pre-existing 'p' unusable.",1,0,0,1
4973, Remove tail entry.,0,1,0,1
4974, pop from quicklist and return result in 'data' ptr.,0,0,0,0
4975,Value of 'data'  is the return value of 'saver' function pointer if the data is NOT a number.,0,0,0,0
4976,"If the quicklist element is a long long, then the return value is returned in  'sval'.",1,0,0,1
4977,Return value of 0 means no elements available.,1,1,0,1
4978,Return value of 1 means check 'data' and 'sval' for values.,0,0,0,0
4979,"If 'data' is set, use 'data' and 'sz'.",0,0,0,0
4980,"Otherwise, use 'sval'.",0,0,0,0
4981, Return a malloc'd copy of data passed in,0,0,0,0
4982, Default pop function   Returns malloc'd value from quicklist,0,0,0,0
4983, Wrapper to allow argument-based switching between HEAD or TAIL pop,0,1,0,1
4984, The rest of this file is test cases and test helpers.,0,1,0,1
4985, Return the UNIX time in microseconds,0,1,0,1
4986, Return the UNIX time in milliseconds,0,1,0,1
4987, Iterate over an entire quicklist.,1,0,0,1
4988,Print the list if 'print' == 1.,0,1,0,1
4989,Returns physical count of elements found by iterating over the list.,1,1,0,1
4990, Count the number of list nodes too,0,1,0,1
4991, Verify list metadata matches physical list contents.,1,1,0,1
4992, Generate new string concatenating integer i against string 'prefix',1,1,0,1
4993," main test, but callable from other files",1,0,0,1
4994, 1 for head and 1 for tail beacuse 1 node = head = tail,0,0,0,0
4995, 1 for head and 1 for tail beacuse 1 node = head = tail,0,0,0,0
4996, Ignore compression verify because ziplist is                  too small to compress.,1,0,0,1
4997, force to unique node,1,0,0,1
4998, force to reset for +3,0,0,0,0
4999," insert ""bar"" before ""bob"" while iterating over list.",0,0,0,0
5000, Insert as fill = 1 so it spills into new node.,1,1,0,1
5001, didn't we fix insert-while-iterating?,0,0,0,0
5002, verify results,0,0,0,0
5003, lrem 0 bar,0,0,0,0
5004, check result of lrem 0 bar,0,0,0,0
5005," Result must be: abc, foo, foobar, foobared, zap, test,                      foo",0,0,0,0
5006, lrem -2 foo,0,0,0,0
5007, check result of lrem -2 foo,0,0,0,0
5008, (we're ignoring the '2' part and still deleting all foo                  because                  we only have two foo),1,0,0,1
5009," Result must be: abc, foo, foobar, foobared, zap, test,                      foo",0,0,0,0
5010, final result of all tests,1,0,0,1
5011," Check results after deletion of ""hij""",0,0,0,0
5012," ltrim 25 53 (keep [25,32] inclusive = 7 remaining)",0,0,0,0
5013, Force-disable compression because our 33 sequential                  integers don't compress and the check always fails.,1,0,0,1
5014," ltrim 5 16 (keep [5,16] inclusive = 12 remaining)",0,0,0,0
5015," ltrim 3 3 (keep [3,3] inclusive = 1 remaining)",0,0,0,0
5016, make sure not loop forever,1,0,0,1
5017, Run a longer test of compression depth outside of primary test loop.,1,1,0,1
5018, skip over many redundant test cases,1,0,0,1
5019, This is a special pointer that is guaranteed to never have the same value  of a radix tree node.,1,0,0,1
5020,"It's used in order to report ""not found"" error without  requiring the function to have multiple return values.",0,0,0,0
5021, -------------------------------- Debugging ------------------------------,0,1,0,1
5022, Turn debugging messages on or off.,0,1,0,1
5023, ------------------------- raxStack functions --------------------------  The raxStack is a simple stack of pointers that is capable of switching  from using a stack-allocated array to dynamic heap once a given number of  items are reached.,1,0,0,1
5024,It is used in order to retain the list of parent nodes  while walking the radix tree in order to implement certain operations that  need to navigate the tree upward.,1,0,0,1
5025, Initialize the stack.,0,1,0,1
5026," Push an item into the stack, returns 1 on success, 0 on out of memory.",1,1,0,1
5027," Pop an item from the stack, the function returns NULL if there are no  items to pop.",0,0,0,0
5028, Return the stack item at the top of the stack without actually consuming  it.,1,0,0,1
5029, Free the stack in case we used heap allocation.,1,1,0,1
5030, ----------------------------------------------------------------------------  Radix tree implementation  --------------------------------------------------------------------------,0,0,0,0
5031, Allocate a new non compressed node with the specified number of children.,1,1,0,1
5032,"If datafiled is true, the allocation is made large enough to hold the  associated data pointer.",1,0,0,1
5033,Returns the new node pointer.,1,1,0,1
5034,On out of memory NULL is returned.,0,1,0,1
5035, Allocate a new rax and return its pointer.,1,0,0,1
5036,On out of memory the function  returns NULL.,0,0,0,0
5037, Return the current total size of the node.,1,1,0,1
5038, realloc the node to make room for auxiliary data in order  to store an item in that node.,0,0,0,0
5039,On out of memory NULL is returned.,0,1,0,1
5040," No reallocation needed, setting isnull=1",0,0,0,0
5041, Set the node auxiliary data to the specified pointer.,0,1,0,1
5042, Get the node auxiliary data.,0,1,0,1
5043," Add a new child to the node 'n' representing the character 'c' and return  its new pointer, as well as the child pointer by reference.",1,0,0,1
5044,"Additionally  'parentlink' is populated with the raxNode pointer-to-pointer of where  the new child was stored, which is useful for the caller to replace the  child pointer if it gets reallocated.",1,0,0,1
5045,"On success the new parent node pointer is returned (it may change because  of the realloc, so the caller should discard 'n' and use the new value).",1,0,0,1
5046,"On out of memory NULL is returned, and the old node is still valid.",1,1,0,1
5047, Alloc the new child we will link to 'n'.,1,0,0,1
5048, Make space in the original node.,1,1,0,1
5049, Add 1 char and 1 pointer.,0,1,0,1
5050," After the reallocation, we have 5 or 9 (depending on the system      pointer size) bytes at the end, that is, the additional char      in the 'data' section, plus one pointer to the new child:           [numc][abx][ap][bp][xp]|auxp|.....           Let's find where to insert the new child in order to make sure      it is inserted in-place lexicographically.",1,0,0,1
5051," Now, if present, move auxiliary data pointer at the end      so that we can mess with the other data without overwriting it.",1,0,0,1
5052,We will obtain something like that:           [numc][abx][ap][bp][xp].....|auxp|,1,0,0,1
5053, Now imagine we are adding a node with edge 'c'.,0,1,0,1
5054,"The insertion      point is between 'b' and 'x', so the 'pos' variable value is      To start, move all the child pointers after the insertion point      of 1+sizeof(pointer) bytes on the right, to obtain:           [numc][abx][ap][bp].....[xp]|auxp|",1,0,0,1
5055," Now make the space for the additional char in the data section,      but also move the pointers before the insertion point in the right      by 1 byte, in order to obtain the following:           [numc][ab.x][ap][bp]....[xp]|auxp|",1,0,0,1
5056, We can now set the character and its child node pointer to get:           [numc][abcx][ap][bp][cp]....|auxp|      [numc][abcx][ap][bp][cp][xp]|auxp|,1,0,0,1
5057, Return the pointer to the last child pointer in a node.,1,1,0,1
5058,For the compressed  nodes this is the only child pointer.,1,0,0,1
5059, Return the pointer to the first child pointer.,1,1,0,1
5060," Turn the node 'n', that must be a node without any children, into a  compressed node representing a set of nodes linked one after the other  and having exactly one child each.",1,0,0,1
5061,The node can be a key or not: this  property and the associated value if any will be preserved.,1,0,0,1
5062,"The function also returns a child node, since the last node of the  compressed chain cannot be part of the chain: it has zero children while  we can only compress inner nodes with exactly one child each.",1,0,0,1
5063, Initialized only to avoid warnings.,1,1,0,1
5064, Allocate the child to link to this node.,0,1,0,1
5065, Make space in the parent node.,0,1,0,1
5066, To restore it later.,0,1,0,1
5067, Low level function that walks the tree looking for the string  's' of 'len' bytes.,1,0,0,1
5068,"The function returns the number of characters  of the key that was possible to process: if the returned integer  is the same as 'len', then it means that the node corresponding to the  string was found (however it may not be a key in case the node->iskey is  zero or if simply we stopped in the middle of a compressed node, so that  'splitpos' is non zero).",1,0,0,1
5069,"Otherwise if the returned integer is not the same as 'len', there was an  early stop during the tree walk because of a character mismatch.",1,0,0,1
5070,The node where the search ended (because the full string was processed  or because there was an early stop) is returned by reference as  'stopnode' if the passed pointer is not NULL.,1,0,0,1
5071,This node link in the  parent's node is returned as 'plink' if not NULL.,0,0,0,0
5072,"Finally, if the  search stopped in a compressed node, 'splitpos' returns the index  inside the compressed node where the search ended.",1,0,0,1
5073,This is useful to  know where to split the node for insertion.,1,0,0,1
5074, Position in the string.,0,1,0,1
5075, Position in the node children (or bytes if compressed).,0,1,0,1
5076," Even when h->size is large, linear scan provides good              performances compared to other approaches that are in theory              more sounding, like performing a binary search.",1,0,0,1
5077, Save stack of parent nodes.,0,0,0,0
5078, Compressed node only child is at index 0.,1,1,0,1
5079, If the new node is compressed and we do not                  iterate again (since i == l) set the split                  position to 0 to signal this node represents                  the searched key.,1,0,0,1
5080," Insert the element 's' of size 'len', setting as auxiliary data  the pointer 'data'.",0,0,0,0
5081,"If the element is already present, the associated  data is updated, and 0 is returned, otherwise the element is inserted  and 1 is returned.",0,0,0,0
5082,"On out of memory the function returns 0 as well but  sets errno to ENOMEM, otherwise errno will be set to 0.",0,0,0,0
5083, Split position.,0,1,0,1
5084,"If raxLowWalk() stops in a compressed                  node, the index 'j' represents the char we stopped within the                  compressed node, that is, the position where to split the                  node for insertion.",0,0,0,0
5085, If i == len we walked following the whole string.,1,0,0,1
5086,"If we are not      in the middle of a compressed node, the string is either already      inserted or this middle node is currently not a key, but can represent      our key.",1,0,0,1
5087,We have just to reallocate the node and make space for the      data pointer.,0,0,0,0
5088, not in the middle if j is 0,0,0,0,0
5089, Element already exists.,0,1,0,1
5090, Element inserted.,0,1,0,1
5091," If the node we stopped at is a compressed node, we need to      split it before to continue.",0,0,0,0
5092,Splitting a compressed node have a few possibile cases.,1,0,0,1
5093,"Imagine that the node 'h' we are currently at is a compressed      node contaning the string ""ANNIBALE"" (it means that it represents      nodes A -> N -> N -> I -> B -> A -> L -> E with the only child      pointer of this node pointing at the 'E' node, because remember that      we have characters at the edges of the graph, not inside the nodes      themselves.",1,0,0,1
5094,"In order to show a real case imagine our node to also point to      another compressed node, that finally points at the node without      children, representing 'O':               ""ANNIBALE"" -> ""SCO"" -> []           When inserting we may face the following cases.",1,0,0,1
5095,"Note that all the cases      require the insertion of a non compressed node with exactly two      children, except for the last case which just requires splitting a      compressed node.",1,0,0,1
5096,"1) Inserting ""ANNIENTARE""                         |B| -> ""ALE"" -> ""SCO"" -> []          ""ANNI"" -> |-|                    |E| -> (... continue algo ...) ""NTARE"" -> []           2) Inserting ""ANNIBALI""                            |E| -> ""SCO"" -> []          ""ANNIBAL"" -> |-|                       |I| -> (... continue algo ...) []           3) Inserting ""AGO"" (Like case 1, but set iscompr = 0 into original node)                      |N| -> ""NIBALE"" -> ""SCO"" -> []          |A| -> |-|                 |G| -> (... continue algo ...) |O| -> []           4) Inserting ""CIAO""               |A| -> ""NNIBALE"" -> ""SCO"" -> []          |-|          |C| -> (... continue algo ...) ""IAO"" -> []           5) Inserting ""ANNI""               ""ANNI"" -> ""BALE"" -> ""SCO"" -> []           The final algorithm for insertion covering all the above cases is as      follows.",1,0,0,1
5097,"============================= ALGO 1 =============================           For the above cases 1 to 4, that is, all cases where we stopped in      the middle of a compressed node for a character mismatch, do:           Let $SPLITPOS be the zero-based index at which, in the      compressed node array of characters, we found the mismatching      character.",1,0,0,1
5098,"For example if the node contains ""ANNIBALE"" and we add      ""ANNIENTARE"" the $SPLITPOS is 4, that is, the index at which the      mismatching character is found.",0,0,0,0
5099,"Save the current compressed node $NEXT pointer (the pointer to the         child element, that is always present in compressed nodes).",1,0,0,1
5100,"Create ""split node"" having as child the non common letter         at the compressed node.",1,0,0,1
5101,"The other non common letter (at the key)         will be added later as we continue the normal insertion algorithm         at step ""6"".",1,0,0,1
5102,3a.,0,1,0,1
5103,"IF $SPLITPOS == 0:          Replace the old node with the split node, by copying the auxiliary          data if any.",1,0,0,1
5104,Fix parent's reference.,0,1,0,1
5105,Free old node eventually          (we still need its data for the next steps of the algorithm).,1,0,0,1
5106,3b.,0,1,0,1
5107,IF $SPLITPOS != 0:          Trim the compressed node (reallocating it as well) in order to          contain $splitpos characters.,0,0,0,0
5108,Change chilid pointer in order to link          to the split node.,0,0,0,0
5109,"If new compressed node len is just 1, set          iscompr to 0 (layout is the same).",1,0,0,1
5110,Fix parent's reference.,0,1,0,1
5111,4a.,0,1,0,1
5112,"IF the postfix len (the length of the remaining string of the          original compressed node after the split character) is non zero,          create a ""postfix node"".",1,0,0,1
5113,"If the postfix node has just one character          set iscompr to 0, otherwise iscompr to 1.",0,0,0,0
5114,Set the postfix node          child pointer to $NEXT.,0,0,0,0
5115,4b.,0,1,0,1
5116,"IF the postfix len is zero, just use $NEXT as postfix pointer.",0,0,0,0
5117,Set child[0] of split node to postfix node.,0,0,0,0
5118,"Set the split node as the current node, set current index at child[1]         and continue insertion algorithm as usually.",1,0,0,1
5119,"============================= ALGO 2 =============================           For case 5, that is, if we stopped in the middle of a compressed      node but no mismatch was found, do:           Let $SPLITPOS be the zero-based index at which, in the      compressed node array of characters, we stopped iterating because      there were no more keys character to match.",1,0,0,1
5120,"So in the example of      the node ""ANNIBALE"", addig the string ""ANNI"", the $SPLITPOS is 4.",0,0,0,0
5121,"Save the current compressed node $NEXT pointer (the pointer to the         child element, that is always present in compressed nodes).",1,0,0,1
5122,"Create a ""postfix node"" containing all the characters from $SPLITPOS         to the end.",0,0,0,0
5123,Use $NEXT as the postfix node child pointer.,0,0,0,0
5124,"If the postfix node length is 1, set iscompr to 0.",0,0,0,0
5125,Set the node as a key with the associated value of the new         inserted key.,1,0,0,1
5126,Trim the current node to contain the first $SPLITPOS characters.,1,1,0,1
5127,"As usually if the new node length is just 1, set iscompr to 0.",1,0,0,1
5128,Take the iskey  or  associated value as it was in the orignal node.,0,0,0,0
5129,Fix the parent's reference.,0,1,0,1
5130,Set the postfix node as the only child pointer of the trimmed         node created at step 1.,1,0,0,1
5131, ------------------------- ALGORITHM 1 ---------------------------,0,1,0,1
5132, 1: Save next pointer.,0,1,0,1
5133, Set the length of the additional nodes we will need.,0,1,0,1
5134, 2: Create the split node.,0,1,0,1
5135,"Also allocate the other nodes we'll need             ASAP, so that it will be simpler to handle OOM.",1,0,0,1
5136, OOM?,0,1,0,1
5137,Abort now that the tree is untouched.,0,1,0,1
5138, 3a: Replace the old node with the split node.,1,1,0,1
5139, 3b: Trim the compressed node.,0,1,0,1
5140, Set parentlink to splitnode parent.,0,0,0,0
5141, 4: Create the postfix node: what remains of the original          compressed node after the split.,1,0,0,1
5142, 4a: create a postfix node.,0,0,0,0
5143, 4b: just use next as postfix node.,0,0,0,0
5144, 5: Set splitnode first child as the postfix node.,1,0,0,1
5145,Continue insertion: this will cause the splitnode to          get a new child (the non common character at the currently          inserted key).,1,0,0,1
5146, ------------------------- ALGORITHM 2 ---------------------------,0,1,0,1
5147, Allocate postfix & trimmed nodes ASAP to fail for OOM gracefully.,1,0,0,1
5148, 1: Save next pointer.,0,1,0,1
5149, 2: Create the postfix node.,0,0,0,0
5150, 3: Trim the compressed node.,0,1,0,1
5151, Fix the trimmed node child pointer to point to          the postfix node.,0,0,0,0
5152, Finish!,0,1,0,1
5153,We don't need to contine with the insertion          algorithm for ALGO 2.,0,0,0,0
5154,The key is already inserted.,1,1,0,1
5155, Key inserted.,1,1,0,1
5156," We walked the radix tree as far as we could, but still there are left      chars in our string.",1,0,0,1
5157,We need to insert the missing nodes.,1,1,0,1
5158," If this node is going to have a single child, and there          are other characters, so that that would result in a chain          of single-childed nodes, turn it into a compressed node.",1,0,0,1
5159, Element inserted.,0,1,0,1
5160, This code path handles out of memory after part of the sub-tree was      already modified.,0,0,0,0
5161,"Set the node as a key, and then remove it.",1,1,0,1
5162,"However we      do that only if the node is a terminal node, otherwise if the OOM      happened reallocating a node in the middle, we don't need to free      anything.",1,0,0,1
5163, Compensate the next remove.,0,1,0,1
5164," Find a key in the rax, returns raxNotFound special void pointer value  if the item was not found, otherwise the value associated with the  item is returned.",1,0,0,1
5165," Return the memory address where the 'parent' node stores the specified  'child' pointer, so that the caller can update the pointer with another  one if needed.",0,0,0,0
5166,"The function assumes it will find a match, otherwise the  operation is an undefined behavior (it will continue scanning the  memory without any bound checking).",0,0,0,0
5167, Low level child removal from node.,1,1,0,1
5168,The new node pointer (after the child  removal) is returned.,1,0,0,1
5169,"Note that this function does not fix the pointer  of the parent node in its parent, so this task is up to the caller.",0,0,0,0
5170,The function never fails for out of memory.,1,1,0,1
5171," If parent is a compressed node (having a single child, as for definition      of the data structure), the removal of the child consists into turning      it into a normal node without children.",1,0,0,1
5172, Otherwise we need to scan for the children pointer and memmove()      accordingly.,0,0,0,0
5173,To start we seek the first element in both the children         pointers and edge bytes in the node.,1,0,0,1
5174,Search the child pointer to remove inside the array of children         pointers.,0,0,0,0
5175,Remove the edge and the pointer by memmoving the remaining children         pointer and edge bytes one position before.,0,0,0,0
5176," Since we have one data byte less, also child pointers start one byte      before now.",1,0,0,1
5177," Move the remaining ""tail"" pointer at the right position as well.",1,0,0,1
5178,Update size.,0,1,0,1
5179," realloc the node according to the theoretical memory usage, to free      data if we are over-allocating right now.",1,0,0,1
5180," Note: if rax_realloc() fails we just return the old address, which      is valid.",1,0,0,1
5181, Remove the specified item.,0,1,0,1
5182,"Returns 1 if the item was found and  deleted, 0 otherwise.",0,0,0,0
5183," If this node has no children, the deletion needs to reclaim the      no longer used nodes.",0,0,0,0
5184,"This is an iterative process that needs to      walk the three upward, deleting all the nodes with just one child      that are not keys, until the head of the rax is reached or the first      node with more than one child is found.",1,0,0,1
5185, Will be set to 1 if we should try to optimize the                            tree resulting from the deletion.,0,0,0,0
5186," If this node has more then one child, or actually holds               a key, stop here.",1,0,0,1
5187," If after the removal the node has just a single child              and is not a key, we need to try to compress it.",1,0,0,1
5188," If the node had just one child, after the removal of the key          further compression with adjacent nodes is pontentially possible.",1,0,0,1
5189, Don't try node compression if our nodes pointers stack is not      complete because of OOM while executing raxLowWalk(),1,0,0,1
5190," Recompression: if trycompress is true, 'h' points to a radix tree node      that changed in a way that could allow to compress nodes in this      sub-branch.",1,0,0,1
5191,"Compressed nodes represent chains of nodes that are not      keys and have a single child, so there are two deletion events that      may alter the tree so that further compression is needed:           1) A node with a single child was a key and now no longer is a key.",1,0,0,1
5192,2) A node with two children now has just one child.,0,1,0,1
5193,"We try to navigate upward till there are other nodes that can be      compressed, when we reach the upper node which is not a key and has      a single child, we scan the chain of children to collect the      compressable part of the tree, and replace the current node with the      new one, fixing the child pointer to reference the first non      compressable node.",1,0,0,1
5194,"Example of case ""1"".",0,0,0,0
5195,"A tree stores the keys ""FOO"" = 1 and      ""FOOBAR"" = 2:                ""FOO"" -> ""BAR"" -> [] (2)                (1)           After the removal of ""FOO"" the tree can be compressed as:           ""FOOBAR"" -> [] (2)                Example of case ""2"".",0,0,0,0
5196,"A tree stores the keys ""FOOBAR"" = 1 and      ""FOOTER"" = 2:                    |B| -> ""AR"" -> [] (1)      ""FOO"" -> |-|               |T| -> ""ER"" -> [] (2)           After the removal of ""FOOTER"" the resulting tree is:           ""FOO"" -> |B| -> ""AR"" -> [] (1)           That can be compressed into:           ""FOOBAR"" -> [] (1)",0,0,0,0
5197, Try to reach the upper node that is compressible.,0,1,0,1
5198,At the end of the loop 'h' will point to the first node we          can try to compress and 'parent' to its parent.,1,0,0,1
5199, Compression starting node.,1,1,0,1
5200, Scan chain of nodes we can compress.,0,1,0,1
5201, Stop here if going to the next node would result into              a compressed node larger than h->size can hold.,1,0,0,1
5202," If we can compress, create the new node and populate it.",1,1,0,1
5203," An out of memory here just means we cannot optimize this              node, but the tree is left in a consistent state.",1,0,0,1
5204," Scan again, this time to populate the new node content and              to fix the new node child pointer.",1,0,0,1
5205,At the same time we free              all the nodes that we'll no longer use.,1,0,0,1
5206," Now 'h' points to the first node that we still need to use,              so our new node child pointer will point to it.",1,0,0,1
5207, Fix parent link.,0,1,0,1
5208, This is the core of raxFree(): performs a depth-first scan of the  tree and releases all the nodes found.,0,0,0,0
5209," Free a whole radix tree, calling the specified callback in order to  free the auxiliary data.",1,0,0,1
5210, Free a whole radix tree.,1,0,0,1
5211, ------------------------------- Iterator ---------------------------------,0,1,0,1
5212, Initialize a Rax iterator.,0,0,0,0
5213,"This call should be performed a single time  to initialize the iterator, and must be followed by a raxSeek() call,  otherwise the raxPrev() or raxNext() functions will just return EOF.",1,0,0,1
5214, No crash if the iterator is not seeked.,0,0,0,0
5215, Append characters at the current key string of the iterator 'it'.,1,1,0,1
5216,"This  is a low level function used to implement the iterator, not callable by  the user.",1,0,0,1
5217,"Returns 0 on out of memory, otherwise 1 is returned.",0,1,0,1
5218, Use memmove since there could be an overlap between 's' and      it->key when we use the current key in order to re-seek.,1,0,0,1
5219, Remove the specified number of chars from the right of the current  iterator key.,1,0,0,1
5220, Do an iteration step towards the next element.,0,1,0,1
5221,At the end of the step the  iterator key will represent the (new) current key.,1,0,0,1
5222,"If it is not possible  to step in the specified direction since there are no longer elements, the  iterator is flagged with RAX_ITER_EOF.",1,0,0,1
5223,"If 'noup' is true the function starts directly scanning for the next  lexicographically smaller children, and the current node is already assumed  to be the parent of the last key node, so the first operation to go back to  the parent will be skipped.",1,0,0,1
5224,"This option is used by raxSeek() when  implementing seeking a non existing element with the "">"" or ""<"" options:  the starting node is not a key in that particular case, so we start the scan  from a node that does not represent the key set.",1,0,0,1
5225,The function returns 1 on success or 0 on out of memory.,1,1,0,1
5226," Save key len, stack items and the node where we are currently      so that on iterator EOF we can restore the current key and state.",1,0,0,1
5227," Seek the lexicographically smaller key in this subtree, which              is the first one found always going torwards the first child              of every successive node.",1,0,0,1
5228," For ""next"" step, stop every time we find a key along the              way, since the key is lexicograhically smaller compared to              what follows in the sub-children.",1,0,0,1
5229," If we finished exporing the previous sub-tree, switch to the              new one: go upper until a node is found where there are              children representing keys lexicographically greater than the              current key.",1,0,0,1
5230, Already on head?,0,1,0,1
5231,"Can't go up, iteration finished.",0,1,0,1
5232," If there are no children at the current node, try parent's                  next child.",1,0,0,1
5233, Adjust the current key to represent the node we are                  at.,1,0,0,1
5234, Try visiting the next child if there was at least one                  additional child.,1,0,0,1
5235, Seek the grestest key in the subtree at the current node.,1,0,0,1
5236,"Return 0 on  out of memory, otherwise 1.",0,0,0,0
5237,This is an helper function for different  iteration functions below.,1,0,0,1
5238, Like raxIteratorNextStep() but implements an iteration step moving  to the lexicographically previous element.,1,0,0,1
5239,The 'noup' option has a similar  effect to the one of raxIteratorPrevSte().,1,0,0,1
5240," Save key len, stack items and the node where we are currently      so that on iterator EOF we can restore the current key and state.",1,0,0,1
5241, Already on head?,0,1,0,1
5242,"Can't go up, iteration finished.",0,1,0,1
5243, Adjust the current key to represent the node we are          at.,1,0,0,1
5244, Try visiting the prev child if there is at least one          child.,1,0,0,1
5245," If we found a new subtree to explore in this node,              go deeper following all the last children in order to              find the key lexicographically greater.",1,0,0,1
5246, Enter the node we just found.,0,1,0,1
5247, Seek sub-tree max.,0,1,0,1
5248," Return the key: this could be the key we found scanning a new          subtree, or if we did not find a new subtree to explore here,          before giving up with this node, check if it's a key itself.",1,0,0,1
5249, Seek an iterator at the specified element.,0,1,0,1
5250,Return 0 if the seek failed for syntax error or out of memory.,1,1,0,1
5251,Otherwise  1 is returned.,0,0,0,0
5252,"When 0 is returned for out of memory, errno is set to  the ENOMEM value.",0,0,0,0
5253, Just resetting.,0,1,0,1
5254,Intialized by raxStart().,0,0,0,0
5255, Set flags according to the operator used to perform the seek.,0,1,0,1
5256, Error.,0,1,0,1
5257," If there are no elements, set the EOF condition immediately and      return.",0,0,0,0
5258, Seeking the first key greater or equal to the empty string          is equivalent to seeking the smaller key available.,1,0,0,1
5259, Find the greatest key taking always the last child till a          final node is found.,1,0,0,1
5260, We need to seek the specified key.,1,1,0,1
5261,"What we do here is to actually      perform a lookup, and later invoke the prev or next key code that      we already use for iteration.",1,0,0,1
5262, Return OOM on incomplete stack info.,0,1,0,1
5263," We found our node, since the key matches and we have an          ""equal"" condition.",1,0,0,1
5264, OOM.,0,1,0,1
5265, Exact key not found or eq flag not set.,1,0,0,1
5266,"We have to set as current          key the one represented by the node we stopped at, and perform          a next or prev operation to seek.",1,0,0,1
5267,"To reconstruct the key at this node          we start from the parent and go to the current node, accumulating          the characters found along the way.",1,0,0,1
5268, We need to set the iterator in the correct state to call next or prev          step in order to seek the desired element.,0,0,0,0
5269," If we stopped in the middle of a normal node because of a              mismatch, add the mismatching character to the current key              and call the iterator with the 'noup' flag so that it will try              to seek the next or prev child in the current node directly based              on the mismatching character.",1,0,0,1
5270, Ignore next call.,0,1,0,1
5271, In case of a mismatch within a compressed node.,0,1,0,1
5272," If the key the compressed node represents is greater                  than our seek element, continue forward, otherwise set the                  state in order to go back to the next sub-tree.",1,0,0,1
5273," If the key the compressed node represents is smaller                  than our seek element, seek the greater key in this                  subtree, otherwise set the state in order to go back to                  the previous sub-tree.",1,0,0,1
5274, Ignore next call.,0,1,0,1
5275," If there was no mismatch we are into a node representing the              key, (but which is not a key or the seek operator does not              include 'eq'), or we stopped in the middle of a compressed node              after processing all the key.",1,0,0,1
5276,Cotinue iterating as this was              a legitimate key we stopped at.,1,0,0,1
5277, Ignore next call.,0,1,0,1
5278, If we are here just eq was set but no match was found.,0,0,0,0
5279, Go to the next element in the scope of the iterator 'it'.,0,1,0,1
5280,"If EOF (or out of memory) is reached, 0 is returned, otherwise 1 is  returned.",0,0,0,0
5281,"In case 0 is returned because of OOM, errno is set to ENOMEM.",0,0,0,0
5282, Go to the previous element in the scope of the iterator 'it'.,1,1,0,1
5283,"If EOF (or out of memory) is reached, 0 is returned, otherwise 1 is  returned.",0,0,0,0
5284,"In case 0 is returned because of OOM, errno is set to ENOMEM.",0,0,0,0
5285, Perform a random walk starting in the current position of the iterator.,1,1,0,1
5286,Return 0 if the tree is empty or on out of memory.,1,1,0,1
5287,Otherwise 1 is returned  and the iterator is set to the node reached after doing a random walk  of 'steps' steps.,1,0,0,1
5288,"If the 'steps' argument is 0, the random walk is performed  using a random number of steps between 1 and two times the logarithm of  the number of elements.",1,0,0,1
5289,"NOTE: if you use this function to generate random elements from the radix  tree, expect a disappointing distribution.",1,0,0,1
5290,"A random walk produces good  random elements if the tree is not sparse, however in the case of a radix  tree certain keys will be reported much more often than others.",1,0,0,1
5291,At least  this function should be able to expore every possible element eventually.,1,0,0,1
5292, Go up to parent.,0,1,0,1
5293, Select a random child.,1,1,0,1
5294, Compare the key currently pointed by the iterator to the specified  key according to the specified operator.,1,0,0,1
5295,"Returns 1 if the comparison is  true, otherwise 0 is returned.",1,0,0,1
5296, Syntax error.,0,1,0,1
5297, Handle ==,0,1,0,1
5298," Handle >, >=, <, <=",0,1,0,1
5299, Same prefix: longer wins.,1,1,0,1
5300, (cmp < 0),0,0,0,0
5301, Free the iterator.,1,1,0,1
5302, Return if the iterator is in an EOF state.,0,1,0,1
5303,"This happens when raxSeek()  failed to seek an appropriate element, so that raxNext() or raxPrev()  will return zero, or when an EOF condition was reached while iterating  with raxNext() and raxPrev().",1,0,0,1
5304, Return the number of elements inside the radix tree.,0,0,0,0
5305, ----------------------------- Introspection ------------------------------,0,1,0,1
5306, This function is mostly used for debugging and learning purposes.,1,1,0,1
5307,"It shows an ASCII representation of a tree on standard output, outling  all the nodes and the contained keys.",0,0,0,0
5308,"The representation is as follow:    ""foobar"" (compressed node)   [abc] (normal node with three children)   [abc]=0x12345678 (node is a key, pointing to value 0x12345678)   [] (a normal empty node)    Children are represented in new idented lines, each children prefixed by   the ""`-(x)"" string, where ""x"" is the edge byte.",1,0,0,1
5309,"[abc]    `-(a) ""ladin""    `-(b) [kj]    `-(c) []    However when a node has a single child the following representation   is used instead:    [abc] -> ""ladin"" -> []",1,0,0,1
5310, The actual implementation of raxShow().,1,0,0,1
5311," Note that 7 and 4 magic constants are the string length      of "" `-(x) "" and "" -> "" respectively.",1,0,0,1
5312," Show a tree, as outlined in the comment above.",1,1,0,1
5313, Used by debugnode() macro to show info about a given node.,0,0,0,0
5314, LZF compression library,0,1,0,1
5315, This is just a wrapper for the low level function rioRead() that will  automatically abort if it is not possible to read the specified amount  of bytes.,1,0,0,1
5316, Not reached.,0,1,0,1
5317," Load a ""type"" in RDB format, that is a one byte unsigned integer.",0,0,0,0
5318,"This function is not only used to load object types, but also special  ""types"" like the end-of-file type, the EXPIRE type, and so forth.",1,0,0,1
5319, Saves an encoded length.,0,1,0,1
5320,The first two bits in the first byte are used to  hold the encoding type.,1,0,0,1
5321,See the RDB_ definitions for more information  on the types of encoding.,1,0,0,1
5322, Save a 6 bit len,0,0,0,0
5323, Save a 14 bit len,0,0,0,0
5324, Save a 32 bit len,0,0,0,0
5325, Save a 64 bit len,0,0,0,0
5326, Load an encoded length.,0,1,0,1
5327,"If the loaded length is a normal length as stored  with rdbSaveLen(), the read length is set to 'lenptr'.",1,0,0,1
5328,"If instead the  loaded length describes a special encoding that follows, then 'isencoded'  is set to 1 and the encoding format is stored at 'lenptr'.",1,0,0,1
5329,See the RDB_ENC_ definitions in rdb.h for more information on special  encodings.,1,0,0,1
5330,"The function returns -1 on error, 0 on success.",1,1,0,1
5331, Read a 6 bit encoding type.,0,1,0,1
5332, Read a 6 bit len.,0,0,0,0
5333, Read a 14 bit len.,0,0,0,0
5334, Read a 32 bit len.,0,0,0,0
5335, Read a 64 bit len.,0,0,0,0
5336, Never reached.,0,1,0,1
5337," This is like rdbLoadLenByRef() but directly returns the value read  from the RDB stream, signaling an error by returning RDB_LENERR  (since it is a too large count to be applicable in any Redis data  structure).",1,0,0,1
5338," Encodes the ""value"" argument as integer when it fits in the supported ranges  for encoded types.",0,0,0,0
5339,"If the function successfully encodes the integer, the  representation is stored in the buffer pointer to by ""enc"" and the string  length is returned.",1,0,0,1
5340,Otherwise 0 is returned.,0,0,0,0
5341," Loads an integer-encoded object with the specified encoding type ""enctype"".",0,0,0,0
5342,"The returned value changes according to the flags, see  rdbGenerincLoadStringObject() for more info.",1,0,0,1
5343, anti-warning,0,0,0,0
5344," String objects in the form ""2391"" ""-100"" without any space and with a  range of values that can fit in an 8, 16 or 32 bit signed value can be  encoded as integers to save space",1,0,0,1
5345, Check if it's possible to encode this value as a number,1,1,0,1
5346, If the number converted back into a string is not identical      then it's not possible to encode the string as integer,1,0,0,1
5347, Data compressed!,0,1,0,1
5348,Let's save it on disk,0,1,0,1
5349, We require at least four bytes compression for this to be worth it,1,1,0,1
5350, Load an LZF compressed string in RDB format.,0,1,0,1
5351,The returned value  changes according to 'flags'.,0,0,0,0
5352,For more info check the  rdbGenericLoadStringObject() function.,1,0,0,1
5353, Allocate our target according to the uncompressed size.,0,1,0,1
5354, Load the compressed representation and uncompress it to target.,0,0,0,0
5355, Save a string object as [len][data] on disk.,0,0,0,0
5356,If the object is a string  representation of an integer value we try to save it in a special form,1,0,0,1
5357, Try integer encoding,0,1,0,1
5358, Try LZF compression - under 20 bytes it's unable to compress even      aaaaaaaaaaaaaaaaaa so skip it,1,0,0,1
5359," Return value of 0 means data can't be compressed, save the old way",1,1,0,1
5360, Store verbatim,0,1,0,1
5361, Save a long long value as either an encoded string or a string.,1,0,0,1
5362, Encode as string,0,1,0,1
5363, Like rdbSaveRawString() gets a Redis object instead.,0,0,0,0
5364," Avoid to decode the object, then encode it again, if the      object is already integer encoded.",0,0,0,0
5365," Load a string object from an RDB file according to flags:   RDB_LOAD_NONE (no flags): load an RDB object, unencoded.",0,0,0,0
5366,"RDB_LOAD_ENC: If the returned type is a Redis object, try to                encode it in a special way to be more memory                efficient.",1,0,0,1
5367,When this flag is passed the function                no longer guarantees that obj->ptr is an SDS string.,0,0,0,0
5368,RDB_LOAD_PLAIN: Return a plain string allocated with zmalloc()                  instead of a Redis object with an sds in it.,1,0,0,1
5369,RDB_LOAD_SDS: Return an SDS string instead of a Redis object.,0,0,0,0
5370,On I or O error NULL is returned.,0,1,0,1
5371, Save a double value.,0,1,0,1
5372,Doubles are saved as strings prefixed by an unsigned  8 bit integer specifying the length of the representation.,0,0,0,0
5373,This 8 bit integer has special values in order to specify the following  conditions:  253: not a number  254: + inf  255: - inf,1,0,0,1
5374, Check if the float is in a safe range to be casted into a          long long.,1,0,0,1
5375,We are assuming that long long is 64 bit here.,1,0,0,1
5376,Also we are assuming that there are no implementations around where          double has precision < 52 bit.,0,0,0,0
5377,Under this assumptions we test if a double is inside an interval          where casting to long long is safe.,1,0,0,1
5378,Then using two castings we          make sure the decimal part is zero.,1,0,0,1
5379,If all this is true we use          integer printing function that is much faster.,1,0,0,1
5380, For information about double serialization check rdbSaveDoubleValue(),0,0,0,0
5381," Saves a double for RDB 8 or greater, where IE754 binary64 format is assumed.",1,1,0,1
5382,"We just make sure the integer is always stored in little endian, otherwise  the value is copied verbatim from memory to disk.",1,0,0,1
5383,"Return -1 on error, the size of the serialized value on success.",1,1,0,1
5384, Loads a double from RDB 8 or greater.,1,1,0,1
5385,See rdbSaveBinaryDoubleValue() for  more info.,1,0,0,1
5386,"On error -1 is returned, otherwise 0.",0,1,0,1
5387, Like rdbSaveBinaryDoubleValue() but single precision.,1,0,0,1
5388, Like rdbLoadBinaryDoubleValue() but single precision.,1,0,0,1
5389," Save the object type of object ""o"".",0,0,0,0
5390, avoid warning,0,0,0,0
5391," Use rdbLoadType() to load a TYPE in RDB format, but returns -1 if the  type is not specifically a valid Object Type.",0,0,0,0
5392, This helper function serializes a consumer group Pending Entries List (PEL)  into the RDB file.,0,0,0,0
5393,"The 'nacks' argument tells the function if also persist  the informations about the not acknowledged message, or if to persist  just the IDs: this is useful because for the global consumer group PEL  we serialized the NACKs as well, but when serializing the local consumer  PELs we just add the ID, that will be resolved inside the global PEL to  put a reference to the same structure.",1,0,0,1
5394, Number of entries in the PEL.,0,1,0,1
5395, Save each entry.,0,1,0,1
5396," We store IDs in raw form as 128 big big endian numbers, like          they are inside the radix tree key.",1,0,0,1
5397," We don't save the consumer name: we'll save the pending IDs              for each consumer in the consumer PEL, and resolve the consumer              at loading time.",0,0,0,0
5398, Serialize the consumers of a stream consumer group into the RDB.,0,1,0,1
5399,Helper  function for the stream data type serialization.,0,0,0,0
5400,"What we do here is to  persist the consumer metadata, and it's PEL, for each consumer.",0,0,0,0
5401, Number of consumers in this consumer group.,0,1,0,1
5402, Save each consumer.,0,1,0,1
5403, Consumer name.,0,1,0,1
5404, Last seen time.,1,1,0,1
5405," Consumer PEL, without the ACKs (see last parameter of the function          passed with value of 0), at loading time we'll lookup the ID          in the consumer group global PEL and will put a reference in the          consumer local PEL.",1,0,0,1
5406, Save a Redis object.,0,0,0,0
5407,"Returns -1 on error, number of bytes written on success.",1,1,0,1
5408, Save a string value,0,1,0,1
5409, Save a list value,0,1,0,1
5410, Save a set value,0,1,0,1
5411, Save a sorted set value,0,1,0,1
5412," We save the skiplist elements from the greatest to the smallest              (that's trivial since the elements are already ordered in the              skiplist): this improves the load process, since the next loaded              element will always be the smaller, so adding to the skiplist              will always immediately stop at the head, making the insertion              O(1) instead of O(log(N)).",1,0,0,1
5413, Save a hash value,0,1,0,1
5414, Store how many listpacks we have inside the radix tree.,1,0,0,1
5415," Serialize all the listpacks inside the radix tree as they are,          when loading back, we'll use the first entry of each listpack          to insert it back into the radix tree.",1,0,0,1
5416, Save the number of elements inside the stream.,0,1,0,1
5417,"We cannot obtain          this easily later, since our macro nodes should be checked for          number of items: not a great CPU  or  space tradeoff.",1,0,0,1
5418, Save the last entry ID.,1,1,0,1
5419," The consumer groups and their clients are part of the stream          type, so serialize every consumer group.",0,0,0,0
5420, Save the number of groups.,0,1,0,1
5421, Serialize each consumer group.,0,1,0,1
5422, Save the group name.,0,1,0,1
5423, Last ID.,1,1,0,1
5424, Save the global PEL.,0,1,0,1
5425, Save the consumers of this group.,0,1,0,1
5426, Save a module-specific value.,0,1,0,1
5427," Write the ""module"" identifier as prefix, so that we'll be able          to call the right module during loading.",1,0,0,1
5428, Then write the module-specific representation + EOF marker.,0,1,0,1
5429, Return the length the object will have on disk if saved with  the rdbSaveObject() function.,0,0,0,0
5430,Currently we use a trick to get  this length with very little changes to the code.,1,0,0,1
5431,In the future  we could switch to a faster solution.,1,0,0,1
5432," Save a key-value pair, with expire time, type, key, value.",1,1,0,1
5433,On error -1 is returned.,0,1,0,1
5434,"On success if the key was actually saved 1 is returned, otherwise 0  is returned (the key was already expired).",1,0,0,1
5435, Save the expire time,0,0,0,0
5436, If this key is already expired skip it,1,0,0,1
5437, Save the LRU info.,0,1,0,1
5438, Using seconds is enough and requires less space.,1,1,0,1
5439, Save the LFU info.,0,1,0,1
5440," We can encode this in exactly two bytes: the opcode and an 8          bit counter, since the frequency is logarithmic with a 0-255 range.",1,0,0,1
5441,Note that we do not store the halving time because to reset it          a single time when loading does not affect the frequency much.,1,0,0,1
5442," Save type, key, value",1,1,0,1
5443, Save an AUX field.,0,1,0,1
5444, Wrapper for rdbSaveAuxField() used when key or val length can be obtained  with strlen().,1,0,0,1
5445, Wrapper for strlen(key) + integer type (up to long long range).,1,0,0,1
5446, Save a few default AUX fields with information about the RDB generated.,1,1,0,1
5447, Add a few fields about the state when the RDB was created.,1,1,0,1
5448, Handle saving options that generate aux fields.,0,1,0,1
5449, Produces a dump of the database in RDB format sending it to the specified  Redis I or O channel.,0,0,0,0
5450,"On success C_OK is returned, otherwise C_ERR  is returned and part of the output, or all the output, can be  missing because of I or O errors.",1,0,0,1
5451,"When the function returns C_ERR and if 'error' is not NULL, the  integer pointed by 'error' is set to the value of errno just after the I or O  error.",0,0,0,0
5452, Write the SELECT DB opcode,0,0,0,0
5453, Write the RESIZE DB opcode.,0,0,0,0
5454,"We trim the size to UINT32_MAX, which          is currently the largest type we are able to represent in RDB sizes.",1,0,0,1
5455,However this does not limit the actual size of the DB to load since          these sizes are just hints to resize the hash tables.,1,0,0,1
5456, Iterate this DB writing every entry,0,1,0,1
5457," When this RDB is produced as part of an AOF rewrite, move              accumulated diff from parent to child while rewriting in              order to have a smaller final write.",1,0,0,1
5458, So that we don't release it again on error.,0,0,0,0
5459," If we are storing the replication information on disk, persist      the script cache as well: on successful PSYNC after a restart, we need      to be able to process any EVALSHA inside the replication backlog the      master will send us.",1,0,0,1
5460, EOF opcode,0,0,0,0
5461, CRC64 checksum.,0,0,0,0
5462,"It will be zero if checksum computation is disabled, the      loading code skips the check in this case.",1,0,0,1
5463, This is just a wrapper to rdbSaveRio() that additionally adds a prefix  and a suffix to the generated RDB dump.,0,0,0,0
5464,The prefix is:   $EOF:<40 bytes unguessable hex string>\r\n   While the suffix is the 40 bytes hex string we announced in the prefix.,0,0,0,0
5465,This way processes receiving the payload can understand when it ends  without doing any processing of the content.,0,0,0,0
5466, Write error.,0,1,0,1
5467, Set 'error' only if not already set by rdbSaveRio() call.,1,0,0,1
5468, Save the DB on disk.,0,1,0,1
5469,"Return C_ERR on error, C_OK on success.",1,1,0,1
5470, Current working dir path for error messages.,1,0,0,1
5471, Make sure data will not remain on the OS's output buffers,1,1,0,1
5472, Use RENAME to make sure the DB file is changed atomically only      if the generate DB file is ok.,1,0,0,1
5473, Child,0,1,0,1
5474, Parent,0,1,0,1
5475, GB per second.,0,1,0,1
5476, unreached,0,0,0,0
5477, This function is called by rdbLoadObject() when the code is in RDB-check  mode and we find a module value of type 2 that can be parsed without  the need of the actual module.,1,0,0,1
5478,"The value is parsed for errors, finally  a dummy redis object is returned just to conform to the API.",1,0,0,1
5479, Load a Redis object of the specified type from the specified file.,0,0,0,0
5480,"On success a newly allocated object is returned, otherwise NULL.",1,1,0,1
5481, Read string value,0,1,0,1
5482, Read list value,0,1,0,1
5483, Load every single element of the list,1,1,0,1
5484, Read Set value,0,1,0,1
5485, Use a regular set when there are too many entries.,1,1,0,1
5486, It's faster to expand the dict to the right size asap in order              to avoid rehashing,1,0,0,1
5487, Load every single element of the set,1,1,0,1
5488, Fetch integer value from element.,0,1,0,1
5489, This will also be called when the set was just converted              to a regular hash table encoded set.,1,0,0,1
5490, Read list or set value.,0,1,0,1
5491, Load every single element of the sorted set.,1,1,0,1
5492, Don't care about integer-encoded strings.,0,1,0,1
5493," Convert after loading, since sorted sets are not stored ordered.",0,1,0,1
5494, Too many entries?,1,1,0,1
5495,Use a hash table.,0,1,0,1
5496, Load every field and value into the ziplist,0,0,0,0
5497, Load raw strings,1,1,0,1
5498, Add pair to ziplist,0,0,0,0
5499, Convert to hash table if size threshold is exceeded,0,1,0,1
5500, Load remaining fields and values into the hash table,0,1,0,1
5501, Load encoded strings,0,1,0,1
5502, Add pair to hash table,0,1,0,1
5503, All pairs should be read by now,0,1,0,1
5504, Obj type fixed below.,1,1,0,1
5505," Fix the object encoding, and make sure to convert the encoded          data type into the base type if accordingly to the current          configuration there are too many elements in the encoded data          type.",1,0,0,1
5506,Note that we only check the length and not max element          size as this is an O(N) scan.,1,0,0,1
5507,Eventually everything will get          converted.,0,0,0,0
5508, Convert to ziplist encoded hash.,0,0,0,0
5509,This must be deprecated                  when loading dumps created by Redis 2.4 gets deprecated.,0,0,0,0
5510," Get the master ID, the one we'll use as key of the radix tree              node: the entries inside the listpack itself are delta-encoded              relatively to this ID.",1,0,0,1
5511, Load the listpack.,0,0,0,0
5512," Serialized listpacks should never be empty, since on                  deletion we should remove the radix tree key if the                  resulting listpack is emtpy.",1,0,0,1
5513, Insert the key in the radix tree.,1,0,0,1
5514, Load total number of items inside the stream.,1,1,0,1
5515, Load the last entry ID.,1,1,0,1
5516, Consumer groups loading,0,1,0,1
5517, Get the consumer group name and ID.,0,1,0,1
5518,We can then create the              consumer group ASAP and populate its structure as              we read more data.,1,0,0,1
5519," Load the global PEL for this consumer group, however we'll              not yet populate the NACK structures with the message              owner, since consumers for this group and their messages will              be read as a next step.",0,0,0,0
5520,So for now leave them not resolved              and later populate it.,0,0,0,0
5521," Now that we loaded our global PEL, we need to load the              consumers and their local PELs.",0,0,0,0
5522, Load the PEL about entries owned by this specific                  consumer.,1,0,0,1
5523," Set the NACK consumer, that was left to NULL when                      loading the global PEL.",0,0,0,0
5524,Then set the same shared                      NACK structure also in the consumer-specific PEL.,1,0,0,1
5525, Call the rdb_load method of the module providing the 10 bit          encoding version in the lower 10 bits of the module ID.,0,0,0,0
5526, Module v2 serialization has an EOF mark at the end.,0,1,0,1
5527, Mark that we are loading in the global state and setup the fields  needed to provide loading stats.,0,0,0,0
5528, Load the DB,0,1,0,1
5529, Refresh the loading progress info,0,1,0,1
5530, Loading finished,0,1,0,1
5531, Track loading progress in order to serve client's from time to time   and if needed calculate rdb checksum,0,0,0,0
5532, The DB can take some non trivial amount of time to load.,0,1,0,1
5533,Update          our cached time since it is used to create and update the last          interaction time with clients and for other important things.,1,0,0,1
5534, Load an RDB file from the rio stream 'rdb'.,0,0,0,0
5535,"On success C_OK is returned,  otherwise C_ERR is returned and 'errno' is set accordingly.",1,0,0,1
5536," Key-specific attributes, set by opcodes before the key type.",1,0,0,1
5537, Read type.,0,1,0,1
5538, Handle special types.,1,1,0,1
5539, EXPIRETIME: load an expire associated with the next key              to load.,1,0,0,1
5540,"Note that after loading an expire we need to              load the actual type, and continue.",1,0,0,1
5541, Read next opcode.,0,0,0,0
5542, EXPIRETIME_MS: milliseconds precision expire times introduced              with RDB v3.,0,0,0,0
5543,Like EXPIRETIME but no with more precision.,1,0,0,1
5544, Read next opcode.,0,0,0,0
5545, FREQ: LFU frequency.,0,1,0,1
5546, Read next opcode.,0,0,0,0
5547, IDLE: LRU idle time.,0,1,0,1
5548, Read next opcode.,0,0,0,0
5549," EOF: End of file, exit the main loop.",1,1,0,1
5550, SELECTDB: Select the specified database.,0,1,0,1
5551, Read next opcode.,0,0,0,0
5552," RESIZEDB: Hint about the size of the keys in the currently              selected data base, in order to avoid useless rehashing.",1,0,0,1
5553, Read next opcode.,0,0,0,0
5554, AUX: generic string-string fields.,0,1,0,1
5555,Use to add state to RDB              which is backward compatible.,0,0,0,0
5556,Implementations of RDB loading              are requierd to skip AUX fields they don't understand.,0,0,0,0
5557,An AUX field is composed of two strings: key and value.,1,1,0,1
5558, All the fields with a name staring with '%' are considered                  information fields and are logged at startup with a log                  level of NOTICE.,0,0,0,0
5559, Load the script back in memory.,0,1,0,1
5560," We ignore fields we don't understand, as by AUX field                  contract.",0,0,0,0
5561, Read type again.,0,1,0,1
5562," This is just for compatibility with the future: we have plans              to add the ability for modules to store anything in the RDB              file, like data that is not related to the Redis key space.",1,0,0,1
5563,Such data will potentially be stored both before and after the              RDB keys-values section.,1,0,0,1
5564,"For this reason since RDB version 9,              we have the ability to read a MODULE_AUX opcode followed by an              identifier of the module, and a serialized value in ""MODULE V2""              format.",0,0,0,0
5565, Unknown module.,1,1,0,1
5566, This version of Redis actually does not know what to do                  with modules AUX data...,1,0,0,1
5567, RDB check mode.,0,1,0,1
5568, Read key,1,1,0,1
5569, Read value,0,1,0,1
5570, Check if the key already expired.,1,1,0,1
5571,"This function is used when loading          an RDB file from disk, either at startup, or when an RDB was          received from the master.",0,0,0,0
5572,"In the latter case, the master is          responsible for key expiry.",1,0,0,1
5573,"If we would expire keys here, the          snapshot taken by the master may not be reflected on the slave.",0,0,0,0
5574, Add the new object in the hash table,1,1,0,1
5575, Set the expire time if needed,0,0,0,0
5576, LRU idle time loaded from RDB is in seconds.,0,1,0,1
5577,"Scale                  according to the LRU clock resolution this Redis                  instance was compiled with (normaly 1000 ms, so the                  below statement will expand to lru_idle1000 or 1000.",0,0,0,0
5578," If the lru field overflows (since LRU it is a wrapping                  clock), the best we can do is to provide the maxium                  representable idle time.",1,0,0,1
5579, Decrement the key refcount since dbAdd() will take its              own reference.,1,0,0,1
5580," Reset the state that is key-specified and is populated by          opcodes before the key, so that we start from scratch again.",1,0,0,1
5581, Verify the checksum if RDB version is >= 5,0,0,0,0
5582, unexpected end of file is handled here with a fatal exit,1,0,0,1
5583, Just to avoid warning,0,1,0,1
5584, Like rdbLoadRio() but takes a filename instead of a rio stream.,0,0,0,0
5585,The  filename is open for reading and a rio stream object created in order  to do the actual loading.,1,0,0,1
5586,Moreover the ETA displayed in the INFO  output is initialized and finalized.,0,0,0,0
5587,"If you pass an 'rsi' structure initialied with RDB_SAVE_OPTION_INIT, the  loading code will fiil the information fields in the structure.",0,0,0,0
5588, A background saving child (BGSAVE) terminated its work.,0,1,0,1
5589,Handle this.,0,1,0,1
5590,This function covers the case of actual BGSAVEs.,1,0,0,1
5591," SIGUSR1 is whitelisted, so we have a way to kill a child without          tirggering an error conditon.",0,0,0,0
5592, Possibly there are slaves waiting for a BGSAVE in order to be served      (the first stage of SYNC is a bulk transfer of dump.rdb),1,0,0,1
5593, A background saving child (BGSAVE) terminated its work.,0,1,0,1
5594,Handle this.,0,1,0,1
5595,This function covers the case of RDB -> Salves socket transfers for  diskless replication.,0,0,0,0
5596," If the child returns an OK exit code, read the set of slave client      IDs and the associated status code.",1,0,0,1
5597,We'll terminate all the slaves      in error state.,0,0,0,0
5598,"If the process returned an error, consider the list of slaves that      can continue to be emtpy, so that it's just a special case of the      normal code path.",1,0,0,1
5599, Make space for the count.,0,1,0,1
5600, Make space for enough elements as specified by the first              uint64_t element in the array.,1,0,0,1
5601, We can continue the replication process with all the slaves that      correctly received the full payload.,1,0,0,1
5602,Others are terminated.,0,1,0,1
5603, Search for the slave ID in the reply.,0,1,0,1
5604,"In order for a slave to              continue the replication process, we need to find it in the list,              and it must have an error code set to 0 (which means success).",1,0,0,1
5605, Found in slaves list.,0,1,0,1
5606, Restore the socket as non-blocking.,0,1,0,1
5607," When a background RDB saving or transfer terminates, call the right handler.",1,1,0,1
5608, Spawn an RDB child that writes the RDB to the sockets of the slaves  that are currently in SLAVE_STATE_WAIT_BGSAVE_START state.,1,0,0,1
5609," Before to fork, create a pipe that will be used in order to      send back to the parent the IDs of the slaves that successfully      received all the writes.",1,0,0,1
5610," Collect the file descriptors of the slaves we want to transfer      the RDB to, which are i WAIT_BGSAVE_START state.",0,0,0,0
5611, We also allocate an array of corresponding client IDs.,0,1,0,1
5612,This will      be useful for the child process in order to build the report      (sent via unix pipe) that will be sent to the parent.,1,0,0,1
5613, Put the socket in blocking mode to simplify RDB transfer.,0,1,0,1
5614,We'll restore it when the children returns (since duped socket              will share the O_NONBLOCK attribute with the parent).,0,0,0,0
5615, Create the child process.,0,1,0,1
5616, Child,0,1,0,1
5617," If we are returning OK, at least one slave was served              with the RDB file as expected, so we need to send a report              to the parent via the pipe.",1,0,0,1
5618,"The format of the message is:                           <len> <slave[0].id> <slave[0].error> ...                           len, slave IDs, and slave errors, are all uint64_t integers,              so basically the reply is composed of 64 bits for the len field              plus 2 additional 64 bit integers for each entry, for a total              of 'len' entries.",1,0,0,1
5619,"The 'id' represents the slave's client ID, so that the master              can match the report with a specific slave, and 'error' is              set to 0 if the replication process terminated with a success              or the error code if an error occurred.",1,0,0,1
5620, Write the message to the parent.,0,1,0,1
5621,"If we have no good slaves or              we are unable to transfer the message to the parent, we exit              with an error so that the parent will abort the replication              process with all the childre that were waiting.",1,0,0,1
5622, Parent,0,1,0,1
5623, Undo the state change.,0,1,0,1
5624,"The caller will perform cleanup on              all the slaves in BGSAVE_START state, but an early call to              replicationSetupSlaveForFullResync() turned it into BGSAVE_END",1,0,0,1
5625, GB per second.,0,1,0,1
5626, Unreached.,0,0,0,0
5627, BGSAVE [SCHEDULE],0,1,0,1
5628, The SCHEDULE option changes the behavior of BGSAVE when an AOF rewrite      is in progress.,0,0,0,0
5629,Instead of returning an error a BGSAVE gets scheduled.,0,1,0,1
5630, Populate the rdbSaveInfo structure used to persist the replication  information inside the RDB file.,0,0,0,0
5631,"Currently the structure explicitly  contains just the currently selected DB from the master stream, however  if the rdbSave() family functions receive a NULL rsi structure also  the Replication ID or offset is not saved.",1,0,0,1
5632,"The function popultes 'rsi'  that is normally stack-allocated in the caller, returns the populated  pointer if the instance has a valid master client, otherwise NULL  is returned, and the RDB saving will not persist any replication related  information.",1,0,0,1
5633," If the instance is a master, we can populate the replication info      only when repl_backlog is not NULL.",1,0,0,1
5634,"If the repl_backlog is NULL,      it means that the instance isn't in any replication chains.",0,0,0,0
5635,"In this      scenario the replication info is useless, because when a slave      connects to us, the NULL repl_backlog will trigger a full      synchronization, at the same time we will use a new replid and clear      replid2.",1,0,0,1
5636," Note that when server.slaveseldb is -1, it means that this master          didn't apply any write commands after a full synchronization.",1,0,0,1
5637,"So we can let repl_stream_db be 0, this allows a restarted slave          to reload replication ID or offset, it's safe because the next write          command must generate a SELECT statement.",1,0,0,1
5638, If the instance is a slave we need a connected master      in order to fetch the currently selected DB.,1,0,0,1
5639," If we have a cached master we can use it in order to populate the      replication selected DB info inside the RDB file: the slave can      increment the master_repl_offset only from data arriving from the      master, so if we are disconnected the offset in the cached master      is valid.",1,0,0,1
5640, Use hiredis sds.,0,0,0,0
5641, Pointers to :rand: strings inside the command buf,0,0,0,0
5642, Number of pointers in client->randptr,0,0,0,0
5643, Number of unused pointers in client->randptr,0,0,0,0
5644, Bytes of 'obuf' already written,0,0,0,0
5645, Start time of a request,0,1,0,1
5646, Request latency,0,1,0,1
5647, Number of pending requests (replies to consume),0,1,0,1
5648," If non-zero, number of pending prefix commands.",0,1,0,1
5649,Commands                               such as auth and select are prefixed to the pipeline of                               benchmark commands and discarded after the first send.,1,0,0,1
5650, Size in bytes of the pending prefix commands,0,1,0,1
5651, Prototypes,0,1,0,1
5652, Implementation,0,1,0,1
5653, Calculate latency only for the first read event.,1,1,0,1
5654,This means that the      server already sent the reply and we need to parse it.,0,0,0,0
5655,"Parsing overhead      is not part of the latency, so calculate it only once, here.",1,0,0,1
5656, This is an OK for prefix commands such as auth and select.,1,0,0,1
5657, Discard prefix commands on first response.,1,1,0,1
5658, We also need to fix the pointers to the strings                         we need to randomize.,0,0,0,0
5659, Initialize request when nothing was written.,0,1,0,1
5660, Enforce upper bound to number of requests.,0,1,0,1
5661, Really initialize: randomize keys and set start time.,1,1,0,1
5662," Create a benchmark client, configured to send the command passed as 'cmd' of  'len' bytes.",0,0,0,0
5663,The command is copied N times in the client output buffer (that is reused  again and again to send the request to the server) accordingly to the configured  pipeline size.,0,0,0,0
5664,"Also an initial SELECT command is prepended in order to make sure the right  database is selected, if needed.",1,0,0,1
5665,The initial SELECT will be discarded as soon  as the first reply is received.,1,0,0,1
5666,"To create a client from scratch, the 'from' pointer is set to NULL.",0,1,0,1
5667,"If instead  we want to create a client using another client as reference, the 'from' pointer  points to the client to use as reference.",0,0,0,0
5668,In such a case the following  information is take from the 'from' client:   1) The command line to use.,1,0,0,1
5669,"2) The offsets of the __rand_int__ elements inside the command line, used     for arguments randomization.",0,0,0,0
5670,"Even when cloning another client, prefix commands are applied if needed.",0,1,0,1
5671, Suppress hiredis cleanup of unused buffers for max speed.,0,0,0,0
5672," Build the request buffer:      Queue N requests accordingly to the pipeline size, or simply clone      the example client buffer.",1,0,0,1
5673," Prefix the request buffer with AUTH and or or SELECT commands, if applicable.",0,0,0,0
5674,"These commands are discarded after the first response, so if the client is      reused the commands will not be used again.",1,0,0,1
5675," If a DB number different than zero is selected, prefix our request      buffer with the SELECT command, that will be discarded the first      time the replies are received, so if the client is reused the      SELECT command will not be used again.",1,0,0,1
5676, Append the request itself.,0,1,0,1
5677, Find substrings in the output buffer that need to be randomized.,0,0,0,0
5678, copy the offsets.,0,0,0,0
5679, Adjust for the different select prefix length.,1,1,0,1
5680," 12 is strlen(""__rand_int__).",0,0,0,0
5681, Listen backlog is quite limited on most systems,1,1,0,1
5682, Returns number of consumed options.,0,1,0,1
5683," We get the list of tests to run as a string in the form              get,set,lrange,...,test_N.",0,0,0,0
5684,"Then we add a comma before and              after the string in order to make sure that searching              for "",testname,"" will always get a match if the test is              enabled.",1,0,0,1
5685, Assume the user meant to provide an option when the arg starts              with a dash.,0,0,0,0
5686,We're done otherwise and should use the remainder              as the command and arguments for running the benchmark.,0,0,0,0
5687, every 250ms,0,0,0,0
5688," Return true if the named test was selected using the -t command line  switch, or if all the tests are selected (no -t passed by user).",1,0,0,1
5689, will never receive a reply,0,0,0,0
5690, and will wait for every,0,0,0,0
5691, Run benchmark with command in the remainder of the arguments.,0,1,0,1
5692, Run default benchmark suite.,0,1,0,1
5693, Increase length to also consume \r\n,0,1,0,1
5694, Stop if the loop did not finish,0,1,0,1
5695, This AOF file may have an RDB preamble.,0,1,0,1
5696,"Check this to start, and if this      is the case, start processing the RDB part.",0,0,0,0
5697, There must be at least room for the RDB header.,1,1,0,1
5698, Current key we are reading.,1,1,0,1
5699, Current key type if != -1.,1,1,0,1
5700, Number of keys processed.,0,1,0,1
5701, Number of keys with an expire.,0,0,0,0
5702, Number of keys already expired.,0,1,0,1
5703, The state while reading the RDB.,0,1,0,1
5704, True if error is populated.,1,1,0,1
5705," At every loading step try to remember what we were about to do, so that  we can log this information when an error is encountered.",0,0,0,0
5706, Show a few stats collected into 'rdbstate',1,0,0,1
5707, Called on RDB errors.,0,1,0,1
5708,Provides details about the RDB and the offset  we were when the error was detected.,0,0,0,0
5709, Print informations during RDB checking.,0,0,0,0
5710, Used inside rdb.c in order to log specific errors happening inside  the RDB loading internals.,1,0,0,1
5711," During RDB check we setup a special signal handler for memory violations  and similar conditions, so that we can log the offending part of the RDB  if the crash is due to broken content.",1,0,0,1
5712, Check the specified RDB file.,0,1,0,1
5713,"Return 0 if the RDB looks sane, otherwise  1 is returned.",0,0,0,0
5714,"The file is specified as a filename in 'rdbfilename' if 'fp' is not NULL,  otherwise the already open file 'fp' is checked.",1,0,0,1
5715, Pointed by global struct riostate.,0,0,0,0
5716, Read type.,0,1,0,1
5717, Handle special types.,1,1,0,1
5718, EXPIRETIME: load an expire associated with the next key              to load.,1,0,0,1
5719,"Note that after loading an expire we need to              load the actual type, and continue.",1,0,0,1
5720, Read next opcode.,0,0,0,0
5721, EXPIRETIME_MS: milliseconds precision expire times introduced              with RDB v3.,0,0,0,0
5722,Like EXPIRETIME but no with more precision.,1,0,0,1
5723, Read next opcode.,0,0,0,0
5724, FREQ: LFU frequency.,0,1,0,1
5725, Read next opcode.,0,0,0,0
5726, IDLE: LRU idle time.,0,1,0,1
5727, Read next opcode.,0,0,0,0
5728," EOF: End of file, exit the main loop.",1,1,0,1
5729, SELECTDB: Select the specified database.,0,1,0,1
5730, Read type again.,0,1,0,1
5731," RESIZEDB: Hint about the size of the keys in the currently              selected data base, in order to avoid useless rehashing.",1,0,0,1
5732, Read type again.,0,1,0,1
5733, AUX: generic string-string fields.,0,1,0,1
5734,Use to add state to RDB              which is backward compatible.,0,0,0,0
5735,Implementations of RDB loading              are requierd to skip AUX fields they don't understand.,0,0,0,0
5736,An AUX field is composed of two strings: key and value.,1,1,0,1
5737, Read type again.,0,1,0,1
5738, Read key,1,1,0,1
5739, Read value,0,1,0,1
5740, Check if the key already expired.,1,1,0,1
5741,"This function is used when loading          an RDB file from disk, either at startup, or when an RDB was          received from the master.",0,0,0,0
5742,"In the latter case, the master is          responsible for key expiry.",1,0,0,1
5743,"If we would expire keys here, the          snapshot taken by the master may not be reflected on the slave.",0,0,0,0
5744, Verify the checksum if RDB version is >= 5,0,0,0,0
5745, unexpected end of file is handled here with a fatal exit,1,0,0,1
5746," RDB check main: called form redis.c when Redis is executed with the  redis-check-rdb alias, on during RDB loading errors.",1,0,0,1
5747,"The function works in two ways: can be called with argc or argv as a  standalone executable, or called with a non NULL 'fp' argument if we  already have an open file to check.",1,0,0,1
5748,This happens when the function  is used to check an RDB preamble inside an AOF file.,0,0,0,0
5749,"When called with fp = NULL, the function never returns, but exits with the  status code according to success (RDB is sane) or error (RDB is corrupted).",1,0,0,1
5750,"Otherwise if called with a non NULL fp, the function returns C_OK or  C_ERR depending on the success or failure.",1,0,0,1
5751," In order to call the loading functions we need to create the shared      integer objects, however since this function may be called from      an already initialized Redis instance, check if we really need to.",1,0,0,1
5752," use sds.h from hiredis, so that only one set of sds functions will be present in the binary",1,0,0,1
5753, seconds,0,0,0,0
5754, seconds,0,0,0,0
5755, --latency-dist palettes.,0,1,0,1
5756, The actual palette in use.,1,1,0,1
5757, get last arg from stdin.,1,0,0,1
5758,(-x option),0,1,0,1
5759," output mode, see OUTPUT_ defines",0,0,0,0
5760, Ask for synchronous mode of the Lua debugger.,0,0,0,0
5761, Lua debugging session ended.,0,0,0,0
5762, Handle manual SCRIPT DEBUG + EVAL commands.,0,1,0,1
5763, User preferences.,0,1,0,1
5764,------------------------------------------------------------------------------  Utility functions ---------------------------------------------------------------------------,0,0,0,0
5765, Add [dbnum] if needed,0,0,0,0
5766, Return the name of the dotfile for the specified 'dotfilename'.,0,0,0,0
5767,Normally it just concatenates user $HOME to the file specified  in 'dotfilename'.,1,0,0,1
5768,"However if the environment varialbe 'envoverride'  is set, its value is taken as the path.",0,0,0,0
5769,"The function returns NULL (if the file is  or dev or null or cannot be  obtained for some error), or an SDS string that must be freed by  the user.",0,0,0,0
5770, Check the env for a dotfile override.,0,0,0,0
5771," If the env is set, return it.",0,0,0,0
5772, If no override is set use $HOME or <dotfilename>.,0,0,0,0
5773, URL-style percent decoding.,0,1,0,1
5774, Parse a URI and extract the server connection information.,0,1,0,1
5775,URI scheme is based on the the provisional specification[1] excluding support  for query parameters.,0,0,0,0
5776,"Valid URIs are:    scheme:    ""redis: or  or ""    authority: [<username> "":""] <password> ""@""] [<hostname> ["":"" <port>]]    path:      ["" or "" [<db>]]    [1]: https: or  or www.iana.org or assignments or uri-schemes or prov or redis",1,0,0,1
5777, URI must start with a valid scheme.,0,1,0,1
5778, Extract user info.,0,1,0,1
5779," If provided, username is ignored.",0,0,0,0
5780, Extract host and port.,0,1,0,1
5781, Extract database number.,0,1,0,1
5782,------------------------------------------------------------------------------  Help functions ---------------------------------------------------------------------------,0,0,0,0
5783, Only used for help on commands,1,1,0,1
5784, Add git commit and working tree status when available,1,1,0,1
5785, cliInitHelp() setups the helpEntries array with the command and group  names from the help.h file.,0,0,0,0
5786,"However the Redis instance we are connecting  to may support more commands, so this function integrates the previous  entries with additional entries obtained using the COMMAND command  available in recent versions of Redis.",1,0,0,1
5787, Scan the array reported by COMMAND and fill only the entries that      don't already match what we have.,1,0,0,1
5788, Output command help to stdout.,0,0,0,0
5789, Print generic help.,0,1,0,1
5790," Output all command help, filtering by group or command name.",0,1,0,1
5791, Compare all arguments,0,1,0,1
5792, Linenoise completion callback.,0,0,0,0
5793, Linenoise hints callback.,0,0,0,0
5794, Check if the argument list is empty and return ASAP.,1,1,0,1
5795, Remove arguments from the returned hint to show only the              ones the user did not yet typed.,1,0,0,1
5796, Add an initial space if needed.,0,1,0,1
5797,------------------------------------------------------------------------------  Networking  or  parsing ---------------------------------------------------------------------------,0,0,0,0
5798, Send AUTH command to the server,0,1,0,1
5799, Send SELECT dbnum to the server,0,0,0,0
5800, Connect to the server.,0,1,0,1
5801,If force is not zero the connection is performed  even if there is already a connected socket.,0,0,0,0
5802, Set aggressive KEEP_ALIVE socket option in the Redis context socket          in order to prevent timeouts caused by the execution of long          commands.,1,0,0,1
5803,At the same time this improves the detection of real          errors.,1,0,0,1
5804, Do AUTH and select the right DB.,1,1,0,1
5805, If you are producing output for the standard output we want         a more interesting output with quoted characters and so forth,1,0,0,1
5806, Calculate chars needed to represent the largest index,0,1,0,1
5807, Prefix for nested multi bulks should grow with idxlen+2 spaces,0,0,0,0
5808, Setup prefix format for every entry,0,1,0,1
5809," Don't use the prefix for the first element, as the parent                  caller already prepended the index number.",1,0,0,1
5810, Format the multi bulk entry,0,0,0,0
5811, Helper  function for sdsCatColorizedLdbReply() appending colorize strings  to an SDS string.,0,0,0,0
5812, Defaults to white.,0,1,0,1
5813, Colorize Lua debugger status replies according to the prefix they  have.,0,0,0,0
5814, Current line.,1,1,0,1
5815, Break point.,0,1,0,1
5816, Nothing...,0,1,0,1
5817, The Lua debugger replies with arrays of simple (status)              strings.,1,0,0,1
5818,We colorize the output for more fun if this              is a debugging session.,1,0,0,1
5819, Detect the end of a debugging session.,0,1,0,1
5820, Signal the caller session ended.,0,1,0,1
5821, Filter cases where we should reconnect,0,1,0,1
5822, avoid compiler warning,0,0,0,0
5823, Check if we need to connect to a different node and reissue the      request.,1,0,0,1
5824, Comments show the position of the pointer as:                   [S] for pointer 's'          [P] for pointer 'p',1,0,0,1
5825, MOVED[S]3999 127.0.0.1:6381,0,1,0,1
5826, MOVED[S]3999[P]127.0.0.1:6381,0,1,0,1
5827, MOVED 3999[P]127.0.0.1[S]6381,0,1,0,1
5828," In debugging mode, let's pass ""help"" to Redis.",0,0,0,0
5829," When the user manually calls SCRIPT DEBUG, setup the activation of      debugging mode on the next eval if needed.",0,0,0,0
5830, Actually activate LDB on EVAL if needed.,1,1,0,1
5831, Setup argument length,0,1,0,1
5832, Error = slaveMode lost connection to master,0,0,0,0
5833, Store database number when SELECT was successfully executed.,1,1,0,1
5834, Make it grep friendly,1,1,0,1
5835, Send a command reconnecting the link if needed.,0,1,0,1
5836, Cursor to left edge + clear line.,1,1,0,1
5837, Cursor to left edge + clear line.,1,1,0,1
5838,------------------------------------------------------------------------------  User interface ---------------------------------------------------------------------------,0,0,0,0
5839," Likely the command name, stop here.",1,1,0,1
5840, --ldb requires --eval.,0,0,0,0
5841, Turn the plain C strings into Sds strings,1,0,0,1
5842, If we still cannot send the command print error.,0,0,0,0
5843,We'll try to reconnect the next time.,0,1,0,1
5844, Issue the command again if we got redirected in cluster mode,0,1,0,1
5845, Split the user provided command into multiple SDS arguments.,0,1,0,1
5846,"This function normally uses sdssplitargs() from sds.c which is able  to understand ""quoted strings"", escapes and so forth.",1,0,0,1
5847,"However when  we are in Lua debugging mode and the ""eval"" command is used, we want  the remaining Lua script (after ""e "" or ""eval "") to be passed verbatim  as a single big argument.",1,0,0,1
5848," ""e "" or ""eval ""?",0,0,0,0
5849, Set the CLI preferences.,0,1,0,1
5850,"This function is invoked when an interactive  "":command"" is called, or when reading ~ or .redisclirc file, in order to  set user preferences.",0,0,0,0
5851, Load the ~ or .redisclirc file if any.,0,0,0,0
5852," Initialize the help and, if possible, use the COMMAND command in order      to retrieve missing entries.",1,0,0,1
5853, Only use history and load the rc file when stdin is a tty.,1,0,0,1
5854,keep in-memory history always regardless if history file can be determined,0,0,0,0
5855, Return to evalMode to restart the session.,0,0,0,0
5856," If our debugging session ended, show the EVAL final                      reply.",1,0,0,1
5857, Free the argument vector,1,1,0,1
5858, linenoise() returns malloc-ed lines like readline(),0,0,0,0
5859,------------------------------------------------------------------------------  Eval mode ---------------------------------------------------------------------------,0,0,0,0
5860," Load the script from the file, as an sds string.",0,0,0,0
5861," If we are debugging a script, enable the Lua debugger.",0,0,0,0
5862, Create our argument vector,0,1,0,1
5863, Call it,0,1,0,1
5864," Save it, may be reverteed.",0,0,0,0
5865," If the debugging session ended immediately, there was an                  error compiling the script.",0,0,0,0
5866,Show it and don't enter                  the REPL at all.,0,0,0,0
5867, Return to the caller.,0,1,0,1
5868, Restart the session if repl() returned.,0,0,0,0
5869, Return to the caller.,0,1,0,1
5870,------------------------------------------------------------------------------  Latency and latency history modes ---------------------------------------------------------------------------,0,0,0,0
5871, milliseconds.,0,0,0,0
5872, milliseconds.,0,0,0,0
5873," Set a default for the interval in case of --latency option      with --raw, --csv or when it is redirected to non tty.",1,0,0,1
5874, We need to convert to milliseconds.,0,1,0,1
5875, Clear the line.,1,1,0,1
5876,------------------------------------------------------------------------------  Latency distribution mode -- requires 256 colors xterm ---------------------------------------------------------------------------,0,0,0,0
5877, milliseconds.,0,0,0,0
5878, Structure to store samples distribution.,0,1,0,1
5879, Max latency to fit into this interval (usec).,1,0,0,1
5880, Number of samples in this interval.,0,1,0,1
5881, Associated character in visualization.,0,1,0,1
5882, Helper function for latencyDistMode().,0,0,0,0
5883,Performs the spectrum visualization  of the collected samples targeting an xterm 256 terminal.,0,0,0,0
5884,"Takes an array of distsamples structures, ordered from smaller to bigger  'max' value.",1,0,0,1
5885,"Last sample max must be 0, to mean that it olds all the  samples greater than the previous one, and is also the stop sentinel.",1,0,0,1
5886,"""tot' is the total number of samples in the different buckets, so it  is the SUM(samples[i].conut) for i to 0 up to the max sample.",1,0,0,1
5887,As a side effect the function sets all the buckets count to 0.,0,0,0,0
5888, We convert samples into a index inside the palette      proportional to the percentage a given bucket represents.,0,0,0,0
5889,"This way intensity of the different parts of the spectrum      don't change relative to the number of requests, which avoids to      pollute the visualization with non-latency related info.",1,0,0,1
5890, Set foreground color to black.,1,1,0,1
5891, Last sample.,1,1,0,1
5892," Show the legend: different buckets values and colors meaning, so  that the spectrum is more easily readable.",1,0,0,1
5893," We use a mostly logarithmic scale, with certain linear intervals          which are more interesting than others, like 1-10 milliseconds          range.",1,0,0,1
5894, 0.01 ms,0,1,0,1
5895, 0.125 ms,0,1,0,1
5896, 0.25 ms,0,1,0,1
5897, 0.5 ms,0,1,0,1
5898, 1 ms,0,1,0,1
5899, 2 ms,0,1,0,1
5900, 3 ms,0,1,0,1
5901, 4 ms,0,1,0,1
5902, 5 ms,0,1,0,1
5903, 6 ms,0,1,0,1
5904, 7 ms,0,1,0,1
5905, 8 ms,0,1,0,1
5906, 9 ms,0,1,0,1
5907, 10 ms,0,1,0,1
5908, 20 ms,0,1,0,1
5909, 30 ms,0,1,0,1
5910, 40 ms,0,1,0,1
5911, 50 ms,0,1,0,1
5912, 0.1 s,0,1,0,1
5913, 0.2 s,0,1,0,1
5914, 0.3 s,0,1,0,1
5915, 0.4 s,0,1,0,1
5916, 0.5 s,0,1,0,1
5917, 1 s,0,1,0,1
5918, 2 s,0,1,0,1
5919, 4 s,0,1,0,1
5920, 8 s,0,1,0,1
5921, 16 s,0,1,0,1
5922, 30 s,0,1,0,1
5923, 1 minute,0,1,0,1
5924, > 1 minute,0,1,0,1
5925, Populate the relevant bucket.,1,1,0,1
5926, From time to time show the spectrum.,0,1,0,1
5927,------------------------------------------------------------------------------  Slave mode ---------------------------------------------------------------------------,0,0,0,0
5928, Sends SYNC and reads the number of bytes in the payload.,0,1,0,1
5929,Used both by  slaveMode() and getRDB().,0,0,0,0
5930, To start we need to send the SYNC command and return the payload.,0,1,0,1
5931,"The hiredis client lib does not understand this part of the protocol      and we don't want to mess with its buffers, so everything is performed      using direct low-level I or O.",1,0,0,1
5932, Send the SYNC command.,0,1,0,1
5933," Read $<payload>\r\n, making sure to read just up to ""\n""",1,0,0,1
5934, Discard the payload.,0,1,0,1
5935, Now we can use hiredis to read the incoming protocol.,0,0,0,0
5936,------------------------------------------------------------------------------  RDB transfer mode ---------------------------------------------------------------------------,0,0,0,0
5937," This function implements --rdb, so it uses the replication protocol in order  to fetch the RDB file from a remote server.",1,0,0,1
5938, Write to file.,0,1,0,1
5939, Close the file descriptor ASAP as fsync() may take time.,0,0,0,0
5940,------------------------------------------------------------------------------  Bulk import (pipe) mode ---------------------------------------------------------------------------,0,0,0,0
5941, Input and output buffers,0,1,0,1
5942, True once we consumed all the standard input.,1,1,0,1
5943, Special reply we recognize.,1,1,0,1
5944, Use non blocking I or O.,0,1,0,1
5945, Transfer raw protocol and read replies from the server at the same      time.,1,0,0,1
5946, Handle the readable state: we can read replies from the server.,0,1,0,1
5947, Read from socket and feed the hiredis reader.,0,0,0,0
5948, Consume replies.,0,1,0,1
5949, Check if this is the reply to our final ECHO                          command.,1,0,0,1
5950,If so everything was received                          from the server.,0,0,0,0
5951, Handle the writable state: we can send protocol to the server.,0,1,0,1
5952, Transfer current buffer to server.,1,1,0,1
5953, Can't accept more data.,1,1,0,1
5954," If buffer is empty, load from stdin.",1,0,0,1
5955," The ECHO sequence starts with a ""\r\n"" so that if there                          is garbage in the protocol we read from stdin, the ECHO                          will likely still be properly formatted.",1,0,0,1
5956,"CRLF is ignored by Redis, so it has no effects.",0,0,0,0
5957," Everything transferred, so we queue a special                          ECHO command that we can match in the replies                          to make sure everything was read from the server.",1,0,0,1
5958," Handle timeout, that is, we reached EOF, and we are not getting          replies from the server for a few seconds, nor the final ECHO is          received.",1,0,0,1
5959,------------------------------------------------------------------------------  Find big keys ---------------------------------------------------------------------------,1,0,0,1
5960, Handle any error conditions,0,1,0,1
5961, Validate our types are correct,0,1,0,1
5962, Update iterator,0,1,0,1
5963, Grab the number of keys and free our reply,1,1,0,1
5964, Pipeline TYPE commands,0,1,0,1
5965, Retrieve types,0,1,0,1
5966, Pipeline size commands,0,1,0,1
5967, Skip keys that were deleted,0,1,0,1
5968, Retreive sizes,0,0,0,0
5969, Skip keys that dissapeared between SCAN and TYPE,0,0,0,0
5970, Retreive size,0,0,0,0
5971, Theoretically the key could have been removed and              added as a different type between TYPE and SIZE,1,0,0,1
5972, Total keys pre scanning,1,0,0,1
5973, Status message,0,1,0,1
5974, New up sds strings to keep track of overall biggest per type,1,0,0,1
5975, SCAN loop,0,1,0,1
5976, Calculate approximate percentage completion,1,1,0,1
5977, Grab some keys and point to the keys array,0,1,0,1
5978, Reallocate our type and size array if we need to,0,1,0,1
5979, Retreive types and then sizes,0,0,0,0
5980, Now update our stats,0,1,0,1
5981, Keep track of biggest key name for this type,1,0,0,1
5982, Keep track of the biggest size for this type,0,1,0,1
5983, Update overall progress,0,1,0,1
5984, Sleep if we've been directed to do so,0,1,0,1
5985, We're done,0,1,0,1
5986," Output the biggest keys we found, for types we did find",0,1,0,1
5987, Free sds strings containing max keys,1,0,0,1
5988, Success!,1,1,0,1
5989, Pipeline OBJECT freq commands,0,1,0,1
5990, Retrieve freqs,0,0,0,0
5991, Total keys pre scanning,1,0,0,1
5992, Status message,0,1,0,1
5993, SCAN loop,0,1,0,1
5994, Calculate approximate percentage completion,1,1,0,1
5995, Grab some keys and point to the keys array,0,1,0,1
5996, Reallocate our freqs array if we need to,0,0,0,0
5997, Now update our stats,0,1,0,1
5998, Update overall progress,0,1,0,1
5999, Use eviction pool here,0,1,0,1
6000, Sleep if we've been directed to do so,0,1,0,1
6001, We're done,0,1,0,1
6002,------------------------------------------------------------------------------  Stats mode ---------------------------------------------------------------------------,0,0,0,0
6003," Return the specified INFO field from the INFO command output ""info"".",0,0,0,0
6004,"A new buffer is allocated for the result, that needs to be free'd.",1,1,0,1
6005,If the field is not found NULL is returned.,0,0,0,0
6006, Like the above function but automatically convert the result into  a long.,1,0,0,1
6007,On error (missing field) LONG_MIN is returned.,1,1,0,1
6008," Convert number of bytes into a human readable string of the form:  100B, 2G, 100M, 4K, and so forth.",1,0,0,1
6009, Bytes,0,1,0,1
6010, Keys,0,1,0,1
6011, Used memory,0,1,0,1
6012, Clients,0,1,0,1
6013, Blocked (BLPOPPING) Clients,0,1,0,1
6014, Requests,0,1,0,1
6015, Connections,0,1,0,1
6016, Children,0,1,0,1
6017,------------------------------------------------------------------------------  Scan mode ---------------------------------------------------------------------------,0,0,0,0
6018,------------------------------------------------------------------------------  LRU test mode ---------------------------------------------------------------------------,0,0,0,0
6019," Return an integer from min to max (both inclusive) using a power-law  distribution, depending on the value of alpha: the greater the alpha  the more bias towards lower values.",1,0,0,1
6020,With alpha = 6.2 the output follows the 80-20 rule where 20% of  the returned numbers will account for 80% of the frequency.,0,0,0,0
6021," Generates a key name among a set of lru_test_sample_size keys, using  an 80-20 distribution.",1,0,0,1
6022, 1000 milliseconds.,0,1,0,1
6023, Perform cycles of 1 second with 50% writes and 50% reads.,0,1,0,1
6024,We use pipelining batching writes  or  reads N times per cycle in order          to fill the target instance easily.,1,0,0,1
6025, Write cycle.,0,1,0,1
6026, Read cycle.,0,1,0,1
6027, Print stats.,0,1,0,1
6028,#NAME?,0,0,0,0
6029,Measure max latency of a running process that does not result from  syscalls.,0,0,0,0
6030,Basically this software should provide an hint about how much  time the kernel leaves the process without a chance to run.,1,0,0,1
6031, This is just some computation the compiler can't optimize out.,0,1,0,1
6032,Should run in less than 100-200 microseconds even using very  slow hardware.,1,0,0,1
6033,Runs in less than 10 microseconds in modern HW.,1,1,0,1
6034, Reporting,0,1,0,1
6035,------------------------------------------------------------------------------  Program main() ---------------------------------------------------------------------------,1,0,0,1
6036, Latency mode,0,1,0,1
6037, Latency distribution mode,0,1,0,1
6038, Slave mode,0,1,0,1
6039, Get RDB mode.,0,1,0,1
6040, Pipe mode,0,1,0,1
6041, Find big keys,1,1,0,1
6042, Find hot keys,1,1,0,1
6043, Stat mode,0,1,0,1
6044, Scan mode,0,1,0,1
6045, LRU test mode,0,1,0,1
6046, Intrinsic latency mode,0,1,0,1
6047, Start interactive mode when no command is provided,0,1,0,1
6048, Ignore SIGPIPE in interactive mode to force a reconnect,0,0,0,0
6049, Note that in repl mode we don't abort on connection error.,0,0,0,0
6050,A new attempt will be performed for every command send.,1,1,0,1
6051," Otherwise, we have some arguments to execute",0,1,0,1
6052," Every time the Redis Git SHA1 or Dirty status changes only this small  file is recompiled, as we access this information in all the other  files using this functions.",1,0,0,1
6053, --------------------------- Utility functions ----------------------------,0,1,0,1
6054, Return the pointer to a string representing the slave ip:listening_port  pair.,0,0,0,0
6055,"Mostly useful for logging, since we want to log a slave using its  IP address and its listening port which is more clear for the user, for  example: ""Closing connection with slave 10.1.2.3:6380"".",1,0,0,1
6056, Note that the 'ip' buffer is always larger than 'c->slave_ip',1,0,0,1
6057, ---------------------------------- MASTER --------------------------------,0,1,0,1
6058," We don't have any data inside our buffer, but virtually the first      byte we have is the next byte that will be generated for the      replication stream.",1,0,0,1
6059, This function is called when the user modifies the replication backlog  size at runtime.,0,0,0,0
6060,"It is up to the function to both update the  server.repl_backlog_size and to resize the buffer and setup it so that  it contains the same data as the previous one (possibly less data, but  the most recent bytes, or the same data and more free space in case the  buffer is enlarged).",1,0,0,1
6061, What we actually do is to flush the old buffer and realloc a new          empty one.,1,0,0,1
6062,It will refill with new data incrementally.,1,1,0,1
6063,The reason is that copying a few gigabytes adds latency and even          worse often we need to alloc additional space before freeing the          old buffer.,1,0,0,1
6064, Next byte we have is... the next since the buffer is empty.,1,1,0,1
6065, Add data to the replication backlog.,0,1,0,1
6066,"This function also increments the global replication offset stored at  server.master_repl_offset, because there is no case where we want to feed  the backlog without incrementing the offset.",0,0,0,0
6067," This is a circular buffer, so write as much data we can at every      iteration and rewind the ""idx"" index if we reach the limit.",1,0,0,1
6068, Set the offset of the first byte we have in the backlog.,1,1,0,1
6069, Wrapper for feedReplicationBacklog() that takes Redis string objects  as input.,0,0,0,0
6070," Propagate write commands to slaves, and populate the replication backlog  as well.",0,0,0,0
6071,This function is used if the instance is a master: we use  the commands received by our clients in order to create the replication  stream.,0,0,0,0
6072,"Instead if the instance is a slave and has sub-slaves attached,  we use replicationFeedSlavesFromMaster()",0,0,0,0
6073," If the instance is not a top level master, return ASAP: we'll just proxy      the stream of data we receive from our master instead, in order to      propagate identical replication stream.",1,0,0,1
6074,In this way this slave can      advertise the same replication ID as the master (since it shares the      master replication history and has the same backlog and offsets).,1,0,0,1
6075," If there aren't slaves, and there is no backlog buffer to populate,      we can return ASAP.",0,0,0,0
6076, We can't have slaves attached and no backlog.,0,1,0,1
6077, Send SELECT command to every slave if needed.,0,1,0,1
6078, For a few DBs we have pre-computed SELECT command.,1,0,0,1
6079, Add the SELECT command into the backlog.,0,1,0,1
6080, Send it to slaves.,0,1,0,1
6081, Write the command to the replication backlog if any.,0,1,0,1
6082, Add the multi bulk reply length.,0,0,0,0
6083," We need to feed the buffer with the object as a bulk reply              not just as a plain string, so create the $..CRLF payload len              and add the final CRLF",1,0,0,1
6084, Write the command to every slave.,0,1,0,1
6085, Don't feed slaves that are still waiting for BGSAVE to start,0,1,0,1
6086," Feed slaves that are waiting for the initial SYNC (so these commands          are queued in the output buffer until the initial SYNC completes),          or are already in sync with the master.",0,0,0,0
6087, Add the multi bulk length.,0,0,0,0
6088, Finally any additional argument that was not stored inside the          static buffer if any (from j to argc).,1,0,0,1
6089, This function is used in order to proxy what we receive from our master  to our sub-slaves.,0,0,0,0
6090, Debugging: this is handy to see the stream sent from master      to slaves.,1,0,0,1
6091,Disabled with if(0).,1,1,0,1
6092, Don't feed slaves that are still waiting for BGSAVE to start,0,1,0,1
6093, Feed the slave 'c' with the replication backlog starting from the  specified 'offset' up to the end of the backlog.,1,0,0,1
6094, Compute the amount of bytes we need to discard.,0,1,0,1
6095," Point j to the oldest byte, that is actually our      server.repl_backlog_off byte.",1,0,0,1
6096, Discard the amount of data to seek to the specified 'offset'.,0,1,0,1
6097, Feed slave with data.,0,1,0,1
6098,Since it is a circular buffer we have to      split the reply in two parts if we are cross-boundary.,0,0,0,0
6099, Return the offset to provide as reply to the PSYNC command received  from the slave.,0,0,0,0
6100,The returned value is only valid immediately after  the BGSAVE process started and before executing any other command  from clients.,1,0,0,1
6101," Send a FULLRESYNC reply in the specific case of a full resynchronization,  as a side effect setup the slave for a full sync in different ways:   1) Remember, into the slave client structure, the replication offset     we sent here, so that if new slaves will later attach to the same     background RDB saving process (by duplicating this client output     buffer), we can get the right offset from this slave.",1,0,0,1
6102,2) Set the replication state of the slave to WAIT_BGSAVE_END so that     we start accumulating differences from this point.,0,0,0,0
6103,3) Force the replication stream to re-emit a SELECT statement so     the new slave incremental differences will start selecting the     right database number.,1,0,0,1
6104,"Normally this function should be called immediately after a successful  BGSAVE for replication was started, or when there is one already in  progress that we attached our slave to.",1,0,0,1
6105, We are going to accumulate the incremental changes for this      slave as well.,0,0,0,0
6106,Set slaveseldb to -1 in order to force to re-emit      a SELECT statement in the replication stream.,0,0,0,0
6107, Don't send this reply to slaves that approached us with      the old SYNC command.,1,0,0,1
6108, This function handles the PSYNC command from the point of view of a  master receiving a request for partial resynchronization.,1,0,0,1
6109,"On success return C_OK, otherwise C_ERR is returned and we proceed  with the usual full resync.",1,0,0,1
6110, Parse the replication offset asked by the slave.,0,1,0,1
6111,Go to full sync      on parse error: this should never happen but we try to handle      it in a robust way compared to aborting.,1,0,0,1
6112, Is the replication ID of this master the same advertised by the wannabe      slave via PSYNC?,1,0,0,1
6113,"If the replication ID changed this master has a      different replication history, and there is no way to continue.",1,0,0,1
6114,Note that there are two potentially valid replication IDs: the ID1      and the ID2.,1,0,0,1
6115,The ID2 however is only valid up to a specific offset.,1,1,0,1
6116," Run id ""?""",0,0,0,0
6117,is used by slaves that want to force a full resync.,1,0,0,1
6118, We still have the data our slave is asking for?,0,1,0,1
6119," If we reached this point, we are able to perform a partial resync:      1) Set client state to make it a slave.",1,0,0,1
6120,2) Inform the client we can continue with +CONTINUE      3) Send the backlog data (from the offset to the end) to the slave.,0,0,0,0
6121, We can't use the connection buffers since they are used to accumulate      new commands at this stage.,1,0,0,1
6122,But we are sure the socket send buffer is      empty so this write will never fail actually.,1,0,0,1
6123," Note that we don't need to set the selected DB at server.slaveseldb      to -1 to force the master to emit SELECT, since the slave already      has this state from the previous connection with the master.",1,0,0,1
6124," The caller can return, no full resync needed.",1,0,0,1
6125, We need a full resync for some reason...,1,0,0,1
6126,Note that we can't      reply to PSYNC right now if a full SYNC is needed.,1,0,0,1
6127,"The reply      must include the master offset at the time the RDB file we transfer      is generated, so we need to delay the reply to that moment.",0,0,0,0
6128," Start a BGSAVE for replication goals, which is, selecting the disk or  socket target depending on the configuration, and making sure that  the script cache is flushed before to start.",1,0,0,1
6129,"The mincapa argument is the bitwise AND among all the slaves capabilities  of the slaves waiting for this BGSAVE, so represents the slave capabilities  all the slaves support.",0,0,0,0
6130,Can be tested via SLAVE_CAPA_ macros.,0,1,0,1
6131,"Side effects, other than starting a BGSAVE:   1) Handle the slaves in WAIT_START state, by preparing them for a full     sync if the BGSAVE was succesfully started, or sending them an error     and dropping them from the list of slaves.",1,0,0,1
6132,2) Flush the Lua scripting script cache if the BGSAVE was actually     started.,1,0,0,1
6133,Returns C_OK on success or C_ERR otherwise.,1,1,0,1
6134," Only do rdbSave when rsiptr is not NULL,      otherwise slave will miss repl-stream-db.",1,0,0,1
6135," If we failed to BGSAVE, remove the slaves waiting for a full      resynchorinization from the list of salves, inform them with      an error about what happened, close the connection ASAP.",1,0,0,1
6136," If the target is socket, rdbSaveToSlavesSockets() already setup      the salves for a full resync.",1,0,0,1
6137,Otherwise for disk target do it now.,0,0,0,0
6138," Flush the script cache, since we need that slave differences are      accumulated without requiring slaves to match our cached scripts.",0,0,0,0
6139, SYNC and PSYNC command implemenation.,0,0,0,0
6140, ignore SYNC if already slave or in monitor mode,0,0,0,0
6141, Refuse SYNC requests if we are a slave but the link with our master      is not ok...,1,0,0,1
6142, SYNC can't be issued when the server has pending data to send to      the client about already issued commands.,0,0,0,0
6143,"We need a fresh reply      buffer registering the differences between the BGSAVE and the current      dataset, so that we can copy to other slaves if needed.",1,0,0,1
6144, Try a partial resynchronization if this is a PSYNC command.,1,0,0,1
6145,"If it fails, we continue with usual full resynchronization, however      when this happens masterTryPartialResynchronization() already      replied with:           +FULLRESYNC <replid> <offset>           So the slave knows the new replid and offset to try a PSYNC later      if the connection with the master is lost.",1,0,0,1
6146," No full resync needed, return.",1,0,0,1
6147," Increment stats for failed PSYNCs, but only if the              replid is not ""?",1,0,0,1
6148,""", as this is used by slaves to force a full              resync on purpose when they are not albe to partially              resync.",1,0,0,1
6149," If a slave uses SYNC, we are dealing with an old implementation          of the replication protocol (like redis-cli --slave).",1,0,0,1
6150,Flag the client          so that we don't expect to receive REPLCONF ACK feedbacks.,0,0,0,0
6151, Full resynchronization.,1,0,0,1
6152, Setup the slave as one waiting for BGSAVE to start.,0,1,0,1
6153,The following code      paths will change the state if we handle the slave differently.,1,0,0,1
6154, Non critical if it fails.,1,1,0,1
6155, Create the replication backlog if needed.,0,1,0,1
6156," When we create the backlog from scratch, we always use a new          replication ID and clear the ID2, since there is no valid          past history.",1,0,0,1
6157," CASE 1: BGSAVE is in progress, with disk target.",0,1,0,1
6158, Ok a background save is in progress.,1,0,0,1
6159,"Let's check if it is a good          one for replication, i.e.",1,0,0,1
6160,if there is another slave that is          registering differences since the server forked to save.,0,0,0,0
6161," To attach this slave, we check that it has at least all the          capabilities of the slave that triggered the current BGSAVE.",1,0,0,1
6162," Perfect, the server is already registering differences for              another slave.",1,0,0,1
6163,"Set the right state, and copy the buffer.",1,1,0,1
6164," No way, we need to wait for the next BGSAVE in order to              register differences.",0,0,0,0
6165," CASE 2: BGSAVE is in progress, with socket target.",0,1,0,1
6166, There is an RDB child process but it is writing directly to          children sockets.,1,0,0,1
6167,We need to wait for the next BGSAVE          in order to synchronize.,0,0,0,0
6168, CASE 3: There is no BGSAVE is progress.,0,1,0,1
6169, Diskless replication RDB child is created inside              replicationCron() since we want to delay its start a              few seconds to wait for more slaves to arrive.,1,0,0,1
6170," Target is disk (or the slave is not capable of supporting              diskless replication) and we don't have a BGSAVE in progress,              let's start one.",1,0,0,1
6171, REPLCONF <option> <value> <option> <value> ...,0,1,0,1
6172,This command is used by a slave in order to configure the replication  process before starting it with the SYNC command.,1,0,0,1
6173,"Currently the only use of this command is to communicate to the master  what is the listening port of the Slave redis instance, so that the  master can accurately list slaves and their listening ports in  the INFO output.",1,0,0,1
6174,In the future the same command can be used in order to configure  the replication to initiate an incremental replication instead of a  full resync.,1,0,0,1
6175, Number of arguments must be odd to make sure that every          option has a corresponding value.,1,0,0,1
6176, Process every option-value pair.,0,1,0,1
6177, Ignore capabilities not understood by this master.,0,1,0,1
6178, REPLCONF ACK is used by slave to inform the master the amount              of replication stream that it processed so far.,1,0,0,1
6179,It is an              internal only command that normal clients should never use.,1,0,0,1
6180," If this was a diskless replication, we need to really put              the slave online when the first ACK is received (which              confirms slave is online and ready to get more data).",1,0,0,1
6181, Note: this command does not reply anything!,0,1,0,1
6182, REPLCONF GETACK is used in order to request an ACK ASAP              to the slave.,0,0,0,0
6183," This function puts a slave in the online state, and should be called just  after a slave received the RDB file for the initial synchronization, and  we are finally ready to send the incremental stream of commands.",1,0,0,1
6184,It does a few things:   1) Put the slave in ONLINE state (useless when the function is called     because state is already ONLINE but repl_put_online_on_ack is true).,1,0,0,1
6185,"2) Make sure the writable event is re-installed, since calling the SYNC     command disables it, so that we can accumulate output buffer without     sending it to the slave.",1,0,0,1
6186,3) Update the count of good slaves.,1,1,0,1
6187, Prevent false timeout.,1,1,0,1
6188," Before sending the RDB file, we send the preamble as configured by the      replication process.",0,0,0,0
6189,"Currently the preamble is just the bulk count of      the file in the form ""$<length>\r\n"".",1,0,0,1
6190, fall through sending data.,0,0,0,0
6191," If the preamble was already transfered, send the RDB bulk data.",0,0,0,0
6192," This function is called at the end of every background saving,  or when the replication RDB transfer strategy is modified from  disk to socket or the other way around.",1,0,0,1
6193,"The goal of this function is to handle slaves waiting for a successful  background saving in order to perform non-blocking synchronization, and  to schedule a new BGSAVE if there are slaves that attached while a  BGSAVE was in progress, but it was not a good one for replication (no  other slave was accumulating differences).",1,0,0,1
6194,The argument bgsaveerr is C_OK if the background saving succeeded  otherwise C_ERR is passed to the function.,0,0,0,0
6195,The 'type' argument is the type of the child that terminated  (if it had a disk or socket target).,0,0,0,0
6196," If this was an RDB on disk save, we have to prepare to send              the RDB from disk to the slave socket.",0,0,0,0
6197,"Otherwise if this was              already an RDB -> Slaves socket transfer, used in the case of              diskless replication, our work is trivial, we can just put              the slave online.",0,0,0,0
6198, Note: we wait for a REPLCONF ACK message from slave in                  order to really put it online (install the write handler                  so that the accumulated data can be transfered).,1,0,0,1
6199,"However                  we change the replication state ASAP, since our slave                  is technically online now.",1,0,0,1
6200, Timeout otherwise.,0,1,0,1
6201," Change the current instance replication ID with a new, random one.",1,1,0,1
6202,"This will prevent successful PSYNCs between this master and other  slaves, so the command should be called when something happens that  alters the current story of the dataset.",1,0,0,1
6203, Clear (invalidate) the secondary replication ID.,1,1,0,1
6204,"This happens, for  example, after a full resynchronization, when we start a new replication  history.",1,0,0,1
6205," Use the current replication ID  or  offset as secondary replication  ID, and change the current one in order to start a new history.",1,0,0,1
6206,This should be used when an instance is switched from slave to master  so that it can serve PSYNC requests performed using the master  replication ID.,0,0,0,0
6207," We set the second replid offset to the master offset + 1, since      the slave will ask for the first byte it has not yet received, so      we need to add one to the offset: for example if, as a slave, we are      sure we have the same history as the master for 50 bytes, after we      are turned into a master, we can accept a PSYNC request with offset      51, since the slave asking has the same history up to the 50th      byte, and is asking for the new bytes starting at offset 51.",1,0,0,1
6208, ----------------------------------- SLAVE --------------------------------,0,1,0,1
6209," Returns 1 if the given replication state is a handshake state,  0 otherwise.",0,0,0,0
6210, Avoid the master to detect the slave is timing out while loading the  RDB file in initial synchronization.,0,0,0,0
6211,"We send a single newline character  that is valid protocol but is guaranteed to either be sent entierly or  not, since the byte is indivisible.",1,0,0,1
6212,"The function is called in two contexts: while we flush the current  data with emptyDb(), and while we load the new data received as an  RDB file from the master.",1,0,0,1
6213, Pinging back in this stage is best-effort.,0,1,0,1
6214, Callback used by emptyDb() while flushing away old data to load  the new dataset received by the master.,1,0,0,1
6215," Once we have a link with the master and the synchroniziation was  performed, this function materializes the master client we store  at server.master, starting from the specified file descriptor.",1,0,0,1
6216," If master offset is set to -1, this master is old and is not      PSYNC capable, so we flag it accordingly.",1,0,0,1
6217, Asynchronously read the SYNC payload we receive from a master,0,1,0,1
6218, 8 MB,0,1,0,1
6219," Static vars used to hold the EOF mark, and the last bytes received      form the server: when they match, we reached the end of the transfer.",1,0,0,1
6220, If repl_transfer_size == -1 we still have to read the bulk length      from the master reply.,0,0,0,0
6221, At this stage just a newline works as a PING in order to take              the connection live.,1,0,0,1
6222,So we refresh our last interaction              timestamp.,1,0,0,1
6223, There are two possible forms for the bulk payload.,1,1,0,1
6224,One is the          usual $<count> bulk format.,1,0,0,1
6225,The other is used for diskless transfers          when the master does not know beforehand the size of the file to          transfer.,1,0,0,1
6226,"In the latter case, the following format is used:                   $EOF:<40 bytes delimiter>                   At the end of the file the announced delimiter is transmitted.",1,0,0,1
6227,The          delimiter is long and random enough that the probability of a          collision with the actual file content can be ignored.,1,0,0,1
6228, Set any repl_transfer_size to avoid entering this code path              at the next call.,0,0,0,0
6229, Read bulk data,0,1,0,1
6230," When a mark is used, we want to detect EOF asap in order to avoid      writing the EOF mark into the file...",0,0,0,0
6231," Update the last bytes array, and check if it matches our delimiter.",1,1,0,1
6232, Delete the last 40 bytes from the file if we reached EOF.,1,1,0,1
6233," Sync data on disk from time to time, otherwise at the end of the transfer      we may suffer a big delay as the memory buffers are copied into the      actual disk.",1,0,0,1
6234, Check if the transfer is now complete,1,1,0,1
6235," We need to stop any AOFRW fork before flusing and parsing          RDB, otherwise we'll create a copy-on-write disaster.",0,0,0,0
6236," Before loading the DB into memory we need to delete the readable          handler, otherwise it will get called recursively since          rdbLoad() will call the event loop to process events from time to          time for non blocking loading.",0,0,0,0
6237," Re-enable the AOF if we disabled it earlier, in order to restore              the original configuration.",1,0,0,1
6238, Final setup of the connected slave <- master link,1,1,0,1
6239, After a full resynchroniziation we use the replication ID and          offset of the master.,1,0,0,1
6240,The secondary ID  or  offset are cleared since          we are starting a new history.,1,0,0,1
6241, Let's create the replication backlog if needed.,0,1,0,1
6242,"Slaves need to          accumulate the backlog regardless of the fact they have sub-slaves          or not, in order to behave correctly if they are promoted to          masters after a failover.",0,0,0,0
6243, Restart the AOF subsystem now that we finished the sync.,0,1,0,1
6244,"This          will trigger an AOF rewrite, and when done will start appending          to the new file.",1,0,0,1
6245, Send a synchronous command to the master.,0,1,0,1
6246,Used to send AUTH and  REPLCONF commands before starting the replication with SYNC.,1,0,0,1
6247,The command returns an sds string representing the result of the  operation.,0,0,0,0
6248,"On error the first byte is a ""-"".",1,0,0,1
6249," Create the command to send to the master, we use simple inline      protocol for simplicity as currently we only send simple strings.",1,0,0,1
6250, Transfer command to the server.,0,1,0,1
6251, Read the reply from the server.,0,1,0,1
6252, Try a partial resynchronization with the master if we are about to reconnect.,1,0,0,1
6253,"If there is no cached master structure, at least try to issue a  ""PSYNC ?",1,0,0,1
6254,"-1"" command in order to trigger a full resync using the PSYNC  command in order to obtain the master run id and the master replication  global offset.",1,0,0,1
6255,"This function is designed to be called from syncWithMaster(), so the  following assumptions are made:   1) We pass the function an already connected socket ""fd"".",1,0,0,1
6256,"2) This function does not close the file descriptor ""fd"".",0,0,0,0
6257,"However in case     of successful partial resynchronization, the function will reuse     'fd' as file descriptor of the server.master client structure.",1,0,0,1
6258,"The function is split in two halves: if read_reply is 0, the function  writes the PSYNC command on the socket, and a new function call is  needed, with read_reply set to 1, in order to read the reply of the  command.",1,0,0,1
6259,"This is useful in order to support non blocking operations, so  that we write, return into the event loop, and read when there are data.",1,0,0,1
6260,"When read_reply is 0 the function returns PSYNC_WRITE_ERR if there  was a write error, or PSYNC_WAIT_REPLY to signal we need another call  with read_reply set to 1.",0,0,0,0
6261,However even when read_reply is set to 1  the function may return PSYNC_WAIT_REPLY again to signal there were  insufficient data to read to complete its work.,1,0,0,1
6262,We should re-enter  into the event loop and wait in such a case.,1,0,0,1
6263,The function returns:   PSYNC_CONTINUE: If the PSYNC command succeded and we can continue.,0,0,0,0
6264,PSYNC_FULLRESYNC: If PSYNC is supported but a full resync is needed.,1,0,0,1
6265,In this case the master run_id and global replication                    offset is saved.,0,0,0,0
6266,PSYNC_NOT_SUPPORTED: If the server does not understand PSYNC at all and                       the caller should fall back to SYNC.,0,0,0,0
6267,PSYNC_WRITE_ERROR: There was an error writing the command to the socket.,0,1,0,1
6268,PSYNC_WAIT_REPLY: Call again the function with read_reply set to 1.,0,0,0,0
6269,PSYNC_TRY_LATER: Master is currently in a transient error condition.,1,1,0,1
6270,"Notable side effects:   1) As a side effect of the function call the function removes the readable     event handler from ""fd"", unless the return value is PSYNC_WAIT_REPLY.",1,0,0,1
6271,2) server.master_initial_offset is set to the right value according     to the master reply.,1,0,0,1
6272,This will be used to populate the 'server.master'     structure replication offset.,0,0,0,0
6273, Writing half,1,1,0,1
6274, Initially set master_initial_offset to -1 to mark the current          master run_id and offset as not valid.,1,0,0,1
6275,"Later if we'll be able to do          a FULL resync using the PSYNC command we'll set the offset at the          right value, so that this information will be propagated to the          client structure representing the master into server.master.",1,0,0,1
6276, Issue the PSYNC command,0,1,0,1
6277, Reading half,1,1,0,1
6278," The master may send empty newlines after it receives PSYNC          and before to reply, just to keep the connection alive.",1,0,0,1
6279," FULL RESYNC, parse the reply in order to extract the run id          and the replication offset.",1,0,0,1
6280," This is an unexpected condition, actually the +FULLRESYNC              reply means that the master supports PSYNC, but the reply              format seems wrong.",1,0,0,1
6281,To stay safe we blank the master              replid to make sure next PSYNCs will fail.,1,0,0,1
6282," We are going to full resync, discard the cached master structure.",1,0,0,1
6283, Partial resync was accepted.,1,0,0,1
6284, Check the new replication ID advertised by the master.,1,1,0,1
6285,"If it          changed, we need to set the new ID as primary ID, and set or          secondary ID as the old master ID up to the current offset, so          that our sub-slaves will be able to PSYNC with us after a          disconnection.",1,0,0,1
6286, Master ID changed.,0,1,0,1
6287," Set the old ID as our ID2, up to the current offset+1.",1,1,0,1
6288, Update the cached master ID and our own primary ID to the                  new one.,1,0,0,1
6289, Disconnect all the sub-slaves: they need to be notified.,0,1,0,1
6290, Setup the replication to continue.,0,1,0,1
6291," If this instance was restarted and we read the metadata to          PSYNC from the persistence file, our replication backlog could          be still not initialized.",0,0,0,0
6292,Create it.,0,1,0,1
6293," If we reach this point we received either an error (since the master does      not understand PSYNC or because it is in a special state and cannot      serve our request), or an unexpected reply from the master.",1,0,0,1
6294,"Return PSYNC_NOT_SUPPORTED on errors we don't understand, otherwise      return PSYNC_TRY_LATER if we believe this is a transient error.",0,0,0,0
6295," If it's not an error, log the unexpected event.",1,1,0,1
6296, This handler fires when the non blocking connect was able to  establish a connection with the master.,1,0,0,1
6297, If this event fired after the user turned the instance into a master      with SLAVEOF NO ONE we must just return ASAP.,0,0,0,0
6298, Check for errors in the socket: after a non blocking connect() we      may find that the socket is in error state.,0,0,0,0
6299, Send a PING to check the master is able to reply without errors.,1,1,0,1
6300, Delete the writable event so that the readable event remains          registered and we can wait for the PONG reply.,0,0,0,0
6301," Send the PING, don't check for errors at all, we have the timeout          that will take care about this.",0,0,0,0
6302, Receive the PONG command.,0,1,0,1
6303," We accept only two replies as valid, a positive +PONG reply          (we just check for ""+"") or an authentication error.",1,0,0,1
6304,"Note that older versions of Redis replied with ""operation not          permitted"" instead of using a proper error code, so we test          both.",1,0,0,1
6305, AUTH with the master if required.,0,1,0,1
6306, Receive AUTH reply.,0,1,0,1
6307," Set the slave port, so that Master's INFO command can list the      slave listening port correctly.",0,0,0,0
6308, Receive REPLCONF listening-port reply.,0,1,0,1
6309," Ignore the error if any, not all the Redis versions support          REPLCONF listening-port.",0,0,0,0
6310, Skip REPLCONF ip-address if there is no slave-announce-ip option set.,0,0,0,0
6311," Set the slave ip, so that Master's INFO command can list the      slave IP address port correctly in case of port forwarding or NAT.",0,0,0,0
6312, Receive REPLCONF ip-address reply.,0,0,0,0
6313," Ignore the error if any, not all the Redis versions support          REPLCONF listening-port.",0,0,0,0
6314, Inform the master of our (slave) capabilities.,0,1,0,1
6315,EOF: supports EOF-style RDB transfer for diskless replication.,0,0,0,0
6316,"PSYNC2: supports PSYNC v2, so understands +CONTINUE <new repl ID>.",0,0,0,0
6317,The master will ignore capabilities it does not understand.,0,1,0,1
6318, Receive CAPA reply.,0,1,0,1
6319," Ignore the error if any, not all the Redis versions support          REPLCONF capa.",0,0,0,0
6320, Try a partial resynchonization.,1,0,0,1
6321,"If we don't have a cached master      slaveTryPartialResynchronization() will at least try to use PSYNC      to start a full resynchronization so that we get the master run id      and the global offset, to try a partial resync at the next      reconnection attempt.",1,0,0,1
6322," If reached this point, we should be in REPL_STATE_RECEIVE_PSYNC.",0,1,0,1
6323, Try again later...,0,1,0,1
6324," If the master is in an transient error, we should try to PSYNC      from scratch later, so go to the error path.",0,0,0,0
6325,This happens when      the server is loading the dataset or is not connected with its      master and so forth.,0,0,0,0
6326," Note: if PSYNC does not return WAIT_REPLY, it will take care of      uninstalling the read handler from the file descriptor.",0,0,0,0
6327," PSYNC failed or is not supported: we want our slaves to resync with us      as well, if we have any sub-slaves.",1,0,0,1
6328,The master may transfer us an      entirely different data set and we have no way to incrementally feed      our slaves after that.,1,0,0,1
6329, Force our slaves to resync with us as well.,0,0,0,0
6330, Don't allow our chained slaves to PSYNC.,0,1,0,1
6331, Fall back to SYNC if needed.,0,1,0,1
6332,Otherwise psync_result == PSYNC_FULLRESYNC      and the server.master_replid and master_initial_offset are      already populated.,0,0,0,0
6333, Prepare a suitable temp file for bulk transfer,1,1,0,1
6334, Setup the non blocking download of the bulk file.,0,1,0,1
6335, Handle sendSynchronousCommand(SYNC_CMD_WRITE) errors.,0,0,0,0
6336, This function can be called when a non blocking connection is currently  in progress to undo it.,1,0,0,1
6337,"Never call this function directly, use cancelReplicationHandshake() instead.",1,0,0,1
6338, Abort the async download of the bulk dataset while SYNC-ing with master.,0,0,0,0
6339,"Never call this function directly, use cancelReplicationHandshake() instead.",1,0,0,1
6340," This function aborts a non blocking replication attempt if there is one  in progress, by canceling the non-blocking connect attempt or  the initial bulk transfer.",0,0,0,0
6341,If there was a replication handshake in progress 1 is returned and  the replication state (server.repl_state) set to REPL_STATE_CONNECT.,0,0,0,0
6342,Otherwise zero is returned and no operation is perforemd at all.,0,0,0,0
6343, Set replication to the specified master address and port.,0,1,0,1
6344," Clients blocked in master, now slave.",0,1,0,1
6345, Force our slaves to resync with us as well.,0,0,0,0
6346,"They may hopefully be able      to partially resync with us, but we can notify the replid change.",1,0,0,1
6347," Before destroying our master state, create a cached master using      our own parameters, to later PSYNC with the new master.",1,0,0,1
6348," Cancel replication, setting the instance as a master itself.",0,1,0,1
6349, Nothing to do.,0,1,0,1
6350," When a slave is turned into a master, the current replication ID      (that was inherited from the master at synchronization time) is      used as secondary ID up to the current offset, and a new replication      ID is created to continue with a new replication history.",1,0,0,1
6351, Disconnecting all the slaves is required: we need to inform slaves      of the replication ID change (see shiftReplicationId() call).,0,0,0,0
6352,"However      the slaves will be able to partially resync with us, so it will be      a very fast reconnection.",1,0,0,1
6353, We need to make sure the new master will start the replication stream      with a SELECT statement.,1,0,0,1
6354,"This is forced after a full resync, but      with PSYNC version 2, there is no need for full resync after a      master switch.",1,0,0,1
6355," Once we turn from slave to master, we consider the starting time without      slaves (that is used to count the replication backlog time to live) as      starting from now.",1,0,0,1
6356,Otherwise the backlog will be freed after a      failover if slaves do not connect immediately.,0,0,0,0
6357, This function is called when the slave lose the connection with the  master into an unexpected way.,1,0,0,1
6358," We lost connection with our master, don't disconnect slaves yet,      maybe we'll be able to PSYNC with our master later.",1,0,0,1
6359,We'll disconnect      the slaves only if we'll have to do a full resync with our master.,1,0,0,1
6360, SLAVEOF is not allowed in cluster mode as replication is automatically      configured using the current address of the master node.,1,0,0,1
6361," The special host or port combination ""NO"" ""ONE"" turns the instance      into a master.",1,0,0,1
6362,Otherwise the new master address is set.,1,0,0,1
6363, Check if we are already attached to the specified slave,0,1,0,1
6364," There was no previous master or the user specified a different one,          we can continue.",1,0,0,1
6365, ROLE command: provide information about the role of the instance  (master or slave) and additional information related to replication  in an easy to process format.,1,0,0,1
6366, Send a REPLCONF ACK command to the master to inform it about the current  processed offset.,1,0,0,1
6367,"If we are not connected with a master, the command has  no effects.",0,0,0,0
6368, ---------------------- MASTER CACHING FOR PSYNC --------------------------,0,1,0,1
6369, In order to implement partial synchronization we need to be able to cache  our master's client structure after a transient disconnection.,1,0,0,1
6370,It is cached into server.cached_master and flushed away using the following  functions.,1,0,0,1
6371, This function is called by freeClient() in order to cache the master  client structure instead of destryoing it.,0,0,0,0
6372,"freeClient() will return  ASAP after this function returns, so every action needed to avoid problems  with a client that is really ""suspended"" has to be done by this function.",1,0,0,1
6373,The other functions that will deal with the cached master are:   replicationDiscardCachedMaster() that will make sure to kill the client  as for some reason we don't want to use it in the future.,1,0,0,1
6374,replicationResurrectCachedMaster() that is used after a successful PSYNC  handshake in order to reactivate the cached master.,1,0,0,1
6375, Unlink the client from the server structures.,0,0,0,0
6376," Reset the master client so that's ready to accept new commands:      we want to discard te non processed query buffers and non processed      offsets, including pending transactions, already populated arguments,      pending outputs to the master.",1,0,0,1
6377, Save the master.,0,1,0,1
6378,Server.master will be set to null later by      replicationHandleMasterDisconnection().,0,0,0,0
6379, Invalidate the Peer ID cache.,0,1,0,1
6380," Caching the master happens instead of the actual freeClient() call,      so make sure to adjust the replication state.",1,0,0,1
6381,This function will      also set server.master to NULL.,0,0,0,0
6382," This function is called when a master is turend into a slave, in order to  create from scratch a cached master for the new client, that will allow  to PSYNC with the slave that was promoted as the new master after a  failover.",1,0,0,1
6383,"Assuming this instance was previously the master instance of the new master,  the new master will accept its replication ID, and potentiall also the  current offset if no data was lost during the failover.",1,0,0,1
6384,So we use our  current replication ID and offset in order to synthesize a cached master.,1,0,0,1
6385," The master client we create can be set to any DBID, because      the new master will start its replication stream with SELECT.",1,0,0,1
6386, Use our own ID  or  offset.,1,0,0,1
6387, Set as cached master.,0,1,0,1
6388," Free a cached master, called when there are no longer the conditions for  a partial resync on reconnection.",1,0,0,1
6389," Turn the cached master into the current master, using the file descriptor  passed as argument as the socket for the new master.",1,0,0,1
6390,This function is called when successfully setup a partial resynchronization  so the stream of data that we'll receive will start from were this  master left.,1,0,0,1
6391, Re-add to the list of clients.,0,1,0,1
6392, Close ASAP.,0,1,0,1
6393, We may also need to install the write handler as well if there is      pending data in the write buffers.,0,0,0,0
6394, Close ASAP.,0,1,0,1
6395, ------------------------- MIN-SLAVES-TO-WRITE  ---------------------------,0,0,0,0
6396, This function counts the number of slaves with lag <= min-slaves-max-lag.,0,1,0,1
6397,"If the option is active, the server will prevent writes if there are not  enough connected slaves with the specified lag (or less).",1,0,0,1
6398," ----------------------- REPLICATION SCRIPT CACHE --------------------------  The goal of this code is to keep track of scripts already sent to every  connected slave, in order to be able to replicate EVALSHA as it is without  translating it to EVAL every time it is possible.",1,0,0,1
6399,"We use a capped collection implemented by a hash table for fast lookup  of scripts we can send as EVALSHA, plus a linked list that is used for  eviction of the oldest entry when the max number of items is reached.",1,0,0,1
6400,"We don't care about taking a different cache for every different slave  since to fill the cache again is not very costly, the goal of this code  is to avoid that the same big script is trasmitted a big number of times  per second wasting bandwidth and processor speed, but it is not a problem  if we need to rebuild the cache from scratch from time to time, every used  script will need to be transmitted a single time to reappear in the cache.",1,0,0,1
6401,"This is how the system works:   1) Every time a new slave connects, we flush the whole script cache.",1,0,0,1
6402,"2) We only send as EVALSHA what was sent to the master as EVALSHA, without     trying to convert EVAL into EVALSHA specifically for slaves.",1,0,0,1
6403,"3) Every time we trasmit a script as EVAL to the slaves, we also add the     corresponding SHA1 of the script into the cache as we are sure every     slave knows about the script starting from now.",1,0,0,1
6404,"4) On SCRIPT FLUSH command, we replicate the command to all the slaves     and at the same time flush the script cache.",1,0,0,1
6405,"5) When the last slave disconnects, flush the cache.",1,1,0,1
6406,6) We handle SCRIPT LOAD as well since that's how scripts are loaded     in the master sometimes.,0,0,0,0
6407," Initialize the script cache, only called at startup.",1,0,0,1
6408, Empty the script cache.,1,1,0,1
6409,"Should be called every time we are no longer sure  that every slave knows about all the scripts in our set, or when the  current AOF ""context"" is no longer aware of the script.",1,0,0,1
6410,In general we  should flush the cache:   1) Every time a new slave reconnects to this master and performs a     full SYNC (PSYNC does not require flushing).,1,0,0,1
6411,2) Every time an AOF rewrite is performed.,0,1,0,1
6412,"3) Every time we are left without slaves at all, and AOF is off, in order     to reclaim otherwise unused memory.",0,0,0,0
6413," Add an entry into the script cache, if we reach max number of entries the  oldest is removed from the list.",0,0,0,0
6414, Evict oldest.,0,1,0,1
6415, Add current.,1,1,0,1
6416," Returns non-zero if the specified entry exists inside the cache, that is,  if all the slaves are aware of this script SHA1.",1,0,0,1
6417," ----------------------- SYNCHRONOUS REPLICATION --------------------------  Redis synchronous replication design can be summarized in points:   - Redis masters have a global replication offset, used by PSYNC.",0,0,0,0
6418,#NAME?,1,0,0,1
6419,#NAME?,1,1,0,1
6420,"So synchronous replication adds a new WAIT command in the form:     WAIT <num_replicas> <milliseconds_timeout>   That returns the number of replicas that processed the query when  we finally have at least num_replicas, or when the timeout was  reached.",1,0,0,1
6421,"The command is implemented in this way:   - Every time a client processes a command, we remember the replication    offset after sending that command to the slaves.",0,0,0,0
6422,#NAME?,0,0,0,0
6423,The client is blocked at the same time (see blocked.c).,1,1,0,1
6424,#NAME?,1,0,0,1
6425, This just set a flag so that we broadcast a REPLCONF GETACK command  to all the slaves in the beforeSleep() function.,0,0,0,0
6426,"Note that this way  we ""group"" all the clients that want to wait for synchronouns replication  in a given event loop iteration, and send a single GETACK for them all.",1,0,0,1
6427, Return the number of slaves that already acknowledged the specified  replication offset.,0,0,0,0
6428, WAIT for N replicas to acknowledge the processing of our latest  write command (and all the previous commands).,1,0,0,1
6429, Argument parsing.,0,1,0,1
6430, First try without blocking at all.,1,1,0,1
6431, Otherwise block the client and put it into our list of clients      waiting for ack from slaves.,0,0,0,0
6432, Make sure that the server will send an ACK request to all the slaves      before returning to the event loop.,1,0,0,1
6433, This is called by unblockClient() to perform the blocking op type  specific cleanup.,1,0,0,1
6434,We just remove the client from the list of clients  waiting for replica acks.,0,0,0,0
6435,"Never call it directly, call unblockClient()  instead.",1,0,0,1
6436, Check if there are clients blocked in WAIT that can be unblocked since  we received enough ACKs from slaves.,1,0,0,1
6437," Every time we find a client that is satisfied for a given          offset and number of replicas, we remember it so the next client          may be unblocked without calling replicationCountAcksByOffset()          if the requested offset  or  replicas were equal or less.",1,0,0,1
6438," Return the slave replication offset for this instance, that is  the offset for which we already processed the master replication stream.",0,0,0,0
6439," offset may be -1 when the master does not support it at all, however      this function is designed to return an offset that can express the      amount of data processed by the master, so we return a positive      integer.",1,0,0,1
6440, --------------------------- REPLICATION CRON  ----------------------------,0,0,0,0
6441," Replication cron function, called 1 time per second.",0,0,0,0
6442, Non blocking connection timeout?,0,1,0,1
6443, Bulk transfer I or O timeout?,0,1,0,1
6444, Timed out master when we are an already connected slave?,0,1,0,1
6445, Check if we should connect to a MASTER,0,1,0,1
6446, Send ACK to master from time to time.,0,1,0,1
6447,Note that we do not send periodic acks to masters that don't      support PSYNC and replication offsets.,0,0,0,0
6448," If we have attached slaves, PING them from time to time.",0,1,0,1
6449,"So slaves can implement an explicit timeout to masters, and will      be able to detect a link disconnection even if the TCP connection      will not actually go down.",1,0,0,1
6450," First, send PING according to ping_slave_period.",1,0,0,1
6451," Second, send a newline to all the slaves in pre-synchronization      stage, that is, slaves waiting for the master to create the RDB file.",0,0,0,0
6452,"Also send the a newline to all the chained slaves we have, if we lost      connection from our master, to keep the slaves aware that their      master is online.",1,0,0,1
6453,"This is needed since sub-slaves only receive proxied      data from top-level masters, so there is no explicit pinging in order      to avoid altering the replication offsets.",1,0,0,1
6454,"This special out of band      pings (newlines) can be sent, they will have no effect in the offset.",1,0,0,1
6455,The newline will be ignored by the slave but will refresh the      last interaction timer preventing a timeout.,1,0,0,1
6456,In this case we ignore the      ping period and refresh the connection once per second since certain      timeouts are set at a few seconds (example: PSYNC response).,1,0,0,1
6457," Don't worry about socket errors, it's just a ping.",0,1,0,1
6458, Disconnect timedout slaves.,0,0,0,0
6459," If this is a master without attached slaves and there is a replication      backlog active, in order to reclaim memory we can free it after some      (configured) time.",1,0,0,1
6460,"Note that this cannot be done for slaves: slaves      without sub-slaves attached should still accumulate data into the      backlog, in order to reply to PSYNC queries if they are turned into      masters after a failover.",0,0,0,0
6461," When we free the backlog, we always use a new              replication ID and clear the ID2.",1,0,0,1
6462,"This is needed              because when there is no backlog, the master_repl_offset              is not updated, but we would still retain our replication              ID, leading to the following problem:                           1.",1,0,0,1
6463,We are a master instance.,0,1,0,1
6464,Our slave is promoted to master.,0,1,0,1
6465,It's repl-id-2 will                 be the same as our repl-id.,1,0,0,1
6466,"We, yet as master, receive some updates, that will not                 increment the master_repl_offset.",0,0,0,0
6467,"Later we are turned into a slave, connecto to the new                 master that will accept our PSYNC request by second                 replication ID, but there will be data inconsistency                 because we received writes.",1,0,0,1
6468," If AOF is disabled and we no longer have attached slaves, we can      free our Replication Script Cache as there is no need to propagate      EVALSHA at all.",1,0,0,1
6469, Start a BGSAVE good for replication if we have slaves in      WAIT_BGSAVE_START state.,1,0,0,1
6470,"In case of diskless replication, we make sure to wait the specified      number of seconds (according to configuration) so that other slaves      have the time to arrive before we start streaming.",1,0,0,1
6471, Start the BGSAVE.,0,1,0,1
6472,The called function may start a              BGSAVE with socket target or disk target depending on the              configuration and slaves capabilities.,0,0,0,0
6473, Refresh the number of slaves with lag <= min-slaves-max-lag.,0,1,0,1
6474, Incremented with frequency 1 HZ.,0,1,0,1
6475, ------------------------- Buffer I or O implementation -----------------------,0,1,0,1
6476, Returns 1 or 0 for success or failure.,1,1,0,1
6477, Returns 1 or 0 for success or failure.,1,1,0,1
6478, not enough buffer to return len bytes.,1,0,0,1
6479, Returns read or write position in buffer.,0,1,0,1
6480, Flushes any buffer to target device if applicable.,0,1,0,1
6481,Returns 1 on success  and 0 on failures.,1,0,0,1
6482," Nothing to do, our write just appends to the buffer.",0,1,0,1
6483, update_checksum,0,0,0,0
6484, current checksum,1,0,0,1
6485, bytes read or written,0,0,0,0
6486, read or write chunk size,0,0,0,0
6487, union for io-specific vars,0,0,0,0
6488, --------------------- Stdio file pointer implementation -------------------,0,1,0,1
6489, Returns 1 or 0 for success or failure.,1,1,0,1
6490, Returns 1 or 0 for success or failure.,1,1,0,1
6491, Returns read or write position in file.,0,1,0,1
6492, Flushes any buffer to target device if applicable.,0,1,0,1
6493,Returns 1 on success  and 0 on failures.,1,0,0,1
6494, update_checksum,0,0,0,0
6495, current checksum,1,0,0,1
6496, bytes read or written,0,0,0,0
6497, read or write chunk size,0,0,0,0
6498, union for io-specific vars,0,0,0,0
6499, ------------------- File descriptors set implementation -------------------,0,1,0,1
6500, Returns 1 or 0 for success or failure.,1,1,0,1
6501,The function returns success as long as we are able to correctly write  to at least one file descriptor.,1,0,0,1
6502,"When buf is NULL and len is 0, the function performs a flush operation  if there is some pending buffer, so this function is also used in order  to implement rioFdsetFlush().",0,0,0,0
6503, To start we always append to our buffer.,0,1,0,1
6504,"If it gets larger than      a given size, we actually write to the sockets.",1,0,0,1
6505, Prevent entering the while below if we don't flush.,0,1,0,1
6506, Write in little chunchs so that when there are big writes we      parallelize while the kernel is sending data in background to      the TCP socket.,1,0,0,1
6507, Skip FDs alraedy in error.,0,0,0,0
6508, Make sure to write 'count' bytes to the socket regardless              of short writes.,1,0,0,1
6509," With blocking sockets, which is the sole user of this                      rio target, EWOULDBLOCK is returned only because of                      the SO_SNDTIMEO socket option, so we translate the error                      into one more recognizable by the user.",1,0,0,1
6510, Mark this FD as broken.,1,1,0,1
6511, All the FDs in error.,0,0,0,0
6512, Returns 1 or 0 for success or failure.,1,1,0,1
6513," Error, this target does not support reading.",0,1,0,1
6514, Returns read or write position in file.,0,1,0,1
6515, Flushes any buffer to target device if applicable.,0,1,0,1
6516,Returns 1 on success  and 0 on failures.,1,0,0,1
6517," Our flush is implemented by the write method, that recognizes a      buffer set to NULL with a count of zero as a flush request.",0,0,0,0
6518, update_checksum,0,0,0,0
6519, current checksum,1,0,0,1
6520, bytes read or written,0,0,0,0
6521, read or write chunk size,0,0,0,0
6522, union for io-specific vars,0,0,0,0
6523, release the rio stream.,0,0,0,0
6524, ---------------------------- Generic functions ----------------------------,0,1,0,1
6525, This function can be installed both in memory and file streams when checksum  computation is needed.,0,0,0,0
6526, Set the file-based rio object to auto-fsync every 'bytes' file written.,0,0,0,0
6527,By default this is set to zero that means no automatic file sync is  performed.,0,0,0,0
6528,"This feature is useful in a few contexts since when we rely on OS write  buffers sometimes the OS buffers way too much, resulting in too many  disk I or O concentrated in very little time.",1,0,0,1
6529,When we fsync in an explicit  way instead the I or O pressure is more distributed across time.,1,0,0,1
6530, --------------------------- Higher level interface --------------------------   The following higher level functions use lower level rio.c functions to help  generating the Redis protocol for the Append Only File.,1,0,0,1
6531," Write multi bulk count in the format: ""<count>\r\n"".",0,0,0,0
6532," Write binary-safe string in the format: ""$<count>\r\n<payload>\r\n"".",0,0,0,0
6533," Write a long long value in format: ""$<count>\r\n<payload>\r\n"".",1,0,0,1
6534," Write a double value in the format: ""$<count>\r\n<payload>\r\n""",0,0,0,0
6535, Debugger shared state is stored inside this global structure.,0,1,0,1
6536, Max number of breakpoints.,0,1,0,1
6537, Default len limit for replies  or  var dumps.,0,0,0,0
6538, Socket of the debugging client.,0,1,0,1
6539, Are we debugging EVAL right now?,1,1,0,1
6540, Is this a fork()ed debugging session?,0,1,0,1
6541, List of messages to send to the client.,0,1,0,1
6542, Messages about Redis commands executed since last stop.,1,0,0,1
6543, All forked debugging sessions pids.,0,0,0,0
6544, An array of breakpoints line numbers.,0,1,0,1
6545, Number of valid entries inside bp.,0,0,0,0
6546, Stop at next line ragardless of breakpoints.,0,0,0,0
6547, Stop at next line because redis.breakpoint() was called.,0,0,0,0
6548, Lua script source code split by line.,0,0,0,0
6549, Number of lines in 'src'.,0,0,0,0
6550, Current line number.,1,1,0,1
6551, Debugger client command buffer.,0,1,0,1
6552, Max var dump  or  reply length.,0,0,0,0
6553," Did we already hint about ""set maxlen""?",0,0,0,0
6554, ---------------------------------------------------------------------------  Utility functions.,0,0,0,0
6555, Perform the SHA1 of the input string.,0,1,0,1
6556,"We use this both for hashing script  bodies in order to obtain the Lua function name, and in the implementation  of redis.sha1().",0,0,0,0
6557,"'digest' should point to a 41 bytes buffer: 40 for SHA1 converted into an  hexadecimal number, plus 1 byte for null term.",0,0,0,0
6558, ---------------------------------------------------------------------------  Redis reply to Lua type conversion functions.,0,0,0,0
6559, Take a Redis reply in the Redis protocol format and convert it into a  Lua type.,0,0,0,0
6560,"Thanks to this function, and the introduction of not connected  clients, it is trivial to implement the redis() lua function.",1,0,0,1
6561,"Basically we take the arguments, execute the Redis command in the context  of a non connected client, then take the generated reply and convert it  into a suitable Lua type.",1,0,0,1
6562,With this trick the scripting feature does not  need the introduction of a full Redis internals API.,1,0,0,1
6563,The script  is like a normal client that bypasses all the slow I or O paths.,1,0,0,1
6564,Note: in this function we do not do any sanity check as the reply is  generated by Redis directly.,1,0,0,1
6565,This allows us to go faster.,0,1,0,1
6566,Errors are returned as a table with a single 'err' field set to the  error string.,1,0,0,1
6567," This function is used in order to push an error on the Lua stack in the  format used by redis.pcall to return errors, which is a lua table  with a single ""err"" field set to the error string.",1,0,0,1
6568,"Note that this  table is never a valid reply by proper commands, since the returned  tables are otherwise always indexed by integers, never by strings.",1,0,0,1
6569," If debugging is active and in step mode, log errors resulting from      Redis commands.",1,0,0,1
6570," Attempt to figure out where this function was called, if possible",1,1,0,1
6571," In case the error set into the Lua stack by luaPushError() was generated  by the non-error-trapping version of redis.pcall(), which is redis.call(),  this function will raise the Lua error so that the execution of the  script will be halted.",0,0,0,0
6572, Sort the array currently in the stack.,1,1,0,1
6573,We do this to make the output  of commands like KEYS or SMEMBERS something deterministic when called  from Lua (to play well with AOf or replication).,0,0,0,0
6574,"The array is sorted using table.sort itself, and assuming all the  list elements are strings.",0,0,0,0
6575, Initial Stack: array,0,1,0,1
6576," Stack: array, table, table.sort",0,1,0,1
6577," Stack: array, table, table.sort, array",0,1,0,1
6578," Stack: array, table, error",0,1,0,1
6579," We are not interested in the error, we assume that the problem is          that there are 'false' elements inside the array, so we try          again with a slower function but able to handle this case, that          is: table.sort(table, __redis__compare_helper)",1,0,0,1
6580," Stack: array, table",0,1,0,1
6581," Stack: array, table, sort",0,1,0,1
6582," Stack: array, table, table.sort",0,1,0,1
6583," Stack: array, table, table.sort, array",0,1,0,1
6584," Stack: array, table, table.sort, array, __redis__compare_helper",0,0,0,0
6585," Stack: array (sorted), table",0,1,0,1
6586, Stack: array (sorted),0,1,0,1
6587, ---------------------------------------------------------------------------  Lua reply to Redis reply conversion functions.,0,0,0,0
6588," We need to check if it is an array, an error, or a status reply.",0,1,0,1
6589,Error are returned as a single element table with 'err' field.,1,1,0,1
6590,Status replies are returned as single element table with 'ok'          field.,1,0,0,1
6591, Discard the 'ok' field value we popped,1,0,0,1
6592, ---------------------------------------------------------------------------  Lua redis.,0,0,0,0
6593,functions implementations.,0,0,0,0
6594, Cached across calls.,0,1,0,1
6595, Recursive calls detection.,0,1,0,1
6596, Reflect MULTI state,0,1,0,1
6597," By using Lua debug hooks it is possible to trigger a recursive call      to luaRedisGenericCommand(), which normally should never happen.",1,0,0,1
6598,"To make this function reentrant is futile and makes it slower, but      we should at least detect such a misuse, and abort.",1,0,0,1
6599, Require at least one argument,1,1,0,1
6600, Build the arguments vector,0,1,0,1
6601, We can't use lua_tolstring() for number -> string conversion              since Lua uses a format specifier that loses precision.,1,0,0,1
6602, Not a string.,0,1,0,1
6603, Try to use a cached object.,0,1,0,1
6604, Check if one of the arguments passed by the Lua script      is not a string or an integer (lua_isstring() return true for      integers as well).,1,0,0,1
6605, Setup our fake client for command execution,1,1,0,1
6606, Log the command if debugging is active.,1,1,0,1
6607, Command lookup,0,0,0,0
6608, There are commands that are not allowed inside scripts.,0,1,0,1
6609," Write commands are forbidden against read-only slaves, or if a      command marked as non-deterministic was already called in the context      of this script.",1,0,0,1
6610," If we reached the memory limit configured via maxmemory, commands that      could enlarge the memory usage are not allowed, but only if this is the      first write in the context of this script, otherwise we can't stop      in the middle.",1,0,0,1
6611," If this is a Redis Cluster node, we need to make sure Lua is not      trying to access non-local keys, with the exception of commands      received from our master or when loading the AOF back in memory.",1,0,0,1
6612, Duplicate relevant flags in the lua client.,1,0,0,1
6613," If we are using single commands replication, we need to wrap what      we propagate into a MULTI or EXEC block, so that it will be atomic like      a Lua script in the context of AOF and slaves.",1,0,0,1
6614, Run the command,0,1,0,1
6615, Set flags according to redis.set_repl() settings.,0,0,0,0
6616, Convert the result of the Redis command into a suitable Lua type.,1,0,0,1
6617,The first thing we need is to create a single string from the client      output buffers.,1,0,0,1
6618, This is a fast path for the common case of a reply inside the          client static buffer.,1,0,0,1
6619,Don't create an SDS string but just use          the client buffer directly.,1,0,0,1
6620," If the debugger is active, log the reply from Redis.",1,0,0,1
6621," Sort the output array if needed, assuming it is a non-null multi bulk      reply as expected.",1,0,0,1
6622, Clean up.,1,1,0,1
6623,Command code may have changed argv or argc so we use the      argv or argc of the client instead of the local variables.,0,0,0,0
6624, Try to cache the object in the cached_objects array.,0,0,0,0
6625,"The object must be small, SDS-encoded, and with refcount = 1          (we must be the only owner) for us to cache it.",1,0,0,1
6626," If we are here we should have an error in the stack, in the          form of a table with an ""err"" field.",0,0,0,0
6627,Extract the string to          return the plain error.,1,0,0,1
6628, redis.call(),0,0,0,0
6629, redis.pcall(),0,0,0,0
6630, This adds redis.sha1hex(string) to Lua scripts using the same hashing  function used for sha1ing lua scripts.,1,0,0,1
6631, Returns a table with a single field 'field' set to the string value  passed as argument.,1,0,0,1
6632,"This helper function is handy when returning  a Redis Protocol error or status reply from Lua:   return redis.error_reply(""ERR Some Error"")  return redis.status_reply(""ERR Some Error"")",1,0,0,1
6633, redis.error_reply(),0,0,0,0
6634, redis.status_reply(),0,0,0,0
6635," redis.replicate_commands()   Turn on single commands replication if the script never called  a write command so far, and returns true.",1,0,0,1
6636,"Otherwise if the script  already started to write, returns false and stick to whole scripts  replication, which is our default.",1,0,0,1
6637," When we switch to single commands replication, we can provide          different math.random() sequences at every call, which is what          the user normally expects.",1,0,0,1
6638," redis.breakpoint()   Allows to stop execution during a debuggign session from within  the Lua code implementation, like if a breakpoint was set in the code  immediately after the function.",0,0,0,0
6639, redis.debug()   Log a string message into the output console.,0,0,0,0
6640,Can take multiple arguments that will be separated by commas.,0,1,0,1
6641,Nothing is returned to the caller.,0,1,0,1
6642, redis.set_repl()   Set the propagation of write commands executed in the context of the  script to on or off for AOF and slaves.,0,0,0,0
6643, redis.log(),0,0,0,0
6644, Glue together all the arguments,0,1,0,1
6645, ---------------------------------------------------------------------------  Lua engine initialization and reset.,0,0,0,0
6646," Stuff that we don't load currently, for sandboxing concerns.",1,0,0,1
6647, Remove a functions that we don't want to expose to the Redis scripting  environment.,0,0,0,0
6648, This function installs metamethods in the global table _G that prevent  the creation of globals accidentally.,0,0,0,0
6649,"It should be the last to be called in the scripting engine initialization  sequence, because it may interact with creation of globals.",1,0,0,1
6650, strict.lua from: http: or  or metalua.luaforge.net or src or lib or strict.lua.html.,0,0,0,0
6651,Modified to be adapted to Redis.,0,0,0,0
6652, Initialize the scripting environment.,0,1,0,1
6653,This function is called the first time at server startup with  the 'setup' argument set to 1.,1,0,0,1
6654,"It can be called again multiple times during the lifetime of the Redis  process, with 'setup' set to 0, and following a scriptingRelease() call,  in order to reset the Lua scripting environment.",1,0,0,1
6655,However it is simpler to just call scriptingReset() that does just that.,0,0,0,0
6656, Only DEBUG can change it.,1,1,0,1
6657, Initialize a dictionary we use to map SHAs to scripts.,0,0,0,0
6658,"This is useful for replication, as we need to replicate EVALSHA      as EVAL, so we need to remember the associated script.",1,0,0,1
6659, Register the redis commands table and fields,0,0,0,0
6660, redis.call,0,0,0,0
6661, redis.pcall,0,0,0,0
6662, redis.log and log levels.,0,0,0,0
6663, redis.sha1hex,0,0,0,0
6664, redis.error_reply and redis.status_reply,0,0,0,0
6665, redis.replicate_commands,0,0,0,0
6666, redis.set_repl and associated flags.,0,0,0,0
6667, redis.breakpoint,0,0,0,0
6668, redis.debug,0,0,0,0
6669, Finally set the table as 'redis' global var.,1,0,0,1
6670, Replace math.random and math.randomseed with our implementations.,0,0,0,0
6671," Add a helper function that we use to sort the multi bulk output of non      deterministic commands, when containing 'false' elements.",1,0,0,1
6672, Add a helper function we use for pcall error reporting.,0,0,0,0
6673,"Note that when the error is in the C function we want to report the      information about the caller, that's what makes sense from the point      of view of the user debugging a script.",0,0,0,0
6674, Create the (non connected) client that we use to execute Redis commands      inside the Lua interpreter.,0,0,0,0
6675,Note: there is no need to create it again when this function is called      by scriptingReset().,0,0,0,0
6676," Lua beginners often don't use ""local"", this is likely to introduce      subtle bugs in their code.",1,0,0,1
6677,To prevent problems we protect accesses      to global variables.,0,0,0,0
6678, Release resources related to Lua scripting.,1,0,0,1
6679,This function is used in order to reset the scripting environment.,0,1,0,1
6680, Set an array of Redis String Objects as a Lua array (table) stored into a  global variable.,0,0,0,0
6681, ---------------------------------------------------------------------------  Redis provided math.random  -------------------------------------------------------------------------,0,0,0,0
6682, We replace math.random() with our implementation that is not affected  by specific libc random() implementations and will output the same sequence  (for the same seed) in every arch.,1,0,0,1
6683, The following implementation is the one shipped with Lua itself but with  rand() replaced by redisLrand48().,1,0,0,1
6684," the `%' avoids the (rare) case of r==1, and is needed also because on     some systems (SunOS!)",1,0,0,1
6685,`rand()' may return a value larger than RAND_MAX,1,0,0,1
6686, check number of arguments,0,0,0,0
6687, no arguments,0,0,0,0
6688, Number between 0 and 1,0,1,0,1
6689, only upper limit,1,0,0,1
6690, int between 1 and `u',0,0,0,0
6691, lower and upper limits,0,0,0,0
6692, int between `l' and `u',0,0,0,0
6693, ---------------------------------------------------------------------------  EVAL and SCRIPT commands implementation  -------------------------------------------------------------------------,0,0,0,0
6694, Define a Lua function with the specified body.,0,0,0,0
6695,The function name will be generated in the following form:     f_<hex sha1 sum>   The function increments the reference count of the 'body' object as a  side effect of a successful call.,1,0,0,1
6696,"On success a pointer to an SDS string representing the function SHA1 of the  just added function is returned (and will be valid until the next call  to scriptingReset() function), otherwise NULL is returned.",1,0,0,1
6697,"The function handles the fact of being called with a script that already  exists, and in such a case, it behaves like in the success case.",1,0,0,1
6698,"If 'c' is not NULL, on error the client is informed with an appropriate  error describing the nature of the problem and the Lua interpreter error.",1,0,0,1
6699, We also save a SHA1 -> Original script map in a dictionary      so that we can replicate  or  write in the AOF all the      EVALSHA commands as EVAL using the original script.,1,0,0,1
6700," This is the Lua script ""count"" hook that we use to detect scripts timeout.",0,0,0,0
6701, Once the script timeouts we reenter the event loop to permit others          to call SCRIPT KILL or SHUTDOWN NOSAVE if needed.,0,0,0,0
6702,For this reason          we need to mask the client executing the script from the event loop.,0,0,0,0
6703,If we don't do that the client may disconnect and could no longer be          here when the EVAL command will return.,0,0,0,0
6704," When we replicate whole scripts, we want the same PRNG sequence at      every call so that our PRNG is not affected by external state.",1,0,0,1
6705, We set this flag to zero to remember that so far no random command      was called.,1,0,0,1
6706,This way we can allow the user to call commands like      SRANDMEMBER or RANDOMKEY from Lua scripts as far as no write command      is called (otherwise the replication and AOF would end with non      deterministic sequences).,1,0,0,1
6707,Thanks to this flag we'll raise an error every time a write command      is called after a random command was used.,1,0,0,1
6708, Get the number of arguments that are keys,0,1,0,1
6709," We obtain the script SHA1, then check if this function is already      defined into the Lua state",0,0,0,0
6710, Hash the code if this is an EVAL call,0,1,0,1
6711, We already have the SHA if it is a EVALSHA,0,1,0,1
6712, Convert to lowercase.,0,1,0,1
6713,We don't use tolower since the function          managed to always show up in the profiler output consuming          a non trivial amount of time.,0,0,0,0
6714, Push the pcall error handler function on the stack.,0,0,0,0
6715, Try to lookup the Lua function,0,0,0,0
6716, remove the nil from the stack,0,0,0,0
6717, Function not defined... let's define it if we have the          body of the function.,0,0,0,0
6718,If this is an EVALSHA call we can just          return an error.,0,0,0,0
6719, remove the error handler from the stack.,0,0,0,0
6720, remove the error handler from the stack.,0,0,0,0
6721, The error is sent to the client by luaCreateFunction()              itself when it returns NULL.,0,0,0,0
6722, Now the following is guaranteed to return non nil,1,1,0,1
6723, Populate the argv and keys table accordingly to the arguments that      EVAL received.,0,0,0,0
6724, Select the right DB in the context of the Lua client,1,0,0,1
6725, Set a hook in order to be able to stop the script execution if it      is running for too much time.,1,0,0,1
6726,We set the hook only if the time limit is enabled as the hook will      make the Lua script execution slower.,1,0,0,1
6727,"If we are debugging, we set instead a ""line"" hook so that the      debugger is call-back at every line executed by the script.",0,0,0,0
6728," At this point whether this script was never seen before or if it was      already defined, we can call it.",0,0,0,0
6729,We have zero arguments and expect      a single return value.,1,0,0,1
6730, Perform some cleanup that we need to do both on error and success.,1,1,0,1
6731, Disable hook,0,1,0,1
6732, Restore the readable handler that was unregistered when the          script timeout was detected.,0,0,0,0
6733," Call the Lua garbage collector from time to time to avoid a      full cycle performed by Lua, which adds too latency.",1,0,0,1
6734,The call is performed every LUA_GC_CYCLE_PERIOD executed commands      (and for LUA_GC_CYCLE_PERIOD collection steps) because calling it      for every command uses too much CPU.,1,0,0,1
6735, Consume the Lua reply and remove error handler.,0,0,0,0
6736," On success convert the Lua return value into Redis protocol, and          send it to  the client.",1,0,0,1
6737, Convert and consume the reply.,0,1,0,1
6738, Remove the error handler.,0,1,0,1
6739," If we are using single commands replication, emit EXEC if there      was at least a write.",1,0,0,1
6740," EVALSHA should be propagated to Slave and AOF file as full EVAL, unless      we are sure that the script was already in the context of all the      attached slaves and the current AOF file if enabled.",1,0,0,1
6741,"To do so we use a cache of SHA1s of scripts that we already propagated      as full EVAL, that's called the Replication Script Cache.",1,0,0,1
6742,"For repliation, everytime a new slave attaches to the master, we need to      flush our cache of scripts that can be replicated as EVALSHA, while      for AOF we need to do so every time we rewrite the AOF file.",1,0,0,1
6743," This script is not in our script cache, replicate it as              EVAL, then add it into the script cache, as from now on              slaves and AOF know about it.",0,0,0,0
6744, We know that a match is not possible if the provided SHA is          not the right length.,1,0,0,1
6745,"So we return an error ASAP, this way          evalGenericCommand() can be implemented without string length          sanity check",0,0,0,0
6746, Propagating this command is a good idea.,1,1,0,1
6747, The error was sent by luaCreateFunction().,0,0,0,0
6748, ---------------------------------------------------------------------------  LDB: Redis Lua debugging facilities  -------------------------------------------------------------------------,0,0,0,0
6749, Initialize Lua debugger data structures.,0,0,0,0
6750, Remove all the pending messages in the specified list.,0,1,0,1
6751, Enable debug mode of Lua scripts for this client.,0,0,0,0
6752, Exit debugging mode from the POV of client.,0,1,0,1
6753,"This function is not enough  to properly shut down a client debugging session, see ldbEndSession()  for more information.",1,0,0,1
6754, Append a log entry to the specified LDB log.,0,1,0,1
6755, A version of ldbLog() which prevents producing logs greater than  ldb.maxlen.,1,0,0,1
6756,"The first time the limit is reached an hint is generated  to inform the user that reply trimming can be disabled using the  debugger ""maxlen"" command.",1,0,0,1
6757, Send ldb.logs to the debugging client as a multi-bulk reply  consisting of simple strings.,1,0,0,1
6758,Log entries which include newlines have them  replaced with spaces.,0,0,0,0
6759,The entries sent are also consumed.,0,1,0,1
6760, Avoid warning.,0,1,0,1
6761,We don't check the return value of write()          since the next read() will catch the I or O error and will          close the debugging session.,0,0,0,0
6762, Start a debugging session before calling EVAL implementation.,0,1,0,1
6763,"The techique we use is to capture the client socket file descriptor,  in order to perform direct I or O with it from within Lua hooks.",1,0,0,1
6764,This  way we don't have to re-enter Redis in order to handle I or O.,0,0,0,0
6765,"The function returns 1 if the caller should proceed to call EVAL,  and 0 if instead the caller should abort the operation (this happens  for the parent in a forked session, since it's up to the children  to continue, or when fork returned an error).",0,0,0,0
6766,The caller should call ldbEndSession() only if ldbStartSession()  returned 1.,1,0,0,1
6767, Child.,0,1,0,1
6768,Let's ignore important signals handled by the parent.,1,1,0,1
6769, Log the creation of the child and close the listening              socket to make sure if the parent crashes a reset is sent              to the clients.,1,0,0,1
6770, Parent,0,1,0,1
6771, Close the client in the parent side.,0,1,0,1
6772, Setup our debugging session.,0,1,0,1
6773, First argument of EVAL is the script itself.,1,1,0,1
6774,We split it into different      lines since this is the way the debugger accesses the source code.,1,0,0,1
6775, End a debugging session after the EVAL call with debugging enabled  returned.,0,0,0,0
6776, Emit the remaining logs and an <endsession> mark.,0,0,0,0
6777," If it's a fork()ed session, we just exit.",0,1,0,1
6778, Otherwise let's restore client's state.,0,0,0,0
6779, Close the client connectin after sending the final EVAL reply      in order to signal the end of the debugging session.,1,0,0,1
6780, Cleanup.,0,1,0,1
6781," If the specified pid is among the list of children spawned for  forked debugging sessions, it is removed from the children list.",0,0,0,0
6782,If the pid was found non-zero is returned.,0,0,0,0
6783, Return the number of children we still did not received termination  acknowledge via wait() in the parent process.,0,0,0,0
6784, Kill all the forked sessions.,0,1,0,1
6785," Wrapper for EVAL  or  EVALSHA that enables debugging, and makes sure  that when EVAL returns, whatever happened, the session is ended.",1,0,0,1
6786," Return a pointer to ldb.src source code line, considering line to be  one-based, and returning a special string for out of range lines.",1,0,0,1
6787, Return true if there is a breakpoint in the specified line.,1,0,0,1
6788, Add the specified breakpoint.,0,0,0,0
6789,Ignore it if we already reached the max.,0,1,0,1
6790,Returns 1 if the breakpoint was added (or was already set).,0,0,0,0
6791,0 if there is  no space for the breakpoint or if the line is invalid.,0,0,0,0
6792," Remove the specified breakpoint, returning 1 if the operation was  performed or 0 if there was no such breakpoint.",1,0,0,1
6793, Expect a valid multi-bulk command in the debugging client query buffer.,0,0,0,0
6794,"On success the command is parsed and returned as an array of SDS strings,  otherwise NULL is returned and there is to read more buffer.",1,0,0,1
6795, Working on a copy is simpler in this case.,0,1,0,1
6796,We can modify it freely      for the sake of simpler parsing.,1,0,0,1
6797, This Redis protocol parser is a joke... just the simplest thing that      works in this context.,0,0,0,0
6798,It is also very forgiving regarding broken      protocol.,1,0,0,1
6799, Seek and parse <count>\r\n.,0,1,0,1
6800, Multi bulk len pointer.,0,0,0,0
6801, Parse each argument.,0,1,0,1
6802, Bulk string len pointer.,0,0,0,0
6803, Length of this arg.,0,0,0,0
6804, Skip the already parsed argument.,0,1,0,1
6805, Skip \r\n.,0,1,0,1
6806, Log the specified line in the Lua debugger output.,0,0,0,0
6807," Implement the ""list"" command of the Lua debugger.",0,0,0,0
6808,"If around is 0  the whole file is listed, otherwise only a small portion of the file  around the specified line is shown.",1,0,0,1
6809,When a line number is specified  the amonut of context (lines before or after) is specified via the  'context' argument.,0,0,0,0
6810," Append an human readable representation of the Lua value at position 'idx'  on the stack of the 'lua' state, to the SDS string passed as argument.",1,0,0,1
6811,The new SDS string with the represented value attached is returned.,1,1,0,1
6812,Used in order to implement ldbLogStackValue().,0,0,0,0
6813,"The element is not automatically removed from the stack, nor it is  converted to a different type.",1,0,0,1
6814, First index we expect in an array.,1,1,0,1
6815, Will be set to null if check fails.,1,1,0,1
6816," Note: we create two representations at the same time, one          assuming the table is an array, one assuming it is not.",1,0,0,1
6817,At the          end we know what is true and select the right one.,1,0,0,1
6818, The first key to start the iteration is nil.,1,1,0,1
6819, Test if so far the table looks like an array.,1,1,0,1
6820," Stack now: table, key, value",1,1,0,1
6821, Array repr.,0,0,0,0
6822, Full repr.,1,0,0,1
6823," Stack: table, key.",1,1,0,1
6824,Ready for next iteration.,1,1,0,1
6825," Strip the last "" ;"" from both the representations.",1,0,0,1
6826, Select the right one and discard the other.,1,1,0,1
6827, Higher level wrapper for ldbCatStackValueRec() that just uses an initial  recursion level of '0'.,1,0,0,1
6828, Produce a debugger log entry representing the value of the Lua object  currently on the top of the stack.,1,0,0,1
6829,The element is ot popped nor modified.,0,0,0,0
6830,Check ldbCatStackValue() for the actual implementation.,1,0,0,1
6831, Get Redis protocol from 'reply' and appends it in human readable form to  the passed SDS string 'o'.,1,0,0,1
6832,"Note that the SDS string is passed by reference (pointer of pointer to  char) so that we can return a modified pointer, as for SDS semantics.",0,0,0,0
6833," The following functions are helpers for ldbRedisProtocolToHuman(), each  take care of a given Redis return type.",1,0,0,1
6834," Log a Redis reply as debugger output, in an human readable format.",1,0,0,1
6835,"If the resulting string is longer than 'len' plus a few more chars  used as prefix, it gets truncated.",1,0,0,1
6836," Implements the ""print <var>"" command of the Lua debugger.",0,0,0,0
6837,"It scans for Lua  var ""varname"" starting from the current stack frame up to the top stack  frame.",1,0,0,1
6838,The first matching variable is printed.,1,1,0,1
6839, Stack level.,0,1,0,1
6840, Variable index.,0,1,0,1
6841, Discard the var name on the stack.,0,1,0,1
6842, Let's try with global vars in two selected cases,0,1,0,1
6843," Implements the ""print"" command (without arguments) of the Lua debugger.",0,0,0,0
6844,Prints all the variables in the current stack frame.,1,1,0,1
6845, Variable index.,0,1,0,1
6846," Implements the break command to list, add and remove breakpoints.",0,1,0,1
6847," Implements the Lua debugger ""eval"" command.",0,0,0,0
6848,"It just compiles the user  passed fragment of code and executes it, showing the result left on  the stack.",0,0,0,0
6849, Glue the script together if it is composed of multiple arguments.,0,1,0,1
6850," Try to compile it as an expression, prepending ""return "".",0,0,0,0
6851, Failed?,1,1,0,1
6852,Try as a statement.,0,1,0,1
6853, Call it.,0,1,0,1
6854," Implement the debugger ""redis"" command.",0,0,0,0
6855,"We use a trick in order to make  the implementation very simple: we just call the Lua redis.call() command  implementation, with ldb.step enabled, so as a side effect the Redis command  and its reply are logged.",1,0,0,1
6856," Stack: redis, redis.call",0,0,0,0
6857, Force redis.call() to log.,0,0,0,0
6858," Stack: redis, result",0,0,0,0
6859, Disable logging.,0,1,0,1
6860, Discard the result and clean the stack.,1,1,0,1
6861," Implements ""trace"" command of the Lua debugger.",0,0,0,0
6862,It just prints a backtrace  querying Lua starting from the current callframe back to the outer one.,1,0,0,1
6863," Impleemnts the debugger ""maxlen"" command.",0,0,0,0
6864,It just queries or sets the  ldb.maxlen variable.,0,0,0,0
6865, User knows about this command.,0,1,0,1
6866, Read debugging commands from client.,0,1,0,1
6867,"Return C_OK if the debugging session is continuing, otherwise  C_ERR if the client closed the connection or is timing out.",1,0,0,1
6868, We continue processing commands until a command that should return      to the Lua interpreter is found.,0,0,0,0
6869, Make sure the script runs without user input since the                  client is no longer connected.,1,0,0,1
6870, Flush the old buffer.,1,1,0,1
6871, Execute the command.,0,1,0,1
6872, Free the command vector.,1,1,0,1
6873, Free the current command argv if we break inside the while loop.,1,0,0,1
6874," This is the core of our Lua debugger, called each time Lua is about  to start executing a new line.",1,0,0,1
6875, Events outside our script are not interesting.,1,1,0,1
6876, Check if a timeout occurred.,0,1,0,1
6877," No timeout, ignore the COUNT event.",0,1,0,1
6878," If the client closed the connection and we have a timeout              connection, let's kill the script otherwise the process              will remain blocked indefinitely.",1,0,0,1
6879, Create a new sds string with the content specified by the 'init' pointer  and 'initlen'.,1,0,0,1
6880,If NULL is used for 'init' the string is initialized with zero bytes.,0,0,0,0
6881,"If SDS_NOINIT is used, the buffer is left uninitialized;   The string is always null-termined (all the sds strings are, always) so  even if you create an sds string with:   mystring = sdsnewlen(""abc"",3);   You can print the string with printf() as there is an implicit \0 at the  end of the string.",0,0,0,0
6882,"However the string is binary safe and can contain  \0 characters in the middle, as the length is stored in the sds header.",1,0,0,1
6883, Empty strings are usually created in order to append.,1,1,0,1
6884,Use type 8      since type 5 is not good at this.,1,0,0,1
6885, flags pointer.,0,0,0,0
6886, Create an empty (zero length) sds string.,1,0,0,1
6887,Even in this case the string  always has an implicit null term.,0,0,0,0
6888, Create a new sds string starting from a null terminated C string.,1,0,0,1
6889, Duplicate an sds string.,0,0,0,0
6890, Free an sds string.,1,0,0,1
6891,No operation is performed if 's' is NULL.,0,1,0,1
6892," Set the sds string length to the length as obtained with strlen(), so  considering as content only up to the first null term character.",1,0,0,1
6893,"This function is useful when the sds string is hacked manually in some  way, like in the following example:   s = sdsnew(""foobar"");  s[2] = '\0';  sdsupdatelen(s);  printf(""%d\n"", sdslen(s));   The output will be ""2"", but if we comment out the call to sdsupdatelen()  the output will be ""6"" as the string was modified but the logical length  remains 6 bytes.",1,0,0,1
6894, Modify an sds string in-place to make it empty (zero length).,1,0,0,1
6895,However all the existing buffer is not discarded but set as free space  so that next append operations will not require allocations up to the  number of bytes previously available.,1,0,0,1
6896," Enlarge the free space at the end of the sds string so that the caller  is sure that after calling this function can overwrite up to addlen  bytes after the end of the string, plus one more byte for nul term.",1,0,0,1
6897,"Note: this does not change the length of the sds string as returned  by sdslen(), but only the free buffer space we have.",1,0,0,1
6898, Return ASAP if there is enough space left.,1,1,0,1
6899," Don't use type 5: the user is appending to the string and type 5 is      not able to remember empty space, so sdsMakeRoomFor() must be called      at every appending operation.",1,0,0,1
6900," Since the header size changes, need to move the string forward,          and can't use realloc",0,0,0,0
6901, Reallocate the sds string so that it has no free space at the end.,1,0,0,1
6902,"The  contained string remains not altered, but next concatenation operations  will require a reallocation.",0,0,0,0
6903,"After the call, the passed sds string is no longer valid and all the  references must be substituted with the new pointer returned by the call.",1,0,0,1
6904, Check what would be the minimum SDS header that is just good enough to      fit this string.,1,0,0,1
6905," If the type is the same, or at least a large enough type is still      required, we just realloc(), letting the allocator to do the copy      only if really needed.",1,0,0,1
6906,"Otherwise if the change is huge, we manually      reallocate the string to use the different header type.",1,0,0,1
6907," Return the total size of the allocation of the specifed sds string,  including:  1) The sds header before the pointer.",1,0,0,1
6908,2) The string.,0,1,0,1
6909,3) The free buffer at the end if any.,1,1,0,1
6910,4) The implicit null term.,0,1,0,1
6911, Return the pointer of the actual SDS allocation (normally SDS strings  are referenced by the start of the string buffer).,1,0,0,1
6912, Increment the sds length and decrements the left free space at the  end of the string according to 'incr'.,1,0,0,1
6913,Also set the null term  in the new end of the string.,1,0,0,1
6914,"This function is used in order to fix the string length after the  user calls sdsMakeRoomFor(), writes something after the end of  the current string, and finally needs to set the new length.",1,0,0,1
6915,Note: it is possible to use a negative increment in order to  right-trim the string.,1,0,0,1
6916,"Usage example:   Using sdsIncrLen() and sdsMakeRoomFor() it is possible to mount the  following schema, to cat bytes coming from the kernel to the end of an  sds string without copying into an intermediate buffer:   oldlen = sdslen(s);  s = sdsMakeRoomFor(s, BUFFER_SIZE);  nread = read(fd, s+oldlen, BUFFER_SIZE);  ... check for nread <= 0 and handle it ...  sdsIncrLen(s, nread);",1,0,0,1
6917, Just to avoid compilation warnings.,0,1,0,1
6918, Grow the sds to have the specified length.,0,0,0,0
6919,Bytes that were not part of  the original length of the sds will be set to zero.,1,0,0,1
6920,"if the specified length is smaller than the current length, no operation  is performed.",1,0,0,1
6921, Make sure added region doesn't contain garbage,1,1,0,1
6922, also set trailing \0 byte,0,0,0,0
6923, Append the specified binary-safe string pointed by 't' of 'len' bytes to the  end of the specified sds string 's'.,0,0,0,0
6924,"After the call, the passed sds string is no longer valid and all the  references must be substituted with the new pointer returned by the call.",1,0,0,1
6925, Append the specified null termianted C string to the sds string 's'.,0,0,0,0
6926,"After the call, the passed sds string is no longer valid and all the  references must be substituted with the new pointer returned by the call.",1,0,0,1
6927, Append the specified sds 't' to the existing sds 's'.,0,0,0,0
6928,"After the call, the modified sds string is no longer valid and all the  references must be substituted with the new pointer returned by the call.",1,0,0,1
6929, Destructively modify the sds string 's' to hold the specified binary  safe string pointed by 't' of length 'len' bytes.,1,0,0,1
6930, Like sdscpylen() but 't' must be a null-termined string so that the length  of the string is obtained with strlen().,0,0,0,0
6931, Helper for sdscatlonglong() doing the actual number -> string  conversion.,1,0,0,1
6932,'s' must point to a string with room for at least  SDS_LLSTR_SIZE bytes.,1,0,0,1
6933,The function returns the length of the null-terminated string  representation stored at 's'.,0,0,0,0
6934," Generate the string representation, this method produces      an reversed string.",0,0,0,0
6935, Compute length and add null term.,0,1,0,1
6936, Reverse the string.,0,1,0,1
6937," Identical sdsll2str(), but for unsigned long long type.",1,0,0,1
6938," Generate the string representation, this method produces      an reversed string.",0,0,0,0
6939, Compute length and add null term.,0,1,0,1
6940, Reverse the string.,0,1,0,1
6941, Create an sds string from a long long value.,1,0,0,1
6942,"It is much faster than:   sdscatprintf(sdsempty(),""%lld\n"", value);",1,0,0,1
6943, Like sdscatprintf() but gets va_list instead of being variadic.,0,0,0,0
6944, We try to start using a static buffer for speed.,1,1,0,1
6945,If not possible we revert to heap allocation.,1,0,0,1
6946, Try with buffers two times bigger every time we fail to      fit the string in the current buffer size.,1,0,0,1
6947, Finally concat the obtained string to the SDS string and return it.,1,0,0,1
6948, Append to the sds string 's' a string obtained using printf-alike format  specifier.,0,0,0,0
6949,"After the call, the modified sds string is no longer valid and all the  references must be substituted with the new pointer returned by the call.",1,0,0,1
6950,"Example:   s = sdsnew(""Sum is: "");  s = sdscatprintf(s,""%d+%d = %d"",a,b,a+b).",1,0,0,1
6951,Often you need to create a string from scratch with the printf-alike  format.,0,0,0,0
6952,"When this is the need, just use sdsempty() as the target string:   s = sdscatprintf(sdsempty(), ""... your format ..."", args);",1,0,0,1
6953," This function is similar to sdscatprintf, but much faster as it does  not rely on sprintf() family functions implemented by the libc that  are often very slow.",1,0,0,1
6954,Moreover directly handling the sds string as  new data is concatenated provides a performance improvement.,1,0,0,1
6955,"However this function only handles an incompatible subset of printf-alike  format specifiers:   %s - C String  %S - SDS string  %i - signed int  %I - 64 bit signed integer (long long, int64_t)  %u - unsigned int  %U - 64 bit unsigned integer (unsigned long long, uint64_t)  %% - Verbatim ""%"" character.",1,0,0,1
6956, Next format specifier byte to process.,0,1,0,1
6957, Position of the next byte to write to dest str.,0,0,0,0
6958, Make sure there is always space for at least 1 char.,1,1,0,1
6959, Handle %% and generally %<unknown>.,1,1,0,1
6960, Add null-term,0,1,0,1
6961," Remove the part of the string from left and from right composed just of  contiguous characters found in 'cset', that is a null terminted C string.",1,0,0,1
6962,"After the call, the modified sds string is no longer valid and all the  references must be substituted with the new pointer returned by the call.",1,0,0,1
6963,"Example:   s = sdsnew(""AA...AA.a.aa.aHelloWorld     :::"");  s = sdstrim(s,""Aa.",1,0,0,1
6964,":"");  printf(""%s\n"", s);   Output will be just ""Hello World"".",0,0,0,0
6965, Turn the string into a smaller (or equal) string containing only the  substring specified by the 'start' and 'end' indexes.,1,0,0,1
6966,"start and end can be negative, where -1 means the last character of the  string, -2 the penultimate character, and so forth.",1,0,0,1
6967,"The interval is inclusive, so the start and end characters will be part  of the resulting string.",0,0,0,0
6968,The string is modified in-place.,0,1,0,1
6969,"Example:   s = sdsnew(""Hello World"");  sdsrange(s,1,-1); => ""ello World""",1,0,0,1
6970, Apply tolower() to every character of the sds string 's'.,0,0,0,0
6971, Apply toupper() to every character of the sds string 's'.,0,0,0,0
6972, Compare two sds strings s1 and s2 with memcmp().,0,0,0,0
6973,Return value:       positive if s1 > s2.,1,0,0,1
6974,negative if s1 < s2.,1,0,0,1
6975,0 if s1 and s2 are exactly the same binary string.,1,1,0,1
6976,"If two strings share exactly the same prefix, but one of the two has  additional characters, the longer string is considered to be greater than  the smaller one.",1,0,0,1
6977, Split 's' with separator in 'sep'.,0,0,0,0
6978,An array  of sds strings is returned.,0,0,0,0
6979,count will be set  by reference to the number of tokens returned.,0,0,0,0
6980,"On out of memory, zero length string, zero length  separator, NULL is returned.",0,0,0,0
6981,Note that 'sep' is able to split a string using  a multi-character separator.,1,0,0,1
6982,"For example  sdssplit(""foo_-_bar"",""_-_""); will return two  elements ""foo"" and ""bar"".",0,0,0,0
6983,This version of the function is binary-safe but  requires length arguments.,0,0,0,0
6984,sdssplit() is just the  same function but for zero-terminated strings.,1,0,0,1
6985, make sure there is room for the next element and the final one,1,0,0,1
6986, search the separator,0,0,0,0
6987, skip the separator,0,0,0,0
6988, Add the final element.,1,1,0,1
6989,We are sure there is room in the tokens array.,1,1,0,1
6990," Free the result returned by sdssplitlen(), or do nothing if 'tokens' is NULL.",1,0,0,1
6991," Append to the sds string ""s"" an escaped string representation where  all the non-printable characters (tested with isprint()) are turned into  escapes in the form ""\n\r\a...."" or ""\x<hex-number>"".",0,0,0,0
6992,"After the call, the modified sds string is no longer valid and all the  references must be substituted with the new pointer returned by the call.",1,0,0,1
6993, Helper function for sdssplitargs() that returns non zero if 'c'  is a valid hex digit.,0,0,0,0
6994, Helper function for sdssplitargs() that converts a hex digit into an  integer from 0 to 15,0,0,0,0
6995," Split a line into arguments, where every argument can be in the  following programming-language REPL-alike form:   foo bar ""newline are supported\n"" and ""\xff\x00otherstuff""   The number of arguments is stored into argc, and an array  of sds is returned.",1,0,0,1
6996,The caller should free the resulting array of sds strings with  sdsfreesplitres().,1,0,0,1
6997,Note that sdscatrepr() is able to convert back a string into  a quoted string in the same format sdssplitargs() is able to parse.,1,0,0,1
6998,"The function returns the allocated tokens on success, even when the  input string is empty, or NULL if the input contains unbalanced  quotes or closed quotes followed by non space characters  as in: ""foo""bar or ""foo'",1,0,0,1
6999, skip blanks,0,0,0,0
7000, get a token,0,0,0,0
7001," set to 1 if we are in ""quotes""",0,0,0,0
7002, set to 1 if we are in 'single quotes',1,0,0,1
7003, add the token to the vector,0,0,0,0
7004, Even on empty input string return something not NULL.,1,1,0,1
7005, Modify the string substituting all the occurrences of the set of  characters specified in the 'from' string to the corresponding character  in the 'to' array.,0,0,0,0
7006,"For instance: sdsmapchars(mystring, ""ho"", ""01"", 2)  will have the effect of turning the string ""hello"" into ""0ell1"".",0,0,0,0
7007,"The function returns the sds string pointer, that is always the same  as the input pointer since no resize is needed.",1,0,0,1
7008, Join an array of C strings using the specified separator (also a C string).,0,1,0,1
7009,Returns the result as an sds string.,0,0,0,0
7010," Like sdsjoin, but joins an array of SDS strings.",0,0,0,0
7011, Wrappers to the allocators used by SDS.,0,0,0,0
7012,Note that SDS will actually  just use the macros defined into sdsalloc.h in order to avoid to pay  the overhead of function calls.,1,0,0,1
7013,"Here we define these wrappers only for  the programs SDS is linked to, if they want to touch the SDS internals  even if they use a different allocator.",1,0,0,1
7014, Run the test a few times in order to hit the first two              SDS header types.,1,0,0,1
7015, ======================== Sentinel global state ===========================,0,1,0,1
7016," Address object, used to describe an ip:port pair.",0,0,0,0
7017, A Sentinel Redis Instance object is monitoring.,0,0,0,0
7018, Subjectively down (no quorum).,1,1,0,1
7019, Objectively down (confirmed by others).,1,1,0,1
7020, A Sentinel with this flag set thinks that                                   its master is down.,1,0,0,1
7021, Failover is in progress for                                           this master.,0,0,0,0
7022, Slave selected for promotion.,0,1,0,1
7023, SLAVEOF <newmaster> sent.,0,0,0,0
7024, Slave synchronization in progress.,0,1,0,1
7025, Slave synchronized with new master.,1,1,0,1
7026, Force failover with master up.,0,0,0,0
7027, SCRIPT KILL already sent on -BUSY,1,1,0,1
7028, Note: times are in milliseconds.,0,1,0,1
7029, Failover machine different states.,1,0,0,1
7030, No failover in progress.,0,0,0,0
7031, Wait for failover_start_time,0,0,0,0
7032, Select slave to promote,0,1,0,1
7033, Slave -> Master,0,1,0,1
7034, Wait slave to change role,0,1,0,1
7035, SLAVEOF newmaster,0,0,0,0
7036, Monitor promoted slave.,0,1,0,1
7037, Generic flags that can be used with different functions.,1,1,0,1
7038,They use higher bits to avoid colliding with the function specific  flags.,1,0,0,1
7039, Script execution flags and limits.,0,1,0,1
7040, 60 seconds max exec time.,0,1,0,1
7041, 30 seconds between retries.,0,1,0,1
7042, SENTINEL SIMULATE-FAILURE command flags.,0,1,0,1
7043, The link to a sentinelRedisInstance.,0,0,0,0
7044,"When we have the same set of Sentinels  monitoring many masters, we have different instances representing the  same Sentinels, one per master, and we need to share the hiredis connections  among them.",1,0,0,1
7045,Oherwise if 5 Sentinels are monitoring 100 masters we create  500 outgoing connections instead of 5.,0,0,0,0
7046,"So this structure represents a reference counted link in terms of the two  hiredis connections for commands and Pub or Sub, and the fields needed for  failure detection, since the ping or pong time are now local to the link: if  the link is available, the instance is avaialbe.",1,0,0,1
7047,"This way we don't just  have 5 connections instead of 500, we also send 5 pings instead of 500.",0,0,0,0
7048,"Links are shared only for Sentinels: master and slave instances have  a link with refcount = 1, always.",1,0,0,1
7049, Number of sentinelRedisInstance owners.,0,0,0,0
7050, Non-zero if we need to reconnect cc or pc.,0,0,0,0
7051, Number of commands sent waiting for a reply.,0,1,0,1
7052, Hiredis context for commands.,0,0,0,0
7053, Hiredis context for Pub  or  Sub.,0,0,0,0
7054, cc connection time.,0,0,0,0
7055, pc connection time.,0,0,0,0
7056, Last time we received any message.,1,1,0,1
7057, Last time the instance replied to ping with                                 a reply we consider valid.,1,0,0,1
7058, Time at which the last pending ping (no pong                                 received after it) was sent.,1,0,0,1
7059,"This field is                                 set to 0 when a pong is received, and set again                                 to the current time if the value is 0 and a new                                 ping is sent.",1,0,0,1
7060, Time at which we sent the last ping.,1,1,0,1
7061,This is                                 only used to avoid sending too many pings                                 during failure.,1,0,0,1
7062,Idle time is computed using                                 the act_ping_time field.,0,0,0,0
7063," Last time the instance replied to ping,                                 whatever the reply was.",1,0,0,1
7064,That's used to check                                 if the link is idle and must be reconnected.,0,0,0,0
7065, Last reconnection attempt performed when                                   the link was down.,1,0,0,1
7066, See SRI_... defines,0,1,0,1
7067, Master name from the point of view of this sentinel.,0,1,0,1
7068," Run ID of this instance, or unique ID if is a Sentinel.",1,1,0,1
7069, Configuration epoch.,0,1,0,1
7070, Master host.,0,1,0,1
7071," Link to the instance, may be shared for Sentinels.",0,1,0,1
7072, Last time we sent hello via Pub or Sub.,1,1,0,1
7073, Only used if SRI_SENTINEL is set.,1,1,0,1
7074,Last time                                 we received a hello from this Sentinel                                 via Pub or Sub.,1,0,0,1
7075, Time of last reply to                                             SENTINEL is-master-down command.,1,0,0,1
7076, Subjectively down since time.,1,1,0,1
7077, Objectively down since time.,1,1,0,1
7078, Consider it down after that period.,1,1,0,1
7079, Time at which we received INFO output from it.,0,1,0,1
7080, Role and the first time we observed it.,1,1,0,1
7081,This is useful in order to delay replacing what the instance reports      with our own configuration.,1,0,0,1
7082,We need to always wait some time in order      to give a chance to the leader to report the new configuration before      we do silly things.,1,0,0,1
7083, Last time slave master addr changed.,1,0,0,1
7084, Master specific.,1,1,0,1
7085, Other sentinels monitoring the same master.,1,1,0,1
7086, Slaves for this master instance.,0,1,0,1
7087, Number of sentinels that need to agree on failure.,1,1,0,1
7088, How many slaves to reconfigure at same time.,1,1,0,1
7089, Password to use for AUTH against master & slaves.,0,1,0,1
7090, Slave specific.,1,1,0,1
7091, Slave replication link down time.,1,1,0,1
7092, Slave priority according to its INFO output.,0,1,0,1
7093, Time at which we sent SLAVE OF <new>,0,1,0,1
7094, Master instance if it's slave.,0,1,0,1
7095, Master host as reported by INFO,0,1,0,1
7096, Master port as reported by INFO,0,1,0,1
7097, Master link status as reported by INFO,0,1,0,1
7098, Slave replication offset.,0,1,0,1
7099, Failover,0,0,0,0
7100," If this is a master instance, this is the runid of                           the Sentinel that should perform the failover.",0,0,0,0
7101,"If                           this is a Sentinel, this is the runid of the Sentinel                           that this Sentinel voted as leader.",0,0,0,0
7102, Epoch of the 'leader' field.,0,1,0,1
7103, Epoch of the currently started failover.,1,0,0,1
7104, See SENTINEL_FAILOVER_STATE_ defines.,0,1,0,1
7105, Last failover attempt start time.,1,0,0,1
7106, Max time to refresh failover state.,0,0,0,0
7107, For what failover_start_time value we                                       logged the failover delay.,0,0,0,0
7108, Promoted slave instance.,0,1,0,1
7109, Scripts executed to notify admin or reconfigure clients: when they      are set to NULL no script is executed.,0,0,0,0
7110, cached INFO output,0,0,0,0
7111, Main state.,1,1,0,1
7112, This sentinel ID.,0,1,0,1
7113, Current epoch.,1,1,0,1
7114, Dictionary of master sentinelRedisInstances.,0,0,0,0
7115,"Key is the instance name, value is the                           sentinelRedisInstance structure pointer.",1,0,0,1
7116, Are we in TILT mode?,0,1,0,1
7117, Number of scripts in execution right now.,1,1,0,1
7118, When TITL started.,0,0,0,0
7119, Last time we ran the time handler.,1,1,0,1
7120, Queue of user scripts to execute.,0,1,0,1
7121, IP addr that is gossiped to other sentinels if                           not NULL.,1,0,0,1
7122, Port that is gossiped to other sentinels if                           non zero.,1,0,0,1
7123, Failures simulation.,0,1,0,1
7124, A script execution job.,0,1,0,1
7125, Script job flags: SENTINEL_SCRIPT_,0,1,0,1
7126, Number of times we tried to execute it.,0,1,0,1
7127, Arguments to call the script.,0,1,0,1
7128," Script execution time if the script is running,                               otherwise 0 if we are allowed to retry the                               execution at any time.",0,0,0,0
7129,"If the script is not                               running and it's not 0, it means: do not run                               before the specified time.",0,0,0,0
7130, Script execution pid.,0,0,0,0
7131," ======================= hiredis ae.c adapters =============================  Note: this implementation is taken from hiredis or adapters or ae.h, however  we have our modified copy for Sentinel in order to use our allocator  and to have full control over how the adapter works.",1,0,0,1
7132, Nothing should be attached when something is already attached,0,1,0,1
7133, Create container for context and r or w events,0,1,0,1
7134, Register functions to start or stop listening for events,0,1,0,1
7135, ============================= Prototypes =================================,0,1,0,1
7136, ========================= Dictionary types ===============================,0,1,0,1
7137, Instance name (sds) -> instance (sentinelRedisInstance pointer)   also used for: sentinelRedisInstance->sentinels dictionary that maps  sentinels ip:port to last seen time in Pub or Sub hello message.,1,0,0,1
7138, hash function,0,0,0,0
7139, key dup,1,0,0,1
7140, val dup,0,0,0,0
7141, key compare,1,0,0,1
7142, key destructor,1,0,0,1
7143, val destructor,0,0,0,0
7144, Instance runid (sds) -> votes (long casted to void)   This is useful into sentinelGetObjectiveLeader() function in order to  count the votes and understand who is the leader.,1,0,0,1
7145, hash function,0,0,0,0
7146, key dup,1,0,0,1
7147, val dup,0,0,0,0
7148, key compare,1,0,0,1
7149, key destructor,1,0,0,1
7150, val destructor,0,0,0,0
7151, =========================== Initialization ===============================,0,1,0,1
7152, This function overwrites a few normal Redis config default with Sentinel  specific defaults.,1,0,0,1
7153, Perform the Sentinel mode initialization.,0,1,0,1
7154," Remove usual Redis commands from the command table, then just add      the SENTINEL command.",1,0,0,1
7155, Initialize various data structures.,1,1,0,1
7156," This function gets called when the server is in Sentinel mode, started,  loaded the configuration, and is ready for normal operations.",1,0,0,1
7157," If this Sentinel has yet no ID set in the configuration file, we      pick a random one and persist the config on disk.",1,0,0,1
7158,From now on this      will be this Sentinel ID across restarts.,0,0,0,0
7159, Pick ID and presist the config.,0,0,0,0
7160, Log its ID to make debugging of issues simpler.,0,1,0,1
7161, We want to generate a +monitor event for every configured master      at startup.,0,0,0,0
7162, ============================== sentinelAddr ==============================,0,0,0,0
7163, Create a sentinelAddr object and return it on success.,1,0,0,1
7164,On error NULL is returned and errno is set to:   ENOENT: Can't resolve the hostname.,0,0,0,0
7165,EINVAL: Invalid port number.,0,1,0,1
7166, Return a duplicate of the source address.,0,1,0,1
7167, Free a Sentinel address.,1,1,0,1
7168,Can't fail.,1,1,0,1
7169, Return non-zero if two addresses are equal.,1,1,0,1
7170, =========================== Events notification ==========================,0,1,0,1
7171," Send an event to log, pub or sub, user notification script.",0,1,0,1
7172,'level' is the log level for logging.,0,0,0,0
7173,Only LL_WARNING events will trigger  the execution of the user notification script.,1,0,0,1
7174,"'type' is the message type, also used as a pub or sub channel name.",0,0,0,0
7175,"'ri', is the redis instance target of this event if applicable, and is  used to obtain the path of the notification script to execute.",0,0,0,0
7176,The remaining arguments are printf-alike.,0,0,0,0
7177,"If the format specifier starts with the two characters ""%@"" then ri is  not NULL, and the message is prefixed with an instance identifier in the  following format:    <instance type> <instance name> <ip> <port>    If the instance type is not master, than the additional string is   added to specify the originating master:    @ <master name> <master ip> <master port>    Any other specifier after ""%@"" is processed by printf itself.",1,0,0,1
7178, Handle %@,0,1,0,1
7179, Use vsprintf for the rest of the formatting if any.,0,0,0,0
7180, Log the message if the log level allows it to be logged.,0,1,0,1
7181, Publish the message via Pub or Sub if it's not a debugging one.,0,1,0,1
7182, Call the notification script if applicable.,0,1,0,1
7183, This function is called only at startup and is used to generate a  +monitor event for every configured master.,1,0,0,1
7184,The same events are also  generated when a master to monitor is added at runtime via the  SENTINEL MONITOR command.,1,0,0,1
7185, ============================ script execution ============================,0,1,0,1
7186, Release a script job structure and all the associated data.,0,1,0,1
7187, Copy the string.,0,1,0,1
7188, Remove the oldest non running script if we already hit the limit.,0,1,0,1
7189, The first node is the oldest as we add on tail.,1,1,0,1
7190," Lookup a script in the scripts queue via pid, and returns the list node  (so that we can easily remove it from the queue if needed).",1,0,0,1
7191, Run pending scripts if we are not already at max number of running  scripts.,0,0,0,0
7192," Find jobs that are not running and run them, from the top to the      tail of the queue, so we run older jobs first.",1,0,0,1
7193, Skip if already running.,0,1,0,1
7194," Skip if it's a retry, but not enough time has elapsed.",1,0,0,1
7195, Parent (fork error).,0,1,0,1
7196,"We report fork errors as signal 99, in order to unify the              reporting with other kind of errors.",1,0,0,1
7197, Child,0,1,0,1
7198, If we are here an error occurred.,0,0,0,0
7199, Don't retry execution.,0,1,0,1
7200, How much to delay the execution of a script that we need to retry after  an error?,1,0,0,1
7201,We double the retry delay for every further retry we do.,1,0,0,1
7202,"So for instance  if RETRY_DELAY is set to 30 seconds and the max number of retries is 10  starting from the second attempt to execute the script the delays are:  30 sec, 60 sec, 2 min, 4 min, 8 min, 16 min, 32 min, 64 min, 128 min.",1,0,0,1
7203," Check for scripts that terminated, and remove them from the queue if the  script terminated successfully.",1,0,0,1
7204,"If instead the script was terminated by  a signal, or returned exit code ""1"", it is scheduled to run again if  the max number of retries did not already elapsed.",0,0,0,0
7205," If the script was terminated by a signal or returns an          exit code of ""1"" (that means: please retry), we reschedule it          if the max number of retries is not already reached.",0,0,0,0
7206," Otherwise let's remove the script, but log the event if the              execution did not terminated in the best of the ways.",1,0,0,1
7207," Kill scripts in timeout, they'll be collected by the  sentinelCollectTerminatedScripts() function.",0,0,0,0
7208, Implements SENTINEL PENDING-SCRIPTS command.,0,1,0,1
7209," This function calls, if any, the client reconfiguration script with the  following parameters:   <master-name> <role> <state> <from-ip> <from-port> <to-ip> <to-port>   It is called every time a failover is performed.",1,0,0,1
7210,"<state> is currently always ""failover"".",1,0,0,1
7211,"<role> is either ""leader"" or ""observer"".",0,0,0,0
7212,"from or to fields are respectively master -> promoted slave addresses for  ""start"" and ""end"".",1,0,0,1
7213, =============================== instanceLink =============================,0,0,0,0
7214, Create a not yet connected link object.,0,1,0,1
7215," We set the act_ping_time to ""now"" even if we actually don't have yet      a connection with the node, nor we sent a ping.",1,0,0,1
7216,This is useful to detect a timeout in case we'll not be able to connect      with the node at all.,1,0,0,1
7217, Disconnect an hiredis connection in the context of an instance link.,0,0,0,0
7218," Decrement the refcount of a link object, if it drops to zero, actually  free it and return NULL.",1,0,0,1
7219,Otherwise don't do anything and return the pointer  to the object.,0,0,0,0
7220,"If we are not going to free the link and ri is not NULL, we rebind all the  pending requests in link->cc (hiredis connection for commands) to a  callback that will just ignore them.",1,0,0,1
7221,This is useful to avoid processing  replies for an instance that no longer exists.,1,0,0,1
7222," This instance may have pending callbacks in the hiredis async              context, having as 'privdata' the instance that we are going to              free.",1,0,0,1
7223,"Let's rewrite the callback list, directly exploiting              hiredis internal data structures, in order to bind them with              a callback that will ignore the reply at all.",1,0,0,1
7224, Not strictly needed.,0,1,0,1
7225, Other active users.,1,1,0,1
7226," This function will attempt to share the instance link we already have  for the same Sentinel in the context of a different master, with the  instance we are passing as argument.",1,0,0,1
7227,"This way multiple Sentinel objects that refer all to the same physical  Sentinel instance but in the context of different masters will use  a single connection, will send a single PING per second for failure  detection and so forth.",1,0,0,1
7228,Return C_OK if a matching Sentinel was found in the context of a  different master and sharing was performed.,1,0,0,1
7229,Otherwise C_ERR  is returned.,0,0,0,0
7230, No way to identify it.,0,1,0,1
7231, Already shared.,0,1,0,1
7232," We want to share with the same physical Sentinel referenced          in other masters, so skip our master.",1,0,0,1
7233, No match.,0,1,0,1
7234, Should never happen but... safer.,0,1,0,1
7235," We identified a matching Sentinel, great!",1,1,0,1
7236,Let's free our link          and use the one of the matching Sentinel.,1,0,0,1
7237," When we detect a Sentinel to switch address (reporting a different IP or port  pair in Hello messages), let's update all the matching Sentinels in the  context of other masters as well and disconnect the links, so that everybody  will be updated.",1,0,0,1
7238,Return the number of updated Sentinel addresses.,0,1,0,1
7239," If there is no match, this master does not know about this          Sentinel, try with the next one.",0,0,0,0
7240, Disconnect the old links if connected.,1,1,0,1
7241, Address already updated for it.,0,1,0,1
7242, Update the address of the matching Sentinel by copying the address          of the Sentinel object that received the address update.,0,0,0,0
7243, This function is called when an hiredis connection reported an error.,0,0,0,0
7244,We set it to NULL and mark the link as disconnected so that it will be  reconnected again.,0,0,0,0
7245,Note: we don't free the hiredis context as hiredis will do it for us  for async connections.,1,0,0,1
7246, Hiredis connection established  or  disconnected callbacks.,0,0,0,0
7247,We need them  just to cleanup our link state.,0,0,0,0
7248, ========================== sentinelRedisInstance =========================,0,0,0,0
7249," Create a redis instance, the following fields must be populated by the  caller if needed:  runid: set to NULL but will be populated once INFO output is received.",1,0,0,1
7250,info_refresh: is set to 0 to mean that we never received INFO so far.,1,0,0,1
7251,If SRI_MASTER is set into initial flags the instance is added to  sentinel.masters table.,0,0,0,0
7252,if SRI_SLAVE or SRI_SENTINEL is set then 'master' must be not NULL and the  instance is added into master->slaves or master->sentinels table.,0,0,0,0
7253,"If the instance is a slave or sentinel, the name parameter is ignored and  is created automatically as hostname:port.",0,0,0,0
7254,The function fails if hostname can't be resolved or port is out of range.,1,0,0,1
7255,When this happens NULL is returned and errno is set accordingly to the  createSentinelAddr() function.,0,0,0,0
7256,"The function may also fail and return NULL with errno set to EBUSY if  a master with the same name, a slave with the same address, or a sentinel  with the same ID already exists.",1,0,0,1
7257, Check address validity.,0,1,0,1
7258, For slaves use ip:port as name.,0,0,0,0
7259, Make sure the entry is not duplicated.,1,1,0,1
7260,This may happen when the same      name for a master is used multiple times inside the configuration or      if we try to add multiple times a slave or sentinel with same ip or port      to a master.,1,0,0,1
7261, Create the instance object.,0,1,0,1
7262," Note that all the instances are started in the disconnected state,      the event loop will take care of connecting them.",0,0,0,0
7263, Failover state.,0,0,0,0
7264, Role,0,1,0,1
7265, Add into the right table.,1,1,0,1
7266," Release this instance and all its slaves, sentinels, hiredis connections.",0,0,0,0
7267,This function does not take care of unlinking the instance from the main  masters table (if it is a master) or from its master sentinels or slaves table  if it is a slave or sentinel.,1,0,0,1
7268, Release all its slaves or sentinels if any.,0,1,0,1
7269, Disconnect the instance.,0,1,0,1
7270, Free other resources.,1,1,0,1
7271, Clear state into the master if needed.,1,1,0,1
7272," Lookup a slave in a master Redis instance, by ip and port.",0,0,0,0
7273, Return the name of the type of the instance as a string.,0,1,0,1
7274, This function remove the Sentinel with the specified ID from the  specified master.,0,0,0,0
7275,"If ""runid"" is NULL the function returns ASAP.",0,0,0,0
7276,"This function is useful because on Sentinels address switch, we want to  remove our old entry and add a new one for the same ID but with the new  address.",1,0,0,1
7277,"The function returns 1 if the matching Sentinel was removed, otherwise  0 if there was no Sentinel with this ID.",0,0,0,0
7278," Search an instance with the same runid, ip and port into a dictionary  of instances.",1,0,0,1
7279,"Return NULL if not found, otherwise return the instance  pointer.",0,0,0,0
7280,runid or ip can be NULL.,0,0,0,0
7281,In such a case the search is performed only  by the non-NULL field.,1,0,0,1
7282, User must pass at least one search param.,1,0,0,1
7283, Master lookup by name,0,0,0,0
7284, Add the specified flags to all the instances in the specified dictionary.,0,1,0,1
7285, Remove the specified flags to all the instances in the specified  dictionary.,0,0,0,0
7286, Reset the state of a monitored master:  1) Remove all slaves.,0,0,0,0
7287,2) Remove all sentinels.,0,1,0,1
7288,3) Remove most of the flags resulting from runtime operations.,1,0,0,1
7289,4) Reset timers to their default value.,0,1,0,1
7290,"For example after a reset it will be     possible to failover again the same master ASAP, without waiting the     failover timeout delay.",1,0,0,1
7291,5) In the process of doing this undo the failover if in progress.,0,0,0,0
7292,6) Disconnect the connections with the master (will reconnect automatically).,0,1,0,1
7293, We can failover again ASAP.,0,0,0,0
7294, Call sentinelResetMaster() on every master with a name matching the specified  pattern.,0,0,0,0
7295," Reset the specified master with sentinelResetMaster(), and also change  the ip:port address, but take the name of the instance unmodified.",0,0,0,0
7296,This is used to handle the +switch-master event.,0,1,0,1
7297,The function returns C_ERR if the address can't be resolved for some  reason.,0,0,0,0
7298,Otherwise C_OK is returned.,0,0,0,0
7299, Make a list of slaves to add back after the reset.,0,1,0,1
7300,Don't include the one having the address we are switching to.,0,1,0,1
7301," If we are switching to a different address, include the old address      as a slave as well, so that we'll be able to sense  or  reconfigure      the old master.",1,0,0,1
7302, Reset and switch address.,0,1,0,1
7303, Add slaves back.,0,1,0,1
7304, Release the old address at the end so we are safe even if the function      gets the master->addr->ip and master->addr->port as arguments.,1,0,0,1
7305, Return non-zero if there was no SDOWN or ODOWN error associated to this  instance in the latest 'ms' milliseconds.,1,0,0,1
7306," Return the current master address, that is, its address or the address  of the promoted slave if already operational.",1,0,0,1
7307," If we are failing over the master, and the state is already      SENTINEL_FAILOVER_STATE_RECONF_SLAVES or greater, it means that we      already have the new configuration epoch in the master, and the      slave acknowledged the configuration switch.",1,0,0,1
7308,Advertise the new      address.,1,0,0,1
7309, This function sets the down_after_period field value in 'master' to all  the slaves and sentinel instances connected to this master.,0,0,0,0
7310, ============================ Config handling =============================,0,0,0,0
7311, monitor <name> <host> <port> <quorum>,0,0,0,0
7312, down-after-milliseconds <name> <milliseconds>,0,0,0,0
7313, failover-timeout <name> <milliseconds>,0,0,0,0
7314, parallel-syncs <name> <milliseconds>,0,0,0,0
7315, notification-script <name> <path>,0,0,0,0
7316, client-reconfig-script <name> <path>,0,0,0,0
7317, auth-pass <name> <password>,0,0,0,0
7318, current-epoch <epoch>,0,0,0,0
7319, config-epoch <name> <epoch>,0,0,0,0
7320," The following update of current_epoch is not really useful as          now the current epoch is persisted on the config file, but          we leave this check here for redundancy.",1,0,0,1
7321, leader-epoch <name> <epoch>,0,0,0,0
7322, known-slave <name> <ip> <port>,0,0,0,0
7323, Ignore the old form without runid.,1,0,0,1
7324, known-sentinel <name> <ip> <port> [runid],0,0,0,0
7325, announce-ip <ip-address>,0,0,0,0
7326, announce-port <port>,0,0,0,0
7327," Implements CONFIG REWRITE for ""sentinel"" option.",0,0,0,0
7328,"This is used not just to rewrite the configuration given by the user  (the configured masters) but also in order to retain the state of  Sentinel across restarts: config epoch of masters, associated slaves  and sentinel instances, and so forth.",0,0,0,0
7329, sentinel unique ID.,1,0,0,1
7330," For every master emit a ""sentinel monitor"" config entry.",0,0,0,0
7331, sentinel monitor,0,0,0,0
7332, sentinel down-after-milliseconds,0,0,0,0
7333, sentinel failover-timeout,0,0,0,0
7334, sentinel parallel-syncs,0,0,0,0
7335, sentinel notification-script,0,0,0,0
7336, sentinel client-reconfig-script,0,0,0,0
7337, sentinel auth-pass,0,0,0,0
7338, sentinel config-epoch,0,0,0,0
7339, sentinel leader-epoch,0,0,0,0
7340, sentinel known-slave,0,0,0,0
7341," If master_addr (obtained using sentinelGetCurrentMasterAddress()              so it may be the address of the promoted slave) is equal to this              slave's address, a failover is in progress and the slave was              already successfully promoted.",1,0,0,1
7342,So as the address of this slave              we use the old master address instead.,1,0,0,1
7343, sentinel known-sentinel,0,0,0,0
7344, sentinel current-epoch is a global state valid for all the masters.,0,0,0,0
7345, sentinel announce-ip.,0,0,0,0
7346, sentinel announce-port.,0,0,0,0
7347, This function uses the config rewriting Redis engine in order to persist  the state of the Sentinel in the current configuration file.,1,0,0,1
7348,Before returning the function calls fsync() against the generated  configuration file to make sure changes are committed to disk.,1,0,0,1
7349,On failure the function logs a warning on the Redis log.,1,0,0,1
7350, ====================== hiredis connection handling =======================,0,0,0,0
7351, Send the AUTH command with the specified master password if needed.,0,1,0,1
7352,Note that for slaves the password set for the master is used.,0,1,0,1
7353,"We don't check at all if the command was successfully transmitted  to the instance as if it fails Sentinel will detect the instance down,  will disconnect and reconnect the link and so forth.",1,0,0,1
7354," Use CLIENT SETNAME to name the connection in the Redis instance as  sentinel-<first_8_chars_of_runid>-<connection_type>  The connection type is ""cmd"" or ""pubsub"" as specified by 'type'.",0,0,0,0
7355,"This makes it possible to list all the sentinel instances connected  to a Redis servewr with CLIENT LIST, grepping for a specific name format.",1,0,0,1
7356, Create the async connections for the instance link if the link  is disconnected.,0,0,0,0
7357,Note that link->disconnected is true even if just  one of the two links (commands and pub or sub) is missing.,1,0,0,1
7358, port == 0 means invalid address.,0,0,0,0
7359, Commands connection.,0,1,0,1
7360, Send a PING ASAP when reconnecting.,0,1,0,1
7361, Pub  or  Sub,0,0,0,0
7362," Now we subscribe to the Sentinels ""Hello"" channel.",0,0,0,0
7363," If we can't subscribe, the Pub or Sub connection is useless                  and we can simply disconnect it and try again.",1,0,0,1
7364, Clear the disconnected status only if we have both the connections      (or just the commands connection if this is a sentinel instance).,1,0,0,1
7365, ======================== Redis instances pinging  ========================,0,0,0,0
7366," Return true if master looks ""sane"", that is:  1) It is actually a master in the current configuration.",1,0,0,1
7367,2) It reports itself as a master.,0,1,0,1
7368,3) It is not SDOWN or ODOWN.,0,1,0,1
7369,4) We obtained last INFO no more than two times the INFO period time ago.,1,1,0,1
7370, Process the INFO output from masters.,0,1,0,1
7371, cache full INFO output for instance,1,0,0,1
7372, The following fields must be reset to a given value in the case they      are not found at all in the INFO output.,1,0,0,1
7373, Process line by line.,0,1,0,1
7374, run_id:<40 hex chars>,0,0,0,0
7375," old versions: slave0:<ip>,<port>,<state>          new versions: slave0:ip=127.0.0.1,port=9999,...",1,0,0,1
7376, Old format.,1,1,0,1
7377, Now ip points to start of ip address.,0,0,0,0
7378, nul term for easy access.,1,0,0,1
7379, Now port points to start of port number.,0,1,0,1
7380, nul term for easy access.,1,0,0,1
7381, New format.,1,1,0,1
7382, Now ip points to start of ip address.,0,0,0,0
7383, Now port points to start of port number.,0,1,0,1
7384, Nul term both fields for easy access.,1,0,0,1
7385," Check if we already have this slave into our table,              otherwise add it.",0,0,0,0
7386, master_link_down_since_seconds:<seconds>,0,0,0,0
7387, role:<role>,0,0,0,0
7388, master_host:<host>,0,0,0,0
7389, master_port:<port>,0,0,0,0
7390, master_link_status:<status>,0,0,0,0
7391, slave_priority:<priority>,0,0,0,0
7392, slave_repl_offset:<offset>,0,0,0,0
7393," ---------------------------- Acting half -----------------------------      Some things will not happen if sentinel.tilt is true, but some will      still be processed.",1,0,0,1
7394, Remember when the role changed.,0,1,0,1
7395, Log the event with +role-change if the new role is coherent or          with -role-change if there is a mismatch with the current config.,1,0,0,1
7396," None of the following conditions are processed when in tilt mode, so      return asap.",1,0,0,1
7397, Handle master -> slave role switch.,0,1,0,1
7398," Nothing to do, but masters claiming to be slaves are          considered to be unreachable by Sentinel, so eventually          a failover will be triggered.",0,0,0,0
7399, Handle slave -> master role switch.,0,1,0,1
7400, If this is a promoted slave we can change state to the          failover state machine.,0,0,0,0
7401, Now that we are sure the slave was reconfigured as a master              set the master configuration epoch to the epoch we won the              election to perform this failover.,1,0,0,1
7402,This will force the other              Sentinels to update their config (assuming there is not              a newer one already available).,1,0,0,1
7403, A slave turned into a master.,0,1,0,1
7404,We want to force our view and              reconfigure as slave.,0,0,0,0
7405,"Wait some time after the change before              going forward, to receive new configs if any.",1,0,0,1
7406, Handle slaves replicating to a different master address.,1,1,0,1
7407, Make sure the master is sane before reconfiguring this instance          into a slave.,1,0,0,1
7408, Detect if the slave that is in the process of being reconfigured      changed state.,0,0,0,0
7409, SRI_RECONF_SENT -> SRI_RECONF_INPROG.,0,1,0,1
7410, SRI_RECONF_INPROG -> SRI_RECONF_DONE,0,1,0,1
7411, Just discard the reply.,0,1,0,1
7412,We use this when we are not monitoring the return  value of the command but its effects directly.,1,0,0,1
7413," Update the ""instance available"" field only if this is an          acceptable reply.",1,0,0,1
7414, Flag the pong as received.,0,1,0,1
7415, Send a SCRIPT KILL command if the instance appears to be              down because of a busy script.,1,0,0,1
7416, This is called when we get the reply about the PUBLISH command we send  to the master to advertise this sentinel.,0,0,0,0
7417, Only update pub_time if we actually published our message.,1,0,0,1
7418,Otherwise      we'll retry again in 100 milliseconds.,0,0,0,0
7419," Process an hello message received via Pub or Sub in master or slave instance,  or sent directly to this sentinel via the (fake) PUBLISH command of Sentinel.",1,0,0,1
7420,"If the master name specified in the message is not known, the message is  discarded.",0,0,0,0
7421," Format is composed of 8 tokens:      0=ip,1=port,2=runid,3=current_epoch,4=master_name,      5=master_ip,6=master_port,7=master_config_epoch.",0,0,0,0
7422, Obtain a reference to the master this hello message is about,0,1,0,1
7423," Unknown master, skip the message.",1,1,0,1
7424," First, try to see if we already have this sentinel.",1,1,0,1
7425," If not, remove all the sentinels that have the same runid              because there was an address change, and add the same Sentinel              with the new address back.",1,0,0,1
7426, Check if there is another Sentinel with the same address this                  new one is reporting.,1,0,0,1
7427,"What we do if this happens is to set its                  port to 0, to signal the address is invalid.",0,0,0,0
7428,We'll update it                  later if we get an HELLO message.,0,0,0,0
7429, It means: invalid address.,0,1,0,1
7430, Add the new sentinel.,1,1,0,1
7431," The runid is NULL after a new instance creation and                  for Sentinels we don't have a later chance to fill it,                  so do it now.",1,0,0,1
7432, Update local current_epoch if received current_epoch is greater.,1,0,0,1
7433, Update master info if received configuration is newer.,0,1,0,1
7434, Update the state of the Sentinel.,0,1,0,1
7435, This is our Pub or Sub callback for the Hello channel.,0,1,0,1
7436,It's useful in order  to discover other sentinels attached at the same master.,1,0,0,1
7437, Update the last activity in the pubsub channel.,1,0,0,1
7438,Note that since we      receive our messages as well this timestamp can be used to detect      if the link is probably disconnected even if it seems otherwise.,0,0,0,0
7439," Sanity check in the reply we expect, so that the code that follows      can avoid to check for details.",0,0,0,0
7440, We are not interested in meeting ourselves,1,1,0,1
7441," Send an ""Hello"" message via Pub or Sub to the specified 'ri' Redis  instance in order to broadcast the current configuraiton for this  master, and to advertise the existence of this Sentinel at the same time.",1,0,0,1
7442,"The message has the following format:   sentinel_ip,sentinel_port,sentinel_runid,current_epoch,  master_name,master_ip,master_port,master_config_epoch.",1,0,0,1
7443,"Returns C_OK if the PUBLISH was queued correctly, otherwise  C_ERR is returned.",0,0,0,0
7444," Use the specified announce address if specified, otherwise try to      obtain our own IP address.",1,0,0,1
7445, Format and send the Hello message.,0,1,0,1
7446, Info about this sentinel.,0,1,0,1
7447, Info about current master.,1,1,0,1
7448, Reset last_pub_time in all the instances in the specified dictionary  in order to force the delivery of an Hello update ASAP.,0,0,0,0
7449," This function forces the delivery of an ""Hello"" message (see  sentinelSendHello() top comment for further information) to all the Redis  and Sentinel instances related to the specified 'master'.",1,0,0,1
7450,"It is technically not needed since we send an update to every instance  with a period of SENTINEL_PUBLISH_PERIOD milliseconds, however when a  Sentinel upgrades a configuration it is a good idea to deliever an update  to the other Sentinels ASAP.",1,0,0,1
7451," Send a PING to the specified instance and refresh the act_ping_time  if it is zero (that is, if we received a pong for the previous ping).",1,0,0,1
7452,"On error zero is returned, and we can't consider the PING command  queued in the connection.",0,0,0,0
7453," We update the active ping time only if we received the pong for          the previous ping, otherwise we are technically waiting since the          first ping that did not received a reply.",1,0,0,1
7454," Send periodic PING, INFO, and PUBLISH to the Hello channel to  the specified master or slave instance.",0,0,0,0
7455," Return ASAP if we have already a PING or INFO already pending, or      in the case the instance is not properly connected.",1,0,0,1
7456," For INFO, PING, PUBLISH that are not critical commands to send we      also have a limit of SENTINEL_MAX_PENDING_COMMANDS.",1,0,0,1
7457,"We don't      want to use a lot of memory just because a link is not working      properly (note that anyway there is a redundant protection about this,      that is, the link will be disconnected and reconnected if a long      timeout condition is detected.",1,0,0,1
7458," If this is a slave of a master in O_DOWN condition we start sending      it INFO every second, instead of the usual SENTINEL_INFO_PERIOD      period.",1,0,0,1
7459,"In this state we want to closely monitor slaves in case they      are turned into masters by another Sentinel, or by the sysadmin.",0,0,0,0
7460,"Similarly we monitor the INFO output more often if the slave reports      to be disconnected from the master, so that we can have a fresh      disconnection time figure.",1,0,0,1
7461," We ping instances every time the last received pong is older than      the configured 'down-after-milliseconds' time, but every second      anyway if 'down-after-milliseconds' is greater than 1 second.",1,0,0,1
7462," Send INFO to masters and slaves, not sentinels.",0,1,0,1
7463, Send PING to all the three kinds of instances.,0,1,0,1
7464, PUBLISH hello messages to all the three kinds of instances.,0,1,0,1
7465, =========================== SENTINEL command =============================,0,1,0,1
7466, Redis instance to Redis protocol representation.,0,0,0,0
7467," remove last "",""",1,0,0,1
7468, Masters and Slaves,0,1,0,1
7469, Only masters,1,1,0,1
7470, Only slaves,1,1,0,1
7471, Only sentinels,1,1,0,1
7472, Output a number of instances contained inside a dictionary as  Redis protocol.,0,0,0,0
7473, Lookup the named master into sentinel.masters.,0,0,0,0
7474,If the master is not found reply to the client with an error and returns  NULL.,0,0,0,0
7475, Number of usable Sentinels.,0,1,0,1
7476,Init to 1 to count myself.,0,0,0,0
7477, Known Sentinels + myself.,0,1,0,1
7478, SENTINEL MASTERS,0,1,0,1
7479, SENTINEL MASTER <name>,0,1,0,1
7480, SENTINEL SLAVES <master-name>,0,1,0,1
7481, SENTINEL SENTINELS <master-name>,0,1,0,1
7482, SENTINEL IS-MASTER-DOWN-BY-ADDR <ip> <port> <current-epoch> <runid>                   Arguments:                   ip and port are the ip and port of the master we want to be          checked by Sentinel.,0,0,0,0
7483,"Note that the command will not check by          name but just by master, in theory different Sentinels may monitor          differnet masters with the same name.",1,0,0,1
7484,current-epoch is needed in order to understand if we are allowed          to vote for a failover leader or not.,0,0,0,0
7485,Each Sentinel can vote just          one time per epoch.,0,0,0,0
7486,"runid is """" if we are not seeking for a vote from the Sentinel          in order to elect the failover leader.",1,0,0,1
7487,Otherwise it is set to the          runid we want the Sentinel to vote if it did not already voted.,0,0,0,0
7488, It exists?,0,1,0,1
7489,Is actually a master?,1,1,0,1
7490,Is subjectively down?,1,1,0,1
7491,It's down.,1,1,0,1
7492,"Note: if we are in tilt mode we always reply with ""0"".",0,0,0,0
7493," Vote for the master (or fetch the previous vote) if the request          includes a runid, otherwise the sender is not seeking for a vote.",1,0,0,1
7494," Reply with a three-elements multi-bulk reply:          down state, leader, vote epoch.",1,0,0,1
7495, SENTINEL RESET <pattern>,0,1,0,1
7496, SENTINEL GET-MASTER-ADDR-BY-NAME <master-name>,0,1,0,1
7497, SENTINEL FAILOVER <master-name>,0,1,0,1
7498, SENTINEL PENDING-SCRIPTS,0,1,0,1
7499, SENTINEL MONITOR <name> <ip> <port> <quorum>,0,0,0,0
7500," Make sure the IP field is actually a valid IP before passing it          to createSentinelRedisInstance(), otherwise we may trigger a          DNS lookup at runtime.",1,0,0,1
7501, Parameters are valid.,0,1,0,1
7502,Try to create the master instance.,0,1,0,1
7503, SENTINEL REMOVE <name>,0,1,0,1
7504, SENTINEL CKQUORUM <name>,0,1,0,1
7505, SENTINEL INFO-CACHE <name>,0,1,0,1
7506, Create an ad-hoc dictionary type so that we can iterate          a dictionary composed of just the master groups the user          requested.,0,0,0,0
7507, ignore non-existing names,0,0,0,0
7508, Reply format:            1.),0,0,0,0
7509,master name            2.),0,0,0,0
7510,info from master                2.),0,0,0,0
7511,info from replica                ...,0,0,0,0
7512,other master name            ...,1,0,0,1
7513, +1 for self,0,1,0,1
7514, SENTINEL SIMULATE-FAILURE <flag> <flag> ... <flag>,0,1,0,1
7515, SENTINEL INFO [section],0,1,0,1
7516, Implements Sentinel verison of the ROLE command.,0,0,0,0
7517,"The output is  ""sentinel"" and the list of currently monitored master names.",1,0,0,1
7518, SENTINEL SET <mastername> [<option> <value> ...],0,0,0,0
7519, Process option - value pairs.,0,1,0,1
7520, down-after-millisecodns <milliseconds>,0,0,0,0
7521, failover-timeout <milliseconds>,0,0,0,0
7522, parallel-syncs <milliseconds>,0,0,0,0
7523, notification-script <path>,0,0,0,0
7524, client-reconfig-script <path>,0,0,0,0
7525, auth-pass <password>,0,0,0,0
7526, quorum <count>,0,0,0,0
7527, Bad format errors,1,1,0,1
7528," Our fake PUBLISH command: it is actually useful only to receive hello messages  from the other sentinel instances, and publishing to a channel other than  SENTINEL_HELLO_CHANNEL is forbidden.",1,0,0,1
7529,"Because we have a Sentinel PUBLISH, the code to send hello messages is the same  for all the three kind of instances: masters, slaves, sentinels.",1,0,0,1
7530, ===================== SENTINEL availability checks =======================,0,1,0,1
7531, Is this instance down from our point of view?,1,1,0,1
7532," Check if we are in need for a reconnection of one of the      links, because we are detecting low activity.",1,0,0,1
7533,"1) Check if the command link seems connected, was connected not less         than SENTINEL_MIN_LINK_RECONNECT_PERIOD, but still we have a         pending ping for more than half the timeout.",1,0,0,1
7534, Ther is a pending ping...,0,0,0,0
7535," The pending ping is delayed, and we did not received          error replies as well.",0,0,0,0
7536," 2) Check if the pubsub link seems connected, was connected not less         than SENTINEL_MIN_LINK_RECONNECT_PERIOD, but still we have no         activity in the Pub or Sub channel for more than         SENTINEL_PUBLISH_PERIOD  3.",1,0,0,1
7537, Update the SDOWN flag.,0,1,0,1
7538,We believe the instance is SDOWN if:           1) It is not replying.,0,0,0,0
7539,"2) We believe it is a master, it reports to be a slave for enough time         to meet the down_after_period, plus enough time to get two times         INFO report from the instance.",1,0,0,1
7540, Is subjectively down,1,1,0,1
7541, Is subjectively up,0,1,0,1
7542, Is this instance down according to the configured quorum?,1,1,0,1
7543,"Note that ODOWN is a weak quorum, it only means that enough Sentinels  reported in a given time range that the instance was not reachable.",1,0,0,1
7544,However messages can be delayed so there are no strong guarantees about  N instances agreeing at the same time about the down state.,1,0,0,1
7545, Is down for enough sentinels?,1,1,0,1
7546, the current sentinel.,1,0,0,1
7547, Count all the other sentinels.,1,1,0,1
7548, Set the flag accordingly to the outcome.,0,1,0,1
7549," Receive the SENTINEL is-master-down-by-addr reply, see the  sentinelAskMasterStateToOtherSentinels() function for more information.",1,0,0,1
7550, Ignore every error or unexpected reply.,1,1,0,1
7551,Note that if the command returns an error for any reason we'll      end clearing the SRI_MASTER_DOWN flag for timeout anyway.,0,0,0,0
7552," If the runid in the reply is not """" the Sentinel actually              replied with a vote.",1,0,0,1
7553," If we think the master is down, we start sending  SENTINEL IS-MASTER-DOWN-BY-ADDR requests to other sentinels  in order to get the replies that allow to reach the quorum  needed to mark the master in ODOWN state and trigger a failover.",1,0,0,1
7554," If the master state from other sentinel is too old, we clear it.",1,1,0,1
7555," Only ask if master is down to other sentinels if:                   1) We believe it is down, or there is a failover in progress.",1,0,0,1
7556,2) Sentinel is connected.,0,1,0,1
7557,3) We did not received the info within SENTINEL_ASK_PERIOD ms.,0,0,0,0
7558, Ask,0,1,0,1
7559, =============================== FAILOVER =================================,0,1,0,1
7560, Crash because of user request via SENTINEL simulate-failure command.,0,1,0,1
7561, Vote for the sentinel with 'req_runid' or return the old vote if already  voted for the specifed 'req_epoch' or one greater.,1,0,0,1
7562,"If a vote is not available returns NULL, otherwise return the Sentinel  runid and populate the leader_epoch with the epoch of the vote.",1,0,0,1
7563," If we did not voted for ourselves, set the master failover start          time to now, in order to force a delay before we can start a          failover for the same master.",1,0,0,1
7564," Helper function for sentinelGetLeader, increment the counter  relative to the specified runid.",0,0,0,0
7565, Scan all the Sentinels attached to this master to check if there  is a leader for the specified epoch.,0,0,0,0
7566,"To be a leader for a given epoch, we should have the majority of  the Sentinels we know (ever seen since the last SENTINEL RESET) that  reported the same instance as leader for the same epoch.",1,0,0,1
7567, All the other sentinels and me.,1,1,0,1
7568, Count other sentinels votes,1,1,0,1
7569, Check what's the winner.,0,1,0,1
7570,"For the winner to win, it needs two conditions:      1) Absolute majority between voters (50% + 1).",1,0,0,1
7571,2) And anyway at least master->quorum votes.,1,1,0,1
7572," Count this Sentinel vote:      if this Sentinel did not voted yet, either vote for the most      common voted sentinel, or for itself if no vote exists at all.",1,0,0,1
7573," Send SLAVEOF to the specified instance, always followed by a  CONFIG REWRITE command in order to store the new configuration on disk  when possible (that is, if the Redis instance is recent enough to support  config rewriting, and if the server was started with a configuration file).",1,0,0,1
7574,"If Host is NULL the function sends ""SLAVEOF NO ONE"".",0,0,0,0
7575,The command returns C_OK if the SLAVEOF command was accepted for  (later) delivery otherwise C_ERR.,0,0,0,0
7576,The command replies are just  discarded.,0,0,0,0
7577, If host is NULL we send SLAVEOF NO ONE that will turn the instance      into a master.,0,0,0,0
7578," In order to send SLAVEOF in a safe way, we send a transaction performing      the following tasks:      1) Reconfigure the instance according to the specified host or port params.",1,0,0,1
7579,2) Rewrite the configuraiton.,0,0,0,0
7580,3) Disconnect all clients (but this one sending the commnad) in order         to trigger the ask-master-on-reconnection protocol for connected         clients.,0,0,0,0
7581,"Note that we don't check the replies returned by commands, since we      will observe instead the effects in the next INFO output.",0,0,0,0
7582," CLIENT KILL TYPE <type> is only supported starting from Redis 2.8.12,      however sending it to an instance not understanding this command is not      an issue because CLIENT is variadic command, so Redis will not      recognized as a syntax error, and the transaction will not fail (but      only the unsupported command will fail).",1,0,0,1
7583, Setup the master state to start a failover.,0,0,0,0
7584," This function checks if there are the conditions to start the failover,  that is:   1) Master must be in ODOWN condition.",0,0,0,0
7585,2) No failover already in progress.,0,0,0,0
7586,3) No failover already attempted recently.,1,0,0,1
7587,We still don't know if we'll win the election so it is possible that we  start the failover but that we'll not be able to act.,1,0,0,1
7588,Return non-zero if a failover was started.,0,0,0,0
7589, We can't failover if the master is not in O_DOWN state.,0,0,0,0
7590, Failover already in progress?,0,0,0,0
7591, Last failover attempt started too little time ago?,1,0,0,1
7592, Remove newline.,0,1,0,1
7593, Select a suitable slave to promote.,1,1,0,1
7594,"The current algorithm only uses  the following parameters:   1) None of the following conditions: S_DOWN, O_DOWN, DISCONNECTED.",1,0,0,1
7595,2) Last time the slave replied to ping no more than 5 times the PING period.,1,1,0,1
7596,3) info_refresh not older than 3 times the INFO refresh period.,1,0,0,1
7597,4) master_link_down_time no more than:      (now - master->s_down_since_time) + (master->down_after_period  10).,1,0,0,1
7598,"Basically since the master is down from our POV, the slave reports     to be disconnected no more than 10 times the configured down-after-period.",1,0,0,1
7599,"This is pretty much black magic but the idea is, the master was not     available so the slave may be lagging, but not over a certain time.",1,0,0,1
7600,Anyway we'll select the best slave according to replication offset.,1,1,0,1
7601,"5) Slave priority can't be zero, otherwise the slave is discarded.",0,1,0,1
7602,"Among all the slaves matching the above conditions we select the slave  with, in order of sorting key:   - lower slave_priority.",1,0,0,1
7603,#NAME?,1,1,0,1
7604,#NAME?,1,0,0,1
7605,"Basically if runid is the same, the slave that processed more commands  from the master is selected.",1,0,0,1
7606,"The function returns the pointer to the selected slave, otherwise  NULL if no suitable slave was found.",1,0,0,1
7607, Helper for sentinelSelectSlave().,0,0,0,0
7608,"This is used by qsort() in order to  sort suitable slaves in a ""better first"" order, to take the first of  the list.",1,0,0,1
7609," If priority is the same, select the slave with greater replication      offset (processed more data from the master).",1,0,0,1
7610, a < b,0,0,0,0
7611, a > b,0,0,0,0
7612, If the replication offset is the same select the slave with that has      the lexicographically smaller runid.,1,0,0,1
7613,Note that we try to handle runid      == NULL as there are old Redis versions that don't publish runid in      INFO.,1,0,0,1
7614,A NULL runid is considered bigger than any other runid.,1,0,0,1
7615, a > b,0,0,0,0
7616, a < b,0,0,0,0
7617, If the master is in SDOWN state we get INFO for slaves every second.,0,1,0,1
7618,Otherwise we get it with the usual period so we need to account for          a larger delay.,1,0,0,1
7619, ---------------- Failover state machine implementation -------------------,0,0,0,0
7620, Check if we are the leader for the failover epoch.,0,0,0,0
7621," If I'm not the leader, and it is not a forced failover via      SENTINEL FAILOVER, then I can't continue with the failover.",1,0,0,1
7622, The election timeout is the MIN between SENTINEL_ELECTION_TIMEOUT          and the configured failover timeout.,0,0,0,0
7623, Abort the failover if I'm not the leader after some time.,0,0,0,0
7624, We don't handle the timeout in this state as the function aborts      the failover or go forward in the next state.,0,0,0,0
7625, We can't send the command to the promoted slave if it is now      disconnected.,0,0,0,0
7626,"Retry again and again with this state until the timeout      is reached, then abort the failover.",0,0,0,0
7627, Send SLAVEOF NO ONE command to turn the slave into a master.,0,1,0,1
7628,We actually register a generic callback for this command as we don't      really care about the reply.,1,0,0,1
7629,We check if it worked indirectly observing      if INFO returns a different role (master instead of slave).,1,0,0,1
7630, We actually wait for promotion indirectly checking with INFO when the  slave turns into a master.,1,0,0,1
7631, Just handle the timeout.,0,1,0,1
7632,Switching to the next state is handled      by the function parsing the INFO command of the promoted slave.,0,0,0,0
7633, We can't consider failover finished if the promoted slave is      not reachable.,0,0,0,0
7634, The failover terminates once all the reachable slaves are properly      configured.,1,0,0,1
7635, Force end of failover on timeout.,0,0,0,0
7636, If I'm the leader it is a good idea to send a best effort SLAVEOF      command to all the slaves still not reconfigured to replicate with      the new master.,1,0,0,1
7637, Send SLAVE OF <new master address> to all the remaining slaves that  still don't appear to have the configuration updated.,0,0,0,0
7638," Skip the promoted slave, and already configured slaves.",0,1,0,1
7639," If too much time elapsed without the slave moving forward to          the next state, consider it reconfigured even if it is not.",1,0,0,1
7640,Sentinels will detect the slave as misconfigured and fix its          configuration later.,0,0,0,0
7641, Nothing to do for instances that are disconnected or already          in RECONF_SENT state.,0,0,0,0
7642, Send SLAVEOF <new master>.,0,1,0,1
7643, Check if all the slaves are reconfigured and handle timeout.,0,1,0,1
7644, This function is called when the slave is in  SENTINEL_FAILOVER_STATE_UPDATE_CONFIG state.,0,0,0,0
7645,In this state we need  to remove it from the master table and add the promoted slave instead.,0,0,0,0
7646, Abort a failover in progress:   This function can only be called before the promoted slave acknowledged  the slave -> master switch.,1,0,0,1
7647,Otherwise the failover can't be aborted and  will reach its end (possibly by timeout).,1,0,0,1
7648," ======================== SENTINEL timer handler ==========================  This is the ""main"" our Sentinel, being sentinel completely non blocking  in design.",1,0,0,1
7649,The function is called every second.,0,1,0,1
7650, Perform scheduled operations for the specified Redis instance.,0,0,0,0
7651, ========== MONITORING HALF ============,1,1,0,1
7652, Every kind of instance,1,1,0,1
7653, ============== ACTING HALF =============,1,1,0,1
7654, We don't proceed with the acting half if we are in TILT mode.,1,1,0,1
7655,"TILT happens when we find something odd with the time, like a      sudden change in the clock.",1,0,0,1
7656, Every kind of instance,1,1,0,1
7657, Masters and slaves,0,1,0,1
7658, Nothing so far.,1,1,0,1
7659, Only masters,1,1,0,1
7660, Perform scheduled operations for all the instances in the dictionary.,0,1,0,1
7661,Recursively call the function against dictionaries of slaves.,0,1,0,1
7662, There are a number of things we need to perform against every master.,0,1,0,1
7663, This function checks if we need to enter the TITL mode.,0,1,0,1
7664,"The TILT mode is entered if we detect that between two invocations of the  timer interrupt, a negative amount of time, or too much time has passed.",1,0,0,1
7665,Note that we expect that more or less just 100 milliseconds will pass  if everything is fine.,1,0,0,1
7666,"However we'll see a negative number or a  difference bigger than SENTINEL_TILT_TRIGGER milliseconds if one of the  following conditions happen:   1) The Sentiel process for some time is blocked, for every kind of  random reason: the load is huge, the computer was frozen for some time  in I or O or alike, the process was stopped by a signal.",1,0,0,1
7667,Everything.,0,1,0,1
7668,2) The system clock was altered significantly.,1,1,0,1
7669,Under both this conditions we'll see everything as timed out and failing  without good reasons.,1,0,0,1
7670,Instead we enter the TILT mode and wait  for SENTINEL_TILT_PERIOD to elapse before starting to act again.,1,0,0,1
7671,"During TILT time we still collect information, we just do not act.",0,1,0,1
7672," We continuously change the frequency of the Redis ""timer interrupt""      in order to desynchronize every Sentinel from every other.",1,0,0,1
7673,This non-determinism avoids that Sentinels started at the same time      exactly continue to stay synchronized asking to be voted at the      same time again and again (resulting in nobody likely winning the      election because of split brain voting).,1,0,0,1
7674," Our shared ""common"" objects",1,0,0,1
7675, Global vars that are actually used as constants.,1,1,0,1
7676,"The following double  values are used for double on-disk serialization, and are initialized  at runtime to avoid strange compiler optimizations.",1,0,0,1
7677,================================= Globals =================================,0,0,0,0
7678, Global vars,0,1,0,1
7679, Server global state,0,1,0,1
7680, Server global current LRU time.,1,1,0,1
7681, Our command table.,0,1,0,1
7682,Every entry is composed of the following fields:   name: a string representing the command name.,1,0,0,1
7683,function: pointer to the C function implementing the command.,0,0,0,0
7684,"arity: number of arguments, it is possible to use -N to say >= N  sflags: command flags as string.",1,0,0,1
7685,See below for a table of flags.,0,1,0,1
7686,flags: flags as bitmask.,0,0,0,0
7687,Computed by Redis using the 'sflags' field.,0,0,0,0
7688,get_keys_proc: an optional function to get key arguments from a command.,1,0,0,1
7689,This is only used when the following three fields are not                 enough to specify what arguments are keys.,1,0,0,1
7690,first_key_index: first argument that is a key  last_key_index: last argument that is a key  key_step: step to get all the keys from first to last argument.,1,0,0,1
7691,"For instance            in MSET the step is two since arguments are key,val,key,val,...  microseconds: microseconds of total execution time for this command.",1,0,0,1
7692,calls: total number of calls of this command.,1,0,0,1
7693,"The flags, microseconds and calls fields are computed by Redis and should  always be set to zero.",0,0,0,0
7694,Command flags are expressed using strings where every character represents  a flag.,0,0,0,0
7695,Later the populateCommandTable() function will take care of  populating the real 'flags' field using this characters.,1,0,0,1
7696,This is the meaning of the flags:   w: write command (may modify the key space).,1,0,0,1
7697,r: read command  (will never modify the key space).,1,0,0,1
7698,m: may increase memory usage once called.,0,0,0,0
7699,Don't allow if out of memory.,0,1,0,1
7700,"a: admin command, like SAVE or SHUTDOWN.",0,0,0,0
7701,p: Pub or Sub related command.,1,0,0,1
7702,"f: force replication of this command, regardless of server.dirty.",0,0,0,0
7703,s: command not allowed in scripts.,0,0,0,0
7704,R: random command.,1,1,0,1
7705,"Command is not deterministic, that is, the same command     with the same arguments, with the same key space, may have different     results.",1,0,0,1
7706,For instance SPOP and RANDOMKEY are two random commands.,1,1,0,1
7707,"S: Sort command output array if called from script, so that the output     is deterministic.",0,0,0,0
7708,l: Allow command while loading the database.,0,0,0,0
7709,t: Allow command while a slave has stale data but is not allowed to     server this data.,1,0,0,1
7710,Normally no command is accepted in this condition     but just a few.,1,0,0,1
7711,M: Do not automatically propagate the command on MONITOR.,0,1,0,1
7712,"k: Perform an implicit ASKING for this command, so the command will be     accepted in cluster mode if the slot is marked as 'importing'.",1,0,0,1
7713,F: Fast command: O(1) or O(log(N)) command that should never delay     its execution as long as the kernel scheduler is giving us time.,1,0,0,1
7714,Note that commands that may trigger a DEL as a side effect (like SET)     are not fast commands.,1,0,0,1
7715,============================ Utility functions ============================,0,1,0,1
7716, Low level logging.,1,1,0,1
7717,"To use only for very big messages, otherwise  serverLog() is to prefer.",1,0,0,1
7718, clear flags,1,0,0,1
7719, Sentinel.,0,1,0,1
7720, RDB  or  AOF writing child.,0,0,0,0
7721, Slave or Master.,0,1,0,1
7722, Like serverLogRaw() but with printf-alike support.,0,0,0,0
7723,This is the function that  is used across the code.,0,0,0,0
7724,The raw version is only used in order to dump  the INFO output on crash.,1,0,0,1
7725," Log a fixed message without printf-alike capabilities, in a way that is  safe to call from a signal handler.",1,0,0,1
7726,We actually use this only for signals that are not fatal from the point  of view of Redis.,1,0,0,1
7727,Signals that are going to kill the server anyway and  where we need printf-alike features are served by serverLog().,0,0,0,0
7728, Return the UNIX time in microseconds,0,1,0,1
7729, Return the UNIX time in milliseconds,0,1,0,1
7730," After an RDB dump or AOF rewrite we exit from children using _exit() instead of  exit(), because the latter may interact with the same file objects used by  the parent process.",1,0,0,1
7731,However if we are testing the coverage normal exit() is  used in order to obtain the right coverage information.,1,0,0,1
7732,====================== Hash table type implementation  ====================,0,0,0,0
7733," This is a hash table type that uses the SDS dynamic strings library as  keys and redis objects as values (objects can hold SDS strings,  lists, sets).",1,0,0,1
7734, A case insensitive version used for the command lookup table and other  places where case insensitive non binary-safe comparison is needed.,1,0,0,1
7735, Lazy freeing will set value to NULL.,1,1,0,1
7736," Generic hash table type where keys are Redis Objects, Values  dummy pointers.",0,0,0,0
7737, hash function,0,0,0,0
7738, key dup,1,0,0,1
7739, val dup,0,0,0,0
7740, key compare,1,0,0,1
7741, key destructor,1,0,0,1
7742, val destructor,0,0,0,0
7743," Like objectKeyPointerValueDictType(), but values can be destroyed, if  not NULL, calling zfree().",0,0,0,0
7744, hash function,0,0,0,0
7745, key dup,1,0,0,1
7746, val dup,0,0,0,0
7747, key compare,1,0,0,1
7748, key destructor,1,0,0,1
7749, val destructor,0,0,0,0
7750, Set dictionary type.,0,1,0,1
7751,"Keys are SDS strings, values are ot used.",0,0,0,0
7752, hash function,0,0,0,0
7753, key dup,1,0,0,1
7754, val dup,0,0,0,0
7755, key compare,1,0,0,1
7756, key destructor,1,0,0,1
7757, val destructor,0,0,0,0
7758, Sorted sets hash (note: a skiplist is used in addition to the hash table),0,0,0,0
7759, hash function,0,0,0,0
7760, key dup,1,0,0,1
7761, val dup,0,0,0,0
7762, key compare,1,0,0,1
7763, Note: SDS string shared & freed by skiplist,0,0,0,0
7764, val destructor,0,0,0,0
7765," Db->dict, keys are sds strings, vals are Redis objects.",0,0,0,0
7766, hash function,0,0,0,0
7767, key dup,1,0,0,1
7768, val dup,0,0,0,0
7769, key compare,1,0,0,1
7770, key destructor,1,0,0,1
7771, val destructor,0,0,0,0
7772, server.lua_scripts sha (as sds string) -> scripts (as robj) cache.,0,0,0,0
7773, hash function,0,0,0,0
7774, key dup,1,0,0,1
7775, val dup,0,0,0,0
7776, key compare,1,0,0,1
7777, key destructor,1,0,0,1
7778, val destructor,0,0,0,0
7779, Db->expires,0,1,0,1
7780, hash function,0,0,0,0
7781, key dup,1,0,0,1
7782, val dup,0,0,0,0
7783, key compare,1,0,0,1
7784, key destructor,1,0,0,1
7785, val destructor,0,0,0,0
7786, Command table.,0,1,0,1
7787,sds string -> command struct pointer.,0,0,0,0
7788, hash function,0,0,0,0
7789, key dup,1,0,0,1
7790, val dup,0,0,0,0
7791, key compare,1,0,0,1
7792, key destructor,1,0,0,1
7793, val destructor,0,0,0,0
7794, Hash type hash table (note that small hashes are represented with ziplists),1,0,0,1
7795, hash function,0,0,0,0
7796, key dup,1,0,0,1
7797, val dup,0,0,0,0
7798, key compare,1,0,0,1
7799, key destructor,1,0,0,1
7800, val destructor,0,0,0,0
7801, Keylist hash table type has unencoded redis objects as keys and  lists as values.,0,0,0,0
7802,It's used for blocking operations (BLPOP) and to  map swapped keys to a list of clients waiting for this keys to be loaded.,0,0,0,0
7803, hash function,0,0,0,0
7804, key dup,1,0,0,1
7805, val dup,0,0,0,0
7806, key compare,1,0,0,1
7807, key destructor,1,0,0,1
7808, val destructor,0,0,0,0
7809," Cluster nodes hash table, mapping nodes addresses 1.2.3.4:6379 to  clusterNode structures.",0,0,0,0
7810, hash function,0,0,0,0
7811, key dup,1,0,0,1
7812, val dup,0,0,0,0
7813, key compare,1,0,0,1
7814, key destructor,1,0,0,1
7815, val destructor,0,0,0,0
7816, Cluster re-addition blacklist.,0,1,0,1
7817,This maps node IDs to the time  we can re-add this node.,0,0,0,0
7818,The goal is to avoid readding a removed  node for some time.,0,0,0,0
7819, hash function,0,0,0,0
7820, key dup,1,0,0,1
7821, val dup,0,0,0,0
7822, key compare,1,0,0,1
7823, key destructor,1,0,0,1
7824, val destructor,0,0,0,0
7825, Cluster re-addition blacklist.,0,1,0,1
7826,This maps node IDs to the time  we can re-add this node.,0,0,0,0
7827,The goal is to avoid readding a removed  node for some time.,0,0,0,0
7828, hash function,0,0,0,0
7829, key dup,1,0,0,1
7830, val dup,0,0,0,0
7831, key compare,1,0,0,1
7832, key destructor,1,0,0,1
7833, val destructor,0,0,0,0
7834, Migrate cache dict type.,0,1,0,1
7835, hash function,0,0,0,0
7836, key dup,1,0,0,1
7837, val dup,0,0,0,0
7838, key compare,1,0,0,1
7839, key destructor,1,0,0,1
7840, val destructor,0,0,0,0
7841, Replication cached script dict (server.repl_scriptcache_dict).,0,0,0,0
7842,"Keys are sds SHA1 strings, while values are not used at all in the current  implementation.",1,0,0,1
7843, hash function,0,0,0,0
7844, key dup,1,0,0,1
7845, val dup,0,0,0,0
7846, key compare,1,0,0,1
7847, key destructor,1,0,0,1
7848, val destructor,0,0,0,0
7849, If the percentage of used slots in the HT reaches HASHTABLE_MIN_FILL  we resize the hash table to save memory,0,0,0,0
7850, Our hash table implementation performs rehashing incrementally while  we write or read from the hash table.,0,0,0,0
7851,"Still if the server is idle, the hash  table will use two tables for a long time.",1,0,0,1
7852,So we try to use 1 millisecond  of CPU time at every call of this function to perform some rehahsing.,0,0,0,0
7853,"The function returns 1 if some rehashing was performed, otherwise 0  is returned.",0,0,0,0
7854, Keys dictionary,0,1,0,1
7855, already used our millisecond for this loop...,0,0,0,0
7856, Expires,0,1,0,1
7857, already used our millisecond for this loop...,0,0,0,0
7858," This function is called once a background process of some kind terminates,  as we want to avoid resizing the hash tables when there is a child in order  to play well with copy-on-write (otherwise when a resize happens lots of  memory pages are copied).",1,0,0,1
7859,The goal of this function is to update the ability  for dict.c to resize the hash tables accordingly to the fact we have o not  running childs.,0,0,0,0
7860, ======================= Cron: called every 100 ms ========================,0,0,0,0
7861, Add a sample to the operations per second array of samples.,0,1,0,1
7862, Return the mean of all the samples.,1,1,0,1
7863, Check for timeouts.,0,1,0,1
7864,Returns non-zero if the client was terminated.,0,1,0,1
7865,"The function gets the current time in milliseconds as argument since  it gets called multiple times in a loop, so calling gettimeofday() for  each iteration would be costly without any actual gain.",1,0,0,1
7866, no timeout for slaves,0,0,0,0
7867, no timeout for masters,0,0,0,0
7868, no timeout for BLPOP,0,0,0,0
7869, no timeout for Pub or Sub clients,0,0,0,0
7870, Blocked OPS timeout is handled with milliseconds resolution.,0,1,0,1
7871,However note that the actual resolution is limited by          server.hz.,1,0,0,1
7872, Handle blocking operation specific timeout.,1,1,0,1
7873, Cluster: handle unblock & redirect of clients blocked              into keys no longer served by this server.,0,0,0,0
7874," The client query buffer is an sds.c string that can end with a lot of  free space not used, this function reclaims space if needed.",1,0,0,1
7875,The function always returns 0 as it never terminates the client.,0,1,0,1
7876, There are two conditions to resize the query buffer:      1) Query buffer is > BIG_ARG and too big for latest peak.,1,0,0,1
7877,2) Client is inactive and the buffer is bigger than 1k.,1,1,0,1
7878, Only resize the query buffer if it is actually wasting space.,1,0,0,1
7879, Reset the peak again to capture the peak memory usage in the next      cycle.,0,0,0,0
7880, Make sure to process at least numclients or server.hz of clients      per call.,1,0,0,1
7881,Since this function is called server.hz times per second      we are sure that in the worst case we process all the clients in 1      second.,1,0,0,1
7882," Process at least a few clients while we are at it, even if we need      to process less than CLIENTS_CRON_MIN_ITERATIONS to meet our contract      of processing each client once per second.",1,0,0,1
7883," Rotate the list, take the current head, process.",1,1,0,1
7884,This way if the client must be removed from the list it's the          first element and we don't incur into O(N) computation.,1,0,0,1
7885, The following functions do different service checks on the client.,1,1,0,1
7886,The protocol is that they return non-zero if the client was          terminated.,0,0,0,0
7887," This function handles 'background' operations we are required to do  incrementally in Redis databases, such as active key expiring, resizing,  rehashing.",1,0,0,1
7888, Expire keys by random sampling.,1,1,0,1
7889,Not required for slaves      as master will synthesize DELs for us.,0,0,0,0
7890, Defrag keys gradually.,0,0,0,0
7891," Perform hash tables rehashing if needed, but only if there are no      other processes saving the DB on disk.",1,0,0,1
7892,Otherwise rehashing is bad      as will cause a lot of copy-on-write of memory pages.,1,0,0,1
7893, We use global counters so if we stop the computation at a given          DB we'll be able to start from the successive in the next          cron loop iteration.,1,0,0,1
7894, Don't test more DBs than we have.,1,0,0,1
7895, Resize,0,0,0,0
7896, Rehash,0,1,0,1
7897," If the function did some work, stop here, we'll do                      more at the next cron loop.",1,0,0,1
7898," If this db didn't need rehash, we'll try the next one.",0,1,0,1
7899," We take a cached value of the unix time in the global state because with  virtual memory and aging there is to store the current time in objects at  every object access, and accuracy is not needed.",1,0,0,1
7900,To access a global var is  a lot faster than calling time(NULL),0,0,0,0
7901," This is our timer interrupt, called server.hz times per second.",0,0,0,0
7902,Here is where we do a number of things that need to be done asynchronously.,0,1,0,1
7903,For instance:   - Active expired keys collection (it is also performed in a lazy way on    lookup).,1,0,0,1
7904,#NAME?,0,1,0,1
7905,#NAME?,0,1,0,1
7906,#NAME?,0,0,0,0
7907,#NAME?,0,0,0,0
7908,#NAME?,1,1,0,1
7909,#NAME?,0,0,0,0
7910,"- Many more...   Everything directly called here will be called server.hz times per second,  so in order to throttle execution of things we want to do less frequently  a macro is used: run_with_period(milliseconds) { .... }",1,0,0,1
7911, Software watchdog: deliver the SIGALRM that will reach the signal      handler if we don't return here fast enough.,1,0,0,1
7912, Update the time cache.,0,1,0,1
7913, We have just LRU_BITS bits per object for LRU information.,0,1,0,1
7914,So we use an (eventually wrapping) LRU clock.,0,1,0,1
7915,"Note that even if the counter wraps it's not a big problem,      everything will still work but some object will appear younger      to Redis.",1,0,0,1
7916,"However for this to happen a given object should never be      touched for all the time needed to the counter to wrap, which is      not likely.",1,0,0,1
7917,Note that you can change the resolution altering the      LRU_CLOCK_RESOLUTION define.,0,0,0,0
7918, Record the max memory used since the server was started.,0,1,0,1
7919, Sample the RSS and other metrics here since this is a relatively slow call.,1,1,0,1
7920,"We must sample the zmalloc_used at the same time we take the rss, otherwise          the frag ratio calculate may be off (ratio of two samples at different times)",1,0,0,1
7921, Sampling the allcator info can be slow too.,1,0,0,1
7922,"The fragmentation ratio it'll show is potentically more accurate          it excludes other RSS pages such as: shared libraries, LUA and other non-zmalloc          allocations, and allocator reserved pages that can be pursed (all not actual frag)",1,0,0,1
7923," in case the allocator isn't providing these stats, fake them so that          fragmention info still shows some (inaccurate metrics)",1,0,0,1
7924," LUA memory isn't part of zmalloc_used, but it is part of the process RSS,              so we must desuct it in order to be able to calculate correct              ""allocator fragmentation"" ratio",1,0,0,1
7925," We received a SIGTERM, shutting down here in a safe way, as it is      not ok doing so inside the signal handler.",1,0,0,1
7926, Show some info about non-empty databases,0,1,0,1
7927, dictPrintStats(server.dict);,0,0,0,0
7928, Show information about connected clients,0,1,0,1
7929, We need to do a few operations on clients asynchronously.,1,1,0,1
7930, Handle background operations on Redis databases.,0,0,0,0
7931, Start a scheduled AOF rewrite if this was requested by the user while      a BGSAVE was in progress.,0,0,0,0
7932, Check if a background saving or AOF rewrite in progress terminated.,0,1,0,1
7933, If there is not a background saving or rewrite in progress check if          we have to save or rewrite now.,0,0,0,0
7934," Save if we reached the given amount of changes,              the given amount of seconds, and if the latest bgsave was              successful or if, in case of an error, at least              CONFIG_BGSAVE_RETRY_DELAY seconds already elapsed.",1,0,0,1
7935, Trigger an AOF rewrite if needed.,0,1,0,1
7936, AOF postponed flush: Try at every cron cycle if the slow fsync      completed.,1,0,0,1
7937," AOF write errors: in this case we have a buffer to flush as well and      clear the AOF error in case of success to make the DB writable again,      however to try every second is enough in case of 'hz' is set to      an higher frequency.",1,0,0,1
7938, Close clients that need to be closed asynchronous,1,1,0,1
7939, Clear the paused clients flag if needed.,1,1,0,1
7940," Don't check return value, just use the side effect.",0,1,0,1
7941," Replication cron function -- used to reconnect to master,      detect transfer failures, start background RDB transfers and so forth.",0,0,0,0
7942, Run the Redis Cluster cron.,0,0,0,0
7943, Run the Sentinel timer if we are in sentinel mode.,0,1,0,1
7944, Cleanup expired MIGRATE cached sockets.,0,1,0,1
7945, Start a scheduled BGSAVE if the corresponding flag is set.,0,1,0,1
7946,This is      useful when we are forced to postpone a BGSAVE because an AOF      rewrite is in progress.,1,0,0,1
7947,Note: this code must be after the replicationCron() call above so      make sure when refactoring this file to keep this order.,1,0,0,1
7948,This is useful      because we want to give priority to RDB savings for replication.,1,0,0,1
7949," This function gets called every time Redis is entering the  main loop of the event driven library, that is, before to sleep  for ready file descriptors.",1,0,0,1
7950, Call the Redis Cluster before sleep function.,0,0,0,0
7951,"Note that this function      may change the state of Redis Cluster (from ok to fail or vice versa),      so it's a good idea to call it before serving the unblocked clients      later in this function.",1,0,0,1
7952, Run a fast expire cycle (the called function will return      ASAP if a fast cycle is not needed).,1,0,0,1
7953, Send all the slaves an ACK request if at least one client blocked      during the previous event loop iteration.,1,0,0,1
7954, Not used argument.,0,1,0,1
7955, Unblock all the clients blocked for synchronous replication      in WAIT.,0,0,0,0
7956, Check if there are clients unblocked by modules that implement      blocking commands.,0,0,0,0
7957, Try to process pending commands for clients that were just unblocked.,0,1,0,1
7958, Write the AOF buffer on disk,0,1,0,1
7959, Handle writes with pending output buffers.,0,1,0,1
7960," Before we are going to sleep, let the threads access the dataset by      releasing the GIL.",0,0,0,0
7961,Redis main thread will not touch anything at this      time.,1,0,0,1
7962," This function is called immadiately after the event loop multiplexing  API returned, and the control is going to soon return to Redis by invoking  the different events callbacks.",1,0,0,1
7963, =========================== Server initialization ========================,0,1,0,1
7964," The following two shared objects, minstring and maxstrings, are not      actually used for their value but as a special object meaning      respectively the minimum possible string and the maximum possible      string in string comparisons for the ZRANGEBYLEX command.",1,0,0,1
7965, Make sure the first time will not match,1,1,0,1
7966," Client IDs, start from 1 .",0,0,0,0
7967, save after 1 hour and 1 change,0,0,0,0
7968, save after 5 minutes and 100 changes,0,0,0,0
7969, save after 1 minute and 10000 changes,0,0,0,0
7970, Replication related,1,1,0,1
7971," Never connected, repl is down since EVER.",1,0,0,1
7972, Replication partial resync backlog,1,0,0,1
7973, Client output buffer limits,0,1,0,1
7974, Double constants initialization,0,1,0,1
7975," Command table -- we initiialize it here as it is part of the      initial configuration, since command names may be changed via      redis.conf using the rename-command directive.",0,0,0,0
7976, Slow log,1,1,0,1
7977, Latency monitor,0,1,0,1
7978, Debugging,0,1,0,1
7979," Restart the server, executing the same executable that started this  instance, with the same arguments and configuration file.",1,0,0,1
7980,The function is designed to directly call execve() so that the new  server instance will retain the PID of the previous one.,1,0,0,1
7981,"The list of flags, that may be bitwise ORed together, alter the  behavior of this function:   RESTART_SERVER_NONE              No flags.",0,0,0,0
7982,RESTART_SERVER_GRACEFULLY        Do a proper shutdown before restarting.,1,0,0,1
7983,RESTART_SERVER_CONFIG_REWRITE    Rewrite the config file before restarting.,0,0,0,0
7984,"On success the function does not return, because the process turns into  a different process.",1,0,0,1
7985,On error C_ERR is returned.,0,1,0,1
7986, Check if we still have accesses to the executable that started this      server instance.,0,0,0,0
7987, Config rewriting.,0,0,0,0
7988, Perform a proper shutdown.,1,1,0,1
7989," Close all file descriptors, with the exception of stdin, stdout, strerr      which are useful if we restart a Redis server which is not daemonized.",1,0,0,1
7990," Test the descriptor validity before closing it, otherwise          Valgrind issues a warning on close().",0,0,0,0
7991, Execute the server with the original command line.,1,1,0,1
7992," If an error occurred here, there is nothing we can do, but exit.",0,1,0,1
7993, Never reached.,0,1,0,1
7994, This function will try to raise the max number of open files accordingly to  the configured max number of clients.,1,0,0,1
7995,"It also reserves a number of file  descriptors (CONFIG_MIN_RESERVED_FDS) for extra operations of  persistence, listening sockets, log files and so forth.",1,0,0,1
7996,"If it will not be possible to set the limit accordingly to the configured  max number of clients, the function will do the reverse setting  server.maxclients to the value that we can actually handle.",1,0,0,1
7997, Set the max number of files if the current limit is not enough          for our needs.,1,0,0,1
7998, Try to set the file limit to match 'maxfiles' or at least              to the higher value supported less than maxfiles.,1,0,0,1
7999, We failed to set file limit to 'bestlimit'.,1,0,0,1
8000,Try with a                  smaller limit decrementing by a few FDs per iteration.,1,0,0,1
8001, Assume that the limit we get initially is still valid if              our last try was even lower.,1,0,0,1
8002, maxclients is unsigned so may overflow: in order                  to check if maxclients is now logically less than 1                  we test indirectly via bestlimit.,1,0,0,1
8003," Check that server.tcp_backlog can be actually enforced in Linux according  to the value of  or proc or sys or net or core or somaxconn, or warn about it.",1,0,0,1
8004, Initialize a set of file descriptors to listen to the specified 'port'  binding the addresses specified in the Redis server configuration.,0,0,0,0
8005,The listening file descriptors are stored in the integer array 'fds'  and their number is set in 'count'.,0,0,0,0
8006,The addresses to bind are specified in the global server.bindaddr array  and their number is server.bindaddr_count.,0,0,0,0
8007,"If the server configuration  contains no specific addresses to bind, this function will try to  bind  (all addresses) for both the IPv4 and IPv6 protocols.",1,0,0,1
8008,On success the function returns C_OK.,1,1,0,1
8009,On error the function returns C_ERR.,0,1,0,1
8010,"For the function to be on  error, at least one of the server.bindaddr addresses was  impossible to bind, or no bind addresses were specified in the server  configuration but the function is not able to bind  for at least  one of the IPv4 or IPv6 protocols.",1,0,0,1
8011," Force binding of 0.0.0.0 if no bind address is specified, always      entering the loop if j == 0.",0,0,0,0
8012," Bind  for both IPv6 and IPv4, we enter here only if              server.bindaddr_count == 0.",1,0,0,1
8013, Bind the IPv4 address as well.,0,1,0,1
8014," Exit the loop if we were able to bind  on IPv4 and IPv6,              otherwise fds[count] will be ANET_ERR and we'll print an              error and return to the caller with an error.",1,0,0,1
8015, Bind IPv6 address.,0,1,0,1
8016, Bind IPv4 address.,0,1,0,1
8017, Resets the stats that we expose via INFO or other means that we want  to reset via CONFIG RESETSTAT.,1,0,0,1
8018,The function is also used in order to  initialize these fields in initServer() at server startup.,0,0,0,0
8019, Force to emit the first SELECT command.,1,1,0,1
8020, Open the TCP listening socket for the user commands.,1,1,0,1
8021, Open the listening Unix domain socket.,1,1,0,1
8022, don't care if this fails,1,0,0,1
8023, Abort if there are no listening sockets at all.,0,1,0,1
8024," Create the Redis databases, and initialize other internal state.",1,0,0,1
8025, Initialize the LRU keys pool.,0,1,0,1
8026, At startup we consider the DB saved.,0,0,0,0
8027, At startup we never tried to BGSAVE.,0,0,0,0
8028," A few stats we don't want to reset: server startup time, and peak mem.",1,0,0,1
8029," Create the timer callback, this is our way to process many background      operations incrementally, like clients timeout, eviction of unaccessed      expired keys and so forth.",1,0,0,1
8030, Create an event handler for accepting new connections in TCP and Unix      domain sockets.,1,0,0,1
8031, Register a readable event for the pipe used to awake the event loop      when a blocked client in a module needs attention.,0,0,0,0
8032, Open the AOF file if needed.,1,1,0,1
8033," 32 bit instances are limited to 4GB of address space, so if there is      no explicit limit in the user provided configuration we set a limit      at 3 GB using maxmemory with 'noeviction' policy'.",1,0,0,1
8034,This avoids      useless crashes of the Redis instance for out of memory.,1,0,0,1
8035, 3 GB,0,1,0,1
8036, Populates the Redis Command Table starting from the hard coded list  we have on top of redis.c file.,1,0,0,1
8037, Populate an additional dictionary that will be unaffected          by rename-command statements in redis.conf.,1,0,0,1
8038, ========================== Redis OP Array API ============================,0,0,0,0
8039, ====================== Commands lookup and execution =====================,0,0,0,0
8040," Lookup the command in the current table, if not found also check in  the original table containing the original command names unaffected by  redis.conf rename-command statement.",1,0,0,1
8041,This is used by functions rewriting the argument vector such as  rewriteClientCommandVector() in order to set client->cmd pointer  correctly even if the command was renamed.,1,0,0,1
8042, Propagate the specified command (in the context of the specified database id)  to AOF and Slaves.,0,0,0,0
8043,flags are an xor between:  + PROPAGATE_NONE (no propagation of command at all)  + PROPAGATE_AOF (propagate into the AOF file if is enabled)  + PROPAGATE_REPL (propagate into the replication link)   This should not be used inside commands implementation.,0,0,0,0
8044,"Use instead  alsoPropagate(), preventCommandPropagation(), forceCommandPropagation().",0,0,0,0
8045, Used inside commands to schedule the propagation of additional commands  after the current command is propagated to AOF  or  Replication.,1,0,0,1
8046,"'cmd' must be a pointer to the Redis command to replicate, dbid is the  database ID the command should be propagated into.",0,0,0,0
8047,"Arguments of the command to propagte are passed as an array of redis  objects pointers of len 'argc', using the 'argv' vector.",0,0,0,0
8048,"The function does not take a reference to the passed 'argv' vector,  so it is up to the caller to release the passed argv (but it is usually  stack allocated).",1,0,0,1
8049,"The function autoamtically increments ref count of  passed objects, so the caller does not need to.",0,0,0,0
8050, No propagation during loading.,0,1,0,1
8051, It is possible to call the function forceCommandPropagation() inside a  Redis command implementation in order to to force the propagation of a  specific command execution into AOF  or  Replication.,1,0,0,1
8052, Avoid that the executed command is propagated at all.,0,1,0,1
8053,This way we  are free to just propagate what we want using the alsoPropagate()  API.,1,0,0,1
8054, AOF specific version of preventCommandPropagation().,1,0,0,1
8055, Replication specific version of preventCommandPropagation().,1,0,0,1
8056, Call() is the core of Redis execution of a command.,0,0,0,0
8057,The following flags can be passed:  CMD_CALL_NONE        No flags.,1,0,0,1
8058,CMD_CALL_SLOWLOG     Check command speed and log in the slow log if needed.,1,0,0,1
8059,CMD_CALL_STATS       Populate command stats.,0,0,0,0
8060,CMD_CALL_PROPAGATE_AOF   Append command to AOF if it modified the dataset                           or if the client flags are forcing propagation.,0,0,0,0
8061,CMD_CALL_PROPAGATE_REPL  Send command to salves if it modified the dataset                           or if the client flags are forcing propagation.,0,0,0,0
8062,CMD_CALL_PROPAGATE   Alias for PROPAGATE_AOF|PROPAGATE_REPL.,0,0,0,0
8063,CMD_CALL_FULL        Alias for SLOWLOG|STATS|PROPAGATE.,0,0,0,0
8064,The exact propagation behavior depends on the client flags.,1,1,0,1
8065,Specifically:   1.,0,0,0,0
8066,"If the client flags CLIENT_FORCE_AOF or CLIENT_FORCE_REPL are set     and assuming the corresponding CMD_CALL_PROPAGATE_AOF or REPL is set     in the call flags, then the command is propagated even if the     dataset was not affected by the command.",0,0,0,0
8067,"If the client flags CLIENT_PREVENT_REPL_PROP or CLIENT_PREVENT_AOF_PROP     are set, the propagation into AOF or to slaves is not performed even     if the command modified the dataset.",0,0,0,0
8068,"Note that regardless of the client flags, if CMD_CALL_PROPAGATE_AOF  or CMD_CALL_PROPAGATE_REPL are not set, then respectively AOF or  slaves propagation will never occur.",1,0,0,1
8069,"Client flags are modified by the implementation of a given command  using the following API:   forceCommandPropagation(client c, int flags);  preventCommandPropagation(client c);  preventCommandAOF(client c);  preventCommandReplication(client c);",1,0,0,1
8070," Sent the command to clients in MONITOR mode, only if the commands are      not generated from reading an AOF.",1,0,0,1
8071," Initialization: clear the flags that must be set by the command on      demand, and initialize the array for additional commands propagation.",1,0,0,1
8072, Call the command.,0,1,0,1
8073, When EVAL is called loading the AOF we don't want commands called      from Lua to go into the slowlog or to populate statistics.,0,0,0,0
8074," If the caller is Lua, we want to force the EVAL caller to propagate      the script if the command flag or client flag are forcing the      propagation.",0,0,0,0
8075," Log the command into the Slow log if needed, and populate the      per-command statistics that we show in INFO commandstats.",1,0,0,1
8076, Propagate the command into the AOF and replication link,0,1,0,1
8077, Check if the command operated changes in the data set.,0,1,0,1
8078,If so          set for replication  or  AOF propagation.,0,0,0,0
8079," If the client forced AOF  or  replication of the command, set          the flags regardless of the command effects on the data set.",1,0,0,1
8080," However prevent AOF  or  replication propagation if the command          implementatino called preventCommandPropagation() or similar,          or if we don't have the call() flags to do so.",1,0,0,1
8081, Call propagate() only if at least one of AOF  or  replication          propagation is needed.,1,0,0,1
8082,"Note that modules commands handle replication          in an explicit way, so we never replicate them automatically.",0,0,0,0
8083," Restore the old replication flags, since call() can be executed      recursively.",1,0,0,1
8084, Handle the alsoPropagate() API to handle commands that want to propagate      multiple separated commands.,0,0,0,0
8085,Note that alsoPropagate() is not affected      by CLIENT_PREVENT_PROP flag.,0,0,0,0
8086," Whatever the command wish is, we honor the call() flags.",0,1,0,1
8087," If this function gets called we already read a whole  command, arguments are in the client argv or argc fields.",1,0,0,1
8088,processCommand() execute the command or prepare the  server for a bulk read from the client.,0,0,0,0
8089,If C_OK is returned the client is still alive and valid and  other operations can be performed by the caller.,1,0,0,1
8090,Otherwise  if C_ERR is returned the client was destroyed (i.e.,0,0,0,0
8091,after QUIT).,0,0,0,0
8092, The QUIT command is handled separately.,0,1,0,1
8093,Normal command procs will      go through checking for replication and QUIT will cause trouble      when FORCE_REPLICATION is enabled and would be implemented in      a regular command proc.,1,0,0,1
8094," Now lookup the command and check ASAP about trivial error conditions      such as wrong arity, bad command name and so forth.",1,0,0,1
8095, Check if the user is authenticated,0,1,0,1
8096, If cluster is enabled perform the cluster redirection here.,0,0,0,0
8097,However we don't perform the redirection if:      1) The sender of this command is our master.,0,0,0,0
8098,2) The command has no key arguments.,1,1,0,1
8099, Handle the maxmemory directive.,0,0,0,0
8100,First we try to free some memory if possible (if there are volatile      keys in the dataset).,1,0,0,1
8101,If there are not the only thing we can do      is returning an error.,1,0,0,1
8102, freeMemoryIfNeeded may flush slave output buffers.,0,0,0,0
8103,"This may result          into a slave, that may be the active client, to be freed.",1,0,0,1
8104," It was impossible to free enough memory, and the command the client          is trying to execute is denied during OOM conditions?",1,0,0,1
8105,Error.,0,1,0,1
8106, Don't accept write commands if there are problems persisting on disk      and if this is a master instance.,0,0,0,0
8107, Don't accept write commands if there are not enough good slaves and      user configured the min-slaves-to-write option.,1,0,0,1
8108, Don't accept write commands if this is a read only slave.,1,1,0,1
8109,But      accept write commands if this is our master.,0,0,0,0
8110, Only allow SUBSCRIBE and UNSUBSCRIBE in the context of Pub or Sub,1,1,0,1
8111," Only allow commands with flag ""t"", such as INFO, SLAVEOF and so on,      when slave-serve-stale-data is no and we are a slave with a broken      link with master.",1,0,0,1
8112, Loading DB?,0,1,0,1
8113,Return an error if the command has not the      CMD_LOADING flag.,0,0,0,0
8114, Lua script too slow?,1,0,0,1
8115,Only allow a limited number of commands.,1,1,0,1
8116, Exec the command,0,1,0,1
8117,================================== Shutdown ===============================,0,1,0,1
8118, Close listening sockets.,0,1,0,1
8119,Also unlink the unix domain socket if  unlink_unix_socket is non-zero.,0,0,0,0
8120, don't care if this fails,1,0,0,1
8121, Kill all the Lua debugger forked sessions.,0,0,0,0
8122, Kill the saving child if there is a background saving in progress.,0,1,0,1
8123,"We want to avoid race conditions, for instance our saving child may       overwrite the synchronous saving did by SHUTDOWN.",0,0,0,0
8124, Kill the AOF saving child as the AOF we already have may be longer          but contains the full dataset anyway.,1,0,0,1
8125," If we have AOF enabled but haven't written the AOF yet, don't              shutdown or else the dataset will be lost.",0,0,0,0
8126, Append only file: flush buffers and fsync() the AOF at exit,1,0,0,1
8127, Create a new RDB file before exiting.,1,1,0,1
8128, Snapshotting.,0,0,0,0
8129,Perform a SYNC SAVE and exit,0,1,0,1
8130, Ooops.. error saving!,0,0,0,0
8131,The best we can do is to continue              operating.,1,0,0,1
8132,"Note that if there was a background saving process,              in the next cron() Redis will be notified that the background              saving aborted, handling special stuff like slaves pending for              synchronization...",1,0,0,1
8133, Remove the pid file if possible and needed.,1,0,0,1
8134," Best effort flush of slave output buffers, so that we hopefully      send them pending writes.",1,0,0,1
8135, Close the listening sockets.,0,1,0,1
8136,Apparently this allows faster restarts.,1,1,0,1
8137,================================== Commands ===============================,0,1,0,1
8138," Return zero if strings are the same, non-zero if they are not.",1,1,0,1
8139,The comparison is performed in a way that prevents an attacker to obtain  information about the nature of the strings just monitoring the execution  time of the function.,0,0,0,0
8140,Note that limiting the comparison length to strings up to 512 bytes we  can avoid leaking any information about the password length and any  possible branch misprediction related leak.,1,0,0,1
8141," The above two strlen perform len(a) + len(b) operations where either      a or b are fixed (our password) length, and the difference is only      relative to the length of the user provided string, so no information      leak is possible in the following two lines of code.",1,0,0,1
8142, We can't compare strings longer than our static buffers.,1,1,0,1
8143,Note that this will never pass the first test in practical circumstances      so there is no info leak.,1,0,0,1
8144, Constant time.,1,1,0,1
8145, Constant time.,1,1,0,1
8146, Again the time of the following two copies is proportional to      len(a) + len(b) so no info is leaked.,1,0,0,1
8147, Always compare all the chars in the two buffers without      conditional expressions.,0,0,0,0
8148, Length must be equal as well.,1,1,0,1
8149, If zero strings are the same.,1,0,0,1
8150, The PING command.,0,0,0,0
8151,It works in a different way if the client is in  in Pub or Sub mode.,1,0,0,1
8152, The command takes zero or one arguments.,0,0,0,0
8153, gettimeofday() can only fail if &tv is a bad address so we      don't check for errors.,1,0,0,1
8154, Helper function for addReplyCommand() to output flags.,0,0,0,0
8155, Output the representation of a Redis command.,0,0,0,0
8156,Used by the COMMAND command.,0,0,0,0
8157," We are adding: command name, arg count, flags, first, last, offset",1,0,0,1
8158, COMMAND <subcommand> <args>,0,0,0,0
8159," Convert an amount of bytes into a human readable string in the form  of 100B, 2G, 100M, 4K, and so forth.",1,0,0,1
8160, Bytes,0,1,0,1
8161, Let's hope we never need this,0,1,0,1
8162, Create the string returned by the INFO command.,0,1,0,1
8163,This is decoupled  by the INFO command itself as we need to report the same information  on memory corruption problems.,1,0,0,1
8164, Server,0,1,0,1
8165, Uname can be slow and is always the same output.,1,0,0,1
8166,Cache it.,0,1,0,1
8167, Clients,0,1,0,1
8168, Memory,0,1,0,1
8169, Peak memory is updated from time to time by serverCron() so it          may happen that the instantaneous value is slightly bigger than          the peak value.,1,0,0,1
8170,"This may confuse users, so we update the peak          if found smaller than the current memory usage.",1,0,0,1
8171," this is the total RSS overhead, including fragmentation,",1,0,0,1
8172, named so for backwards compatibility,0,0,0,0
8173, Persistence,0,1,0,1
8174, A fake 1 second figure if we don't have                            enough info,1,0,0,1
8175, Stats,0,1,0,1
8176, Replication,0,1,0,1
8177," If min-slaves-to-write is active, write the number of slaves          currently considered 'good'.",1,0,0,1
8178, CPU,0,1,0,1
8179, Command statistics,0,1,0,1
8180, Cluster,0,1,0,1
8181, Key space,1,1,0,1
8182, ignore MONITOR if already slave or in monitor mode,0,0,0,0
8183, =================================== Main!,1,1,0,1
8184, __linux__,0,0,0,0
8185," If pidfile requested, but no pidfile defined, use      default pidfile path",0,0,0,0
8186, Try to write the pid file in a best-effort way.,0,0,0,0
8187, parent exits,0,0,0,0
8188, create a new session,1,0,0,1
8189, Every output goes to  or dev or null.,0,0,0,0
8190,If Redis is daemonized but      the 'logfile' is set to 'stdout' in the configuration file      it will not log at all.,0,0,0,0
8191, Show the ASCII logo if: log file is stdout AND stdout is a      tty AND syslog logging is disabled.,1,0,0,1
8192,Also show logo if the user      forced us to do so via redis.conf.,1,0,0,1
8193, SIGINT is often delivered via Ctrl+C in an interactive session.,0,0,0,0
8194,"If we receive the signal the second time, we interpret this as      the user really wanting to quit ASAP without waiting to persist      on disk.",1,0,0,1
8195, Exit with an error since this was not a clean shutdown.,1,1,0,1
8196, When the SA_SIGINFO flag is set in sa_flags then sa_sigaction is used.,0,0,0,0
8197,"Otherwise, sa_handler is used.",0,0,0,0
8198," Returns 1 if there is --sentinel among the arguments or if  argv[0] contains ""redis-sentinel"".",0,0,0,0
8199, Function called at startup to load RDB or AOF file in memory.,0,0,0,0
8200, Restore the replication ID  or  offset from the RDB file.,0,0,0,0
8201," Note that older implementations may save a repl_stream_db                  of -1 inside the RDB file in a wrong way, see more information                  in function rdbPopulateSaveInfo.",1,0,0,1
8202," If we are a slave, create a cached master from this                  information, in order to allow partial resynchronizations                  with masters.",1,0,0,1
8203,  Check whether systemd or upstart have been used to start redis.,0,0,0,0
8204, test not found,0,0,0,0
8205," We need to initialize our libraries, and the server configuration.",0,1,0,1
8206, Store the executable path and arguments in a safe place in order      to be able to restart the server later.,1,0,0,1
8207, We need to init sentinel right now as parsing the configuration file      in sentinel mode will have the effect of populating the sentinel      data structures with master nodes to monitor.,1,0,0,1
8208, Check if we need to start in redis-check-rdb or aof mode.,0,0,0,0
8209,We just execute      the program main.,1,0,0,1
8210,However the program is part of the Redis executable      so that we can easily execute an RDB check on loading errors.,1,0,0,1
8211, First option to parse in argv[],1,0,0,1
8212, Handle special options --help and --version,1,1,0,1
8213, First argument is the config file name?,1,0,0,1
8214, Replace the config file in server.exec_argv with              its absoulte path.,0,0,0,0
8215, All the other options are parsed and conceptually appended to the          configuration file.,1,0,0,1
8216,"For instance --port 6380 will generate the          string ""port 6380\n"" to be parsed after the actual file name          is parsed, if any.",1,0,0,1
8217, Option name,0,1,0,1
8218," Argument has no options, need to skip for parsing.",0,1,0,1
8219, Option argument,0,1,0,1
8220, Things not needed when running in Sentinel mode.,0,1,0,1
8221, Warning the user about suspicious maxmemory setting.,0,0,0,0
8222, The End,0,1,0,1
8223, NULL size_t,0,0,0,0
8224, va_list va_start va_end,0,0,0,0
8225, malloc(3) setenv(3) clearenv(3) setproctitle(3) getprogname(3),0,0,0,0
8226, vsnprintf(3) snprintf(3),0,0,0,0
8227, strlen(3) strchr(3) strdup(3) memset(3) memcpy(3),0,0,0,0
8228, errno program_invocation_name program_invocation_short_name,0,0,0,0
8229, original value,1,0,0,1
8230, title space available,1,0,0,1
8231, pointer to original nul character within base,1,0,0,1
8232, spt_min(),0,0,0,0
8233,"  For discussion on the portability of the various methods, see  http: or  or lists.freebsd.org or pipermail or freebsd-stable or 2008-June or 043136.html",1,0,0,1
8234, spt_clearenv(),0,0,0,0
8235, spt_copyenv(),0,0,0,0
8236, spt_copyargs(),0,0,0,0
8237, spt_init(),0,0,0,0
8238, use buffer in case argv[0] is passed,0,0,0,0
8239, setproctitle(),0,0,0,0
8240, __linux || __APPLE__,0,0,0,0
8241, !HAVE_SETPROCTITLE,0,1,0,1
8242, ================ sha1.c ================,0,1,0,1
8243,"SHA-1 in CBy Steve Reid <steve@edmweb.com>100% Public DomainTest Vectors (from FIPS PUB 180-1)""abc""  A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D""abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq""  84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1A million repetitions of ""a""  34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F",1,0,0,1
8244," #define LITTLE_ENDIAN  This should be #define'd already, if true.",1,0,0,1
8245, #define SHA1HANDSOFF  Copies data before messing with it.,0,0,0,0
8246, blk0() and blk() perform the initial expand.,0,0,0,0
8247, I got the idea of expanding during the round function from SSLeay,1,0,0,1
8248," (R0+R1), R2, R3, R4 are the different operations used in SHA1",1,1,0,1
8249, Hash a single 512-bit block.,1,1,0,1
8250,This is the core of the algorithm.,0,1,0,1
8251, use array to appear as a pointer,0,0,0,0
8252, The following had better never be used because it causes the      pointer-to-const buffer to be cast into a pointer to non-const.,1,0,0,1
8253,And the result is written through.,0,1,0,1
8254,"I threw a ""const"" in, hoping      this will cause a diagnostic.",0,0,0,0
8255, Copy context->state[] to working vars,0,1,0,1
8256, 4 rounds of 20 operations each.,0,1,0,1
8257,Loop unrolled.,0,1,0,1
8258, Add the working vars back into context.state[],0,1,0,1
8259, Wipe variables,0,1,0,1
8260, SHA1Init - Initialize new context,1,1,0,1
8261, SHA1 initialization constants,0,1,0,1
8262, Run your data through this.,0,1,0,1
8263, Add padding and return the message digest.,0,1,0,1
8264," untested ""improvement"" by DHR",0,0,0,0
8265, Convert context->count to a sequence of bytes      in finalcount.,0,0,0,0
8266,"Second element first, but      big-endian order within element.",1,0,0,1
8267,But we do it all backwards.,0,1,0,1
8268, Endian independent,1,0,0,1
8269, Should cause a SHA1Transform(),0,1,0,1
8270, Wipe variables,0,1,0,1
8271, ================ end of sha1.c ================,0,1,0,1
8272, Fast tolower() alike function that does not care about locale  but just returns a-z insetad of A-Z.,1,0,0,1
8273, Test of the CPU is Little Endian and supports not aligned accesses.,1,0,0,1
8274,Two interesting conditions to speedup the function that happen to be  in most of x86 servers.,1,0,0,1
8275, --------------------------------- TEST ------------------------------------,0,1,0,1
8276, Test siphash using a test vector.,0,0,0,0
8277,"Returns 0 if the function passed  all the tests, otherwise 1 is returned.",0,0,0,0
8278,IMPORTANT: The test vector is for SipHash 2-4.,1,1,0,1
8279,Before running  the test revert back the siphash() function to 2-4 rounds since  now it uses 1-2 rounds.,0,0,0,0
8280," printf(""fail for %d bytes\n"", i);",1,0,0,1
8281, Run a few basic tests with the case insensitive version.,1,0,0,1
8282, Create a new slowlog entry.,1,0,0,1
8283,Incrementing the ref count of all the objects retained is up to  this function.,0,0,0,0
8284," Logging too many arguments is a useless memory waste, so we stop          at SLOWLOG_ENTRY_MAX_ARGC, but use the last argument to specify          how many remaining arguments there were in the original command.",1,0,0,1
8285, Trim too long strings as well...,1,1,0,1
8286," Here we need to dupliacate the string objects composing the                  argument vector of the command, because those may otherwise                  end shared with string objects stored into keys.",0,0,0,0
8287,"Having                  shared objects between any part of Redis, and the data                  structure holding the data, is a problem: FLUSHALL ASYNC                  may release the shared string object and create a race.",0,0,0,0
8288, Free a slow log entry.,1,1,0,1
8289,The argument is void so that the prototype of this  function matches the one of the 'free' method of adlist.c.,1,0,0,1
8290,This function will take care to release all the retained object.,0,1,0,1
8291, Initialize the slow log.,1,1,0,1
8292,This function should be called a single time  at server startup.,1,0,0,1
8293, Push a new entry into the slow log.,1,1,0,1
8294,This function will make sure to trim the slow log accordingly to the  configured max length.,1,0,0,1
8295, Slowlog disabled,1,0,0,1
8296, Remove old entries if needed.,1,1,0,1
8297, Remove all the entries from the current slow log.,1,1,0,1
8298, The SLOWLOG command.,0,1,0,1
8299,Implements all the subcommands needed to handle the  Redis slow log.,1,0,0,1
8300, Partial qsort for SORT+LIMIT,1,0,0,1
8301, isnan(),0,0,0,0
8302, Return the value associated to the key with a name obtained using  the following rules:   1) The first occurrence of '' in 'pattern' is substituted with 'subst'.,1,0,0,1
8303,"2) If 'pattern' matches the ""->"" string, everything on the left of     the arrow is treated as the name of a hash field, and the part on the     left as the key name containing a hash.",1,0,0,1
8304,The value of the specified     field is returned.,0,0,0,0
8305,"3) If 'pattern' equals ""#"", the function simply returns 'subst' itself so     that the SORT command can be used like: SORT key GET # to retrieve     the Set or List elements directly.",1,0,0,1
8306,The returned object will always have its refcount increased by 1  when it is non-NULL.,0,0,0,0
8307," If the pattern is ""#"" return the substitution object itself in order      to implement the ""SORT ... GET #"" feature.",0,0,0,0
8308, The substitution object may be specially encoded.,1,1,0,1
8309,If so we create      a decoded object on the fly.,1,0,0,1
8310,"Otherwise getDecodedObject will just      increment the ref count, that we'll decrement later.",0,0,0,0
8311, If we can't find '' in the pattern we return NULL as to GET a      fixed key does not make sense.,1,0,0,1
8312, Find out if we're dealing with a hash dereference.,0,0,0,0
8313, Perform the '' substitution.,0,1,0,1
8314, Incremented by decodeObject(),0,0,0,0
8315, Lookup substituted key,1,0,0,1
8316, Retrieve value from hash by the field name.,0,1,0,1
8317,The returend object          is a new object with refcount already incremented.,1,0,0,1
8318, Every object that this function returns needs to have its refcount          increased.,0,0,0,0
8319,sortCommand decreases it again.,0,0,0,0
8320, sortCompare() is used by qsort in sortCommand().,0,0,0,0
8321,Given that qsort_r with  the additional parameter is not standard but a BSD-specific we have to  pass sorting parameters via the global 'server' structure,0,0,0,0
8322, Numeric sorting.,0,1,0,1
8323,Here it's trivial as we precomputed scores,0,0,0,0
8324," Objects have the same score, but we don't want the comparison              to be undefined, so we compare objects lexicographically.",1,0,0,1
8325,This way the result of SORT is deterministic.,0,1,0,1
8326, Alphanumeric sorting,0,1,0,1
8327, At least one compare object is NULL,1,1,0,1
8328," We have both the objects, compare them.",0,1,0,1
8329, Here we can use strcoll() directly as we are sure that                      the objects are decoded string objects.,1,0,0,1
8330, Compare elements directly.,1,1,0,1
8331, The SORT command is the most complex command in Redis.,1,0,0,1
8332,Warning: this code  is optimized for speed and a bit less for readability,1,0,0,1
8333, GET operation counter,0,1,0,1
8334, Resulting vector to sort,0,1,0,1
8335, Lookup the key to sort.,1,0,0,1
8336,It must be of the right types,1,1,0,1
8337, Create a list of operations to perform for every sorted element.,0,1,0,1
8338,Operations can be GET,0,1,0,1
8339, options start at argv[2],0,0,0,0
8340," Now we need to protect sortval incrementing its count, in the future      SORT may have options able to overwrite or delete keys during the sorting      and the sorted key itself may get destroyed",1,0,0,1
8341," The SORT command has an SQL-alike syntax, parse it",0,1,0,1
8342," If the BY pattern does not contain '', i.e.",0,1,0,1
8343,"it is constant,              we don't need to sort nor to lookup the weight keys.",1,0,0,1
8344," If BY is specified with a real patter, we can't accept                  it in cluster mode.",1,0,0,1
8345, Handle syntax errors set during options parsing.,0,1,0,1
8346," When sorting a set with no sort specified, we must sort the output      so the result is consistent across scripting and replication.",1,0,0,1
8347,"The other types (list, sorted set) will retain their native order      even if no sort order is requested, so they remain stable across      scripting and replication.",1,0,0,1
8348, Force ALPHA sorting,0,1,0,1
8349, Destructively convert encoded sorted sets for SORT.,1,1,0,1
8350, Objtain the length of the object to sort.,0,0,0,0
8351, Avoid GCC warning,0,1,0,1
8352," Perform LIMIT start,count sanity checking.",0,0,0,0
8353," Whenever possible, we load elements into the output array in a more      direct way.",1,0,0,1
8354,This is possible if:           1) The object to sort is a sorted set or a list (internally sorted).,1,0,0,1
8355,2) There is nothing to sort as dontsort is true (BY <constant string>).,1,0,0,1
8356,"In this special case, if we have a LIMIT option that actually reduces      the number of elements to fetch, we also optimize to just load the      range we are interested in and allocating a vector that is big enough      for the selected range length.",1,0,0,1
8357, Load the sorting vector with all the objects to sort,0,1,0,1
8358," Special handling for a list, if 'dontsort' is true.",1,0,0,1
8359,"This makes sure we return elements in the list original          ordering, accordingly to DESC  or  ASC options.",1,0,0,1
8360,"Note that in this case we also handle LIMIT here in a direct          way, just getting the required range, as an optimization.",1,0,0,1
8361, Fix start or end: output code is not aware of this optimization.,1,1,0,1
8362," Special handling for a sorted set, if 'dontsort' is true.",1,0,0,1
8363,"This makes sure we return elements in the sorted set original          ordering, accordingly to DESC  or  ASC options.",1,0,0,1
8364,"Note that in this case we also handle LIMIT here in a direct          way, just getting the required range, as an optimization.",1,0,0,1
8365," Check if starting point is trivial, before doing log(N) lookup.",1,0,0,1
8366, Fix start or end: output code is not aware of this optimization.,1,1,0,1
8367, Now it's time to load the right scores in the sorting vector,1,1,0,1
8368, lookup value to sort by,0,0,0,0
8369, use object itself to sort by,0,0,0,0
8370, Don't need to decode the object if it's                      integer-encoded (the only encoding supported) so                      far.,1,0,0,1
8371,We can just cast it,0,1,0,1
8372," when the object was retrieved using lookupKeyByPattern,              its refcount needs to be decreased.",1,0,0,1
8373," Send command output to the output buffer, performing the specified      GET or DEL or INCR or DECR operations if any.",0,0,0,0
8374," STORE option not specified, sent the sorting result to client",0,1,0,1
8375, Always fails,1,0,0,1
8376," STORE option specified, set the sorting result as a List object",0,1,0,1
8377," listTypePush does an incrRefCount, so we should take care                          care of the incremented refcount caused by either                          lookupKeyByPattern or createStringObject("""",0)",0,0,0,0
8378, Always fails,1,0,0,1
8379, Cleanup,0,1,0,1
8380," This is the charset used to display the graphs, but multiple rows are used  to increase the resolution.",0,0,0,0
8381, ----------------------------------------------------------------------------  Sequences are arrays of samples we use to represent data to turn  into sparklines.,0,0,0,0
8382,"This is the API in order to generate a sparkline:   struct sequence seq = createSparklineSequence();  sparklineSequenceAddSample(seq, 10, NULL);  sparklineSequenceAddSample(seq, 20, NULL);  sparklineSequenceAddSample(seq, 30, ""last sample label"");  sds output = sparklineRender(sdsempty(), seq, 80, 4, SPARKLINE_FILL);  freeSparklineSequence(seq);  -------------------------------------------------------------------------",1,0,0,1
8383, Create a new sequence.,1,1,0,1
8384, Add a new sample into a sequence.,1,1,0,1
8385, Free a sequence.,1,1,0,1
8386, ----------------------------------------------------------------------------  ASCII rendering of sequence  -------------------------------------------------------------------------,0,0,0,0
8387," Render part of a sequence, so that render_sequence() call call this function  with differnent parts in order to create the full output without overflowing  the current terminal columns.",1,0,0,1
8388, Print the character needed to create the sparkline,0,0,0,0
8389, Labels spacing,0,1,0,1
8390, Print the label if needed.,0,1,0,1
8391, Turn a sequence into its ASCII representation,0,1,0,1
8392, ----------------- Blocking sockets I or O with timeouts ---------------------,0,1,0,1
8393," Redis performs most of the I or O in a nonblocking way, with the exception  of the SYNC command where the slave does it in a blocking way, and  the MIGRATE command that must be blocking in order to be atomic from the  point of view of the two instances (one migrating the key and one receiving  the key).",1,0,0,1
8394,This is why need the following blocking I or O functions.,1,1,0,1
8395,All the functions take the timeout in milliseconds.,0,1,0,1
8396, Resolution in milliseconds,0,1,0,1
8397, Write the specified payload to 'fd'.,0,0,0,0
8398,If writing the whole payload will be  done within 'timeout' milliseconds the operation succeeds and 'size' is  returned.,1,0,0,1
8399,"Otherwise the operation fails, -1 is returned, and an unspecified  partial write could be performed against the file descriptor.",1,0,0,1
8400, Optimistically try to write before checking if the file descriptor          is actually writable.,1,0,0,1
8401,At worst we get EAGAIN.,1,1,0,1
8402, Wait,0,1,0,1
8403, Read the specified amount of bytes from 'fd'.,0,0,0,0
8404,If all the bytes are read  within 'timeout' milliseconds the operation succeed and 'size' is returned.,0,0,0,0
8405,"Otherwise the operation fails, -1 is returned, and an unspecified amount of  data could be read from the file descriptor.",1,0,0,1
8406, Optimistically try to read before checking if the file descriptor          is actually readable.,1,0,0,1
8407,At worst we get EAGAIN.,1,1,0,1
8408, short read.,1,0,0,1
8409, Wait,0,1,0,1
8410, Read a line making sure that every char will not require more than 'timeout'  milliseconds to be read.,1,0,0,1
8411,"On success the number of bytes read is returned, otherwise -1.",1,1,0,1
8412,On success the string is always correctly terminated with a 0 byte.,1,1,0,1
8413,-----------------------------------------------------------------------------  Hash type API ----------------------------------------------------------------------------,0,0,0,0
8414, Check the length of a number of objects to see if we need to convert a  ziplist to a real hash.,1,0,0,1
8415,Note that we only check string encoded objects  as their string length can be queried in constant time.,1,0,0,1
8416," Get the value from a ziplist encoded hash, identified by field.",0,0,0,0
8417,Returns -1 when the field cannot be found.,0,1,0,1
8418, Grab pointer to the value (fptr points to the field),0,0,0,0
8419," Get the value from a hash table encoded hash, identified by field.",0,1,0,1
8420,"Returns NULL when the field cannot be found, otherwise the SDS value  is returned.",0,0,0,0
8421, Higher level function of hashTypeGet() that returns the hash value  associated with the specified field.,1,0,0,1
8422,"If the field is found C_OK  is returned, otherwise C_ERR.",0,0,0,0
8423,"The returned object is returned by  reference in either vstr and vlen if it's returned in string form,  or stored in vll if it's returned as a number.",0,0,0,0
8424,"If vll is populated vstr is set to NULL, so the caller  can always check the function return by checking the return value  for C_OK and checking if vll (or vstr) is NULL.",0,0,0,0
8425," Like hashTypeGetValue() but returns a Redis object, which is useful for  interaction with the hash type outside t_hash.c.",1,0,0,1
8426,The function returns NULL if the field is not found in the hash.,0,1,0,1
8427,Otherwise  a newly allocated string object with the value is returned.,1,0,0,1
8428," Higher level function using hashTypeGet() to return the length of the  object associated with the requested field, or 0 if the field does not  exist.",1,0,0,1
8429, Test if the specified field exists in the given hash.,0,1,0,1
8430,"Returns 1 if the field  exists, and 0 when it doesn't.",0,0,0,0
8431," Add a new field, overwrite the old with the new value if it already exists.",1,1,0,1
8432,Return 0 on insert and 1 on update.,0,1,0,1
8433,"By default, the key and value SDS strings are copied if needed, so the  caller retains ownership of the strings passed.",1,0,0,1
8434,However this behavior  can be effected by passing appropriate flags (possibly bitwise OR-ed):   HASH_SET_TAKE_FIELD -- The SDS field ownership passes to the function.,1,0,0,1
8435,HASH_SET_TAKE_VALUE -- The SDS value ownership passes to the function.,0,1,0,1
8436,When the flags are used the caller does not need to release the passed  SDS string(s).,0,0,0,0
8437,It's up to the function to use the string to create a new  entry or to free the SDS string before returning to the caller.,1,0,0,1
8438,"HASH_SET_COPY corresponds to no flags passed, and means the default  semantics of copying the values if needed.",0,0,0,0
8439, Grab pointer to the value (fptr points to the field),0,0,0,0
8440, Delete value,0,1,0,1
8441, Insert new value,1,1,0,1
8442, Push new field or value pair onto the tail of the ziplist,1,0,0,1
8443, Check if the ziplist needs to be converted to a hash table,0,0,0,0
8444, Free SDS strings we did not referenced elsewhere if the flags      want this function to be responsible.,1,0,0,1
8445, Delete an element from a hash.,0,1,0,1
8446,Return 1 on deleted and 0 on not found.,0,1,0,1
8447, Delete the key.,1,1,0,1
8448, Delete the value.,0,1,0,1
8449, Always check if the dictionary needs a resize after a delete.,0,0,0,0
8450, Return the number of elements in a hash.,0,1,0,1
8451, Move to the next entry in the hash.,0,1,0,1
8452,Return C_OK when the next entry  could be found and C_ERR when the iterator reaches the end.,0,0,0,0
8453, Initialize cursor,0,1,0,1
8454, Advance cursor,0,1,0,1
8455, Grab pointer to the value (fptr points to the field),0,0,0,0
8456," fptr, vptr now point to the first or next pair",1,0,0,1
8457," Get the field or value at iterator cursor, for an iterator on a hash value  encoded as a ziplist.",0,0,0,0
8458,Prototype is similar to `hashTypeGetFromZiplist`.,1,0,0,1
8459," Get the field or value at iterator cursor, for an iterator on a hash value  encoded as a hash table.",0,0,0,0
8460,Prototype is similar to  `hashTypeGetFromHashTable`.,1,0,0,1
8461, Higher level function of hashTypeCurrent() that returns the hash value  at current iterator position.,1,0,0,1
8462,"The returned element is returned by reference in either vstr and vlen if  it's returned in string form, or stored in vll if it's returned as  a number.",0,0,0,0
8463,"If vll is populated vstr is set to NULL, so the caller  can always check the function return by checking the return value  type checking if vstr == NULL.",0,0,0,0
8464, Return the key or value at the current iterator position as a new  SDS string.,1,0,0,1
8465, Nothing to do...,0,1,0,1
8466,-----------------------------------------------------------------------------  Hash type commands ----------------------------------------------------------------------------,0,0,0,0
8467, HMSET (deprecated) and HSET return value is different.,1,1,0,1
8468, HSET,0,1,0,1
8469, HMSET,0,1,0,1
8470, Else hashTypeGetValue() already stored it into &value,0,0,0,0
8471, Always replicate HINCRBYFLOAT as an HSET command with the final value      in order to make sure that differences in float pricision or formatting      will not create differences in replicas or after an AOF restart.,1,0,0,1
8472, Don't abort when the key cannot be found.,1,1,0,1
8473,"Non-existing keys are empty      hashes, where HMGET should respond with a series of null bulks.",1,0,0,1
8474,-----------------------------------------------------------------------------  List API ----------------------------------------------------------------------------,0,0,0,0
8475," The function pushes an element to the specified list object 'subject',  at head or tail position as specified by 'where'.",1,0,0,1
8476,There is no need for the caller to increment the refcount of 'value' as  the function takes care of it if needed.,0,0,0,0
8477, Initialize an iterator at the specified index.,0,1,0,1
8478, LIST_HEAD means start at TAIL and move towards head.,0,1,0,1
8479,LIST_TAIL means start at HEAD and move towards tail.,0,1,0,1
8480, Clean up the iterator.,1,1,0,1
8481, Stores pointer to current the entry in the provided entry structure  and advances the position of the iterator.,1,0,0,1
8482,"Returns 1 when the current  entry is in fact an entry, 0 otherwise.",1,0,0,1
8483, Protect from converting when iterating,0,1,0,1
8484, Return entry or NULL at the current position of the iterator.,1,1,0,1
8485, Compare the given object with the entry at the current position.,1,1,0,1
8486, Delete the element pointed to.,0,1,0,1
8487, Create a quicklist from a single ziplist,1,0,0,1
8488,-----------------------------------------------------------------------------  List Commands ----------------------------------------------------------------------------,0,0,0,0
8489, Seek pivot from head to tail,0,1,0,1
8490, Notify client of a failed insert,1,1,0,1
8491, convert negative indexes,1,0,0,1
8492," Invariant: start >= 0, so this test will be true when end < 0.",1,1,0,1
8493,The range is empty when start > end or start >= length.,1,1,0,1
8494, Return the result in form of a multi-bulk reply,0,0,0,0
8495, convert negative indexes,1,0,0,1
8496," Invariant: start >= 0, so this test will be true when end < 0.",1,1,0,1
8497,The range is empty when start > end or start >= length.,1,1,0,1
8498, Out of range start or start > end result in empty list,1,1,0,1
8499, Remove list elements to perform the trim,0,1,0,1
8500, This is the semantic of this command:   RPOPLPUSH srclist dstlist:     IF LLEN(srclist) > 0       element = RPOP srclist       LPUSH dstlist element       RETURN element     ELSE       RETURN nil     END   END   The idea is to be able to get an element from a list in a reliable way  since the element is not just returned but pushed against another list  as well.,1,0,0,1
8501,This command was originally proposed by Ezra Zygmuntowicz.,1,0,0,1
8502, Create the list if the key does not exist,1,1,0,1
8503, Always send the pushed value to the client.,0,1,0,1
8504, This may only happen after loading very old RDB files.,1,1,0,1
8505,Recent          versions of Redis delete keys of empty lists.,1,0,0,1
8506," We saved touched key, and protect it, since rpoplpushHandlePush          may change the client command argument vector (it does not          currently).",1,0,0,1
8507, listTypePop returns an object with its refcount incremented,0,0,0,0
8508, Delete the source list when it is empty,1,1,0,1
8509,-----------------------------------------------------------------------------  Blocking POP operations ----------------------------------------------------------------------------,0,0,0,0
8510, This is a helper function for handleClientsBlockedOnLists().,0,0,0,0
8511,"It's work  is to serve a specific client (receiver) that is blocked on 'key'  in the context of the specified 'db', doing the following:   1) Provide the client with the 'value' element.",1,0,0,1
8512,2) If the dstkey is not NULL (we are serving a BRPOPLPUSH) also push the     'value' element on the destination list (the LPUSH side of the command).,0,0,0,0
8513,"3) Propagate the resulting BRPOP, BLPOP and additional LPUSH if any into     the AOF and replication channel.",0,0,0,0
8514,"The argument 'where' is LIST_TAIL or LIST_HEAD, and indicates if the  'value' element was popped fron the head (BLPOP) or tail (BRPOP) so that  we can propagate the command properly.",1,0,0,1
8515,"The function returns C_OK if we are able to serve the client, otherwise  C_ERR is returned to signal the caller that the list POP operation  should be undone as the client was not served: This only happens for  BRPOPLPUSH that fails to push the value to the destination key as it is  of the wrong type.",1,0,0,1
8516, Propagate the [LR]POP operation.,0,1,0,1
8517, BRPOP or BLPOP,0,1,0,1
8518, Notify event.,0,1,0,1
8519, BRPOPLPUSH,0,1,0,1
8520, Propagate the RPOP operation.,0,1,0,1
8521, Propagate the LPUSH operation.,0,1,0,1
8522," Notify event (""lpush"" was notified by rpoplpushHandlePush).",0,0,0,0
8523, BRPOPLPUSH failed because of wrong              destination type.,1,0,0,1
8524, Blocking RPOP or LPOP,0,1,0,1
8525," Non empty list, this is like a non normal [LR]POP.",1,1,0,1
8526, Replicate it as an [LR]POP instead of B[LR]POP.,0,1,0,1
8527, If we are inside a MULTI or EXEC and the list is empty the only thing      we can do is treating it as a timeout (even with timeout 0).,1,0,0,1
8528, If the list is empty or the key does not exists we must block,1,0,0,1
8529, Blocking against an empty list in a multi state              returns immediately.,1,0,0,1
8530, The list is empty and the client blocks.,1,1,0,1
8531," The list exists and has elements, so              the regular rpoplpushCommand is executed.",1,0,0,1
8532,-----------------------------------------------------------------------------  Set Commands ----------------------------------------------------------------------------,0,0,0,0
8533," Factory method to return a set that can hold ""value"".",0,0,0,0
8534,"When the object has  an integer-encodable value, an intset will be returned.",0,0,0,0
8535,Otherwise a regular  hash table.,1,0,0,1
8536, Add the specified value into a set.,0,1,0,1
8537,"If the value was already member of the set, nothing is done and 0 is  returned, otherwise the new element is added and 1 is returned.",1,0,0,1
8538, Convert to regular set when the intset contains                  too many entries.,1,0,0,1
8539," Failed to get integer from object, convert to regular set.",1,1,0,1
8540," The set was an intset and this value is not integer              encodable, so dictAdd should always work.",0,0,0,0
8541, Move to the next entry in the set.,0,1,0,1
8542,Returns the object at the current  position.,1,0,0,1
8543,"Since set elements can be internally be stored as SDS strings or  simple arrays of integers, setTypeNext returns the encoding of the  set object you are iterating, and will populate the appropriate pointer  (sdsele) or (llele) accordingly.",1,0,0,1
8544,Note that both the sdsele and llele pointers should be passed and cannot  be NULL since the function will try to defensively populate the non  used field with values which are easy to trap if misused.,1,0,0,1
8545,When there are no longer elements -1 is returned.,0,0,0,0
8546, Not needed.,0,1,0,1
8547,Defensive.,0,1,0,1
8548, Not needed.,0,1,0,1
8549,Defensive.,0,1,0,1
8550," The not copy on write friendly version but easy to use version  of setTypeNext() is setTypeNextObject(), returning new SDS  strings.",1,0,0,1
8551,So if you don't retain a pointer to this object you should call  sdsfree() against it.,0,0,0,0
8552,This function is the way to go for write operations where COW is not  an issue.,1,0,0,1
8553, just to suppress warnings,0,0,0,0
8554, Return random element from a non empty set.,1,1,0,1
8555,"The returned element can be a int64_t value if the set is encoded  as an ""intset"" blob of integers, or an SDS string if the set  is a regular set.",1,0,0,1
8556,The caller provides both pointers to be populated with the right  object.,1,0,0,1
8557,The return value of the function is the object->encoding  field of the object and is used by the caller to check if the  int64_t pointer or the redis object pointer was populated.,0,0,0,0
8558,Note that both the sdsele and llele pointers should be passed and cannot  be NULL since the function will try to defensively populate the non  used field with values which are easy to trap if misused.,1,0,0,1
8559, Not needed.,0,1,0,1
8560,Defensive.,0,1,0,1
8561, Not needed.,0,1,0,1
8562,Defensive.,0,1,0,1
8563, Convert the set to specified encoding.,0,1,0,1
8564,The resulting dict (when converting  to a hash table) is presized to hold the number of elements in the original  set.,1,0,0,1
8565, Presize the dict to avoid rehashing,0,0,0,0
8566, To add the elements we extract integers and create redis objects,0,0,0,0
8567, If the source key does not exist return 0,1,0,0,1
8568," If the source key has the wrong type, or the destination key      is set and has the wrong type, return with an error.",1,0,0,1
8569," If srcset and dstset are equal, SMOVE is a no-op",1,0,0,1
8570," If the element cannot be removed from the src set, return 0.",0,0,0,0
8571, Remove the src set from the database when empty,1,0,0,1
8572, Create the destination set when it doesn't exist,0,1,0,1
8573, An extra key has changed when ele was successfully added to dstset,1,0,0,1
8574," Handle the ""SPOP key <count>"" variant.",1,0,0,1
8575,The normal version of the  command is handled by the spopCommand() function itself.,1,0,0,1
8576," How many times bigger should be the set compared to the remaining size  for us to use the ""create new set"" strategy?",1,0,0,1
8577,Read later in the  implementation for more info.,1,0,0,1
8578, Get the count argument,0,1,0,1
8579," Make sure a key with the name inputted exists, and that it's type is      indeed a set.",1,0,0,1
8580,"Otherwise, return nil",0,1,0,1
8581," If count is zero, serve an empty multibulk ASAP to avoid special      cases later.",1,0,0,1
8582, Generate an SPOP keyspace notification,0,0,0,0
8583, CASE 1:      The number of requested elements is greater than or equal to      the number of elements inside the set: simply return the whole set.,1,0,0,1
8584, We just return the entire set,1,1,0,1
8585, Delete the set as it is now empty,1,1,0,1
8586, Propagate this command as an DEL operation,0,1,0,1
8587, Case 2 and 3 require to replicate SPOP as a set of SREM commands.,0,0,0,0
8588,Prepare our replication argument vector.,0,1,0,1
8589,Also send the array length      which is common to both the code paths.,1,0,0,1
8590, Common iteration vars.,1,1,0,1
8591, Elements left after SPOP.,0,1,0,1
8592," If we are here, the number of requested elements is less than the      number of elements inside the set.",1,0,0,1
8593,Also we are sure that count < size.,1,0,0,1
8594,Use two different strategies.,1,1,0,1
8595,CASE 2: The number of elements to return is small compared to the      set size.,1,0,0,1
8596,We can just extract random elements and return them to      the set.,1,0,0,1
8597, Emit and remove.,0,1,0,1
8598, Replicate or AOF this command as an SREM operation,0,1,0,1
8599," CASE 3: The number of elements to return is very big, approaching      the size of the set itself.",1,0,0,1
8600,"After some time extracting random elements      from such a set becomes computationally expensive, so we use      a different strategy, we extract random elements that we don't      want to return (the elements that will remain part of the set),      creating a new set as we do this (that will be stored as the original      set).",1,0,0,1
8601,Then we return the elements left in the original set and      release it.,1,0,0,1
8602, Create a new set with just the remaining elements.,1,1,0,1
8603, Assign the new set as the key value.,1,1,0,1
8604, Protect the old set value.,1,1,0,1
8605, Tranfer the old set to the client and release it.,1,0,0,1
8606, Replicate or AOF this command as an SREM operation,0,1,0,1
8607, Don't propagate the command itself even if we incremented the      dirty counter.,1,0,0,1
8608,We don't want to propagate an SPOP command since      we propagated the command as a set of SREMs operations using      the alsoPropagate() API.,0,0,0,0
8609," Make sure a key with the name inputted exists, and that it's type is      indeed a set",1,0,0,1
8610, Get a random element from the set,1,1,0,1
8611, Remove the element from the set,0,1,0,1
8612, Replicate or AOF this command as an SREM operation,0,1,0,1
8613, Add the element to the reply,0,1,0,1
8614, Delete the set if it's empty,1,1,0,1
8615, Set has been modified,0,1,0,1
8616," handle the ""SRANDMEMBER key <count>"" variant.",1,0,0,1
8617,The normal version of the  command is handled by the srandmemberCommand() function itself.,1,0,0,1
8618," How many times bigger should be the set compared to the requested size  for us to don't use the ""remove elements"" strategy?",1,0,0,1
8619,Read later in the  implementation for more info.,1,0,0,1
8620, A negative count means: return the same elements multiple times          (i.e.,1,0,0,1
8621,don't remove the extracted element after every extraction).,0,0,0,0
8622," If count is zero, serve it ASAP to avoid special cases later.",1,1,0,1
8623," CASE 1: The count was negative, so the extraction method is just:      ""return N random elements"" sampling the whole set every time.",1,0,0,1
8624,This case is trivial and can be served without auxiliary data      structures.,0,0,0,0
8625, CASE 2:      The number of requested elements is greater than the number of      elements inside the set: simply return the whole set.,1,0,0,1
8626, For CASE 3 and CASE 4 we need an auxiliary dictionary.,0,1,0,1
8627, CASE 3:      The number of elements inside the set is not greater than      SRANDMEMBER_SUB_STRATEGY_MUL times the number of requested elements.,1,0,0,1
8628,"In this case we create a set from scratch with all the elements, and      subtract random elements to reach the requested number of elements.",1,0,0,1
8629,"This is done because if the number of requsted elements is just      a bit less than the number of elements in the set, the natural approach      used into CASE 3 is highly inefficient.",1,0,0,1
8630, Add all the elements into the temporary dictionary.,0,1,0,1
8631, Remove random elements to reach the right count.,1,1,0,1
8632, CASE 4: We have a big set compared to the requested number of elements.,1,1,0,1
8633,"In this case we can simply get random elements from the set and add      to the temporary set, trying to eventually get enough unique elements      to reach the specified count.",1,0,0,1
8634, Try to add the object to the dictionary.,0,1,0,1
8635,"If it already exists              free it, otherwise increment the number of objects we have              in the result dictionary.",1,0,0,1
8636, CASE 3 & 4: send the result to the user.,0,1,0,1
8637, This is used by SDIFF and in this case we can receive NULL that should  be handled as empty sets.,1,0,0,1
8638," Sort sets from the smallest to largest, this will improve our      algorithm's performance",0,0,0,0
8639," The first thing we should output is the total number of elements...      since this is a multi-bulk write, but at this stage we don't know      the intersection set size, so we use a trick, append an empty object      to the output list and save the pointer to later modify it with the      right length",1,0,0,1
8640, If we have a target key where to store the resulting set          create this key with an empty set inside,1,0,0,1
8641," Iterate all the elements of the first (smallest) set, and test      the element against all the other sets, if at least one set does      not include the element it is discarded",1,0,0,1
8642, intset with intset is simple... and fast,1,0,0,1
8643," in order to compare an integer with an object we                  have to use the generic function, creating an object                  for this",0,0,0,0
8644, Only take action when all sets contain the member,1,1,0,1
8645," Store the resulting set into the target, if the intersection          is not an empty set.",1,0,0,1
8646, Select what DIFF algorithm to use.,0,1,0,1
8647,Algorithm 1 is O(NM) where N is the size of the element first set      and M the total number of sets.,1,0,0,1
8648,Algorithm 2 is O(N) where N is the total number of elements in all      the sets.,1,0,0,1
8649,We compute what is the best bet with the current input here.,1,1,0,1
8650, Algorithm 1 has better constant times and performs less operations          if there are elements in common.,1,0,0,1
8651,Give it some advantage.,0,1,0,1
8652," With algorithm 1 it is better to order the sets to subtract              by decreasing size, so that we are more likely to find              duplicated elements ASAP.",1,0,0,1
8653, We need a temp set object to store our union.,0,1,0,1
8654,"If the dstkey      is not NULL (that is, we are inside an SUNIONSTORE operation) then      this set object will be the resulting object to set into the target key",1,0,0,1
8655," Union is trivial, just add every element of every set to the          temporary set.",0,0,0,0
8656, non existing keys are like empty sets,1,0,0,1
8657," DIFF Algorithm 1:                   We perform the diff by iterating all the elements of the first set,          and only adding it to the target set if the element does not exist          into all the other sets.",1,0,0,1
8658,"This way we perform at max NM operations, where N is the size of          the first set, and M the number of sets.",1,0,0,1
8659, no key is an empty set.,1,0,0,1
8660, same set!,1,0,0,1
8661, There is no other set with this element.,1,1,0,1
8662,Add it.,0,1,0,1
8663, DIFF Algorithm 2:                   Add all the elements of the first set to the auxiliary set.,1,0,0,1
8664,Then remove all the elements of all the next sets from it.,0,1,0,1
8665,This is O(N) where N is the sum of all the elements in every          set.,0,0,0,0
8666, non existing keys are like empty sets,1,0,0,1
8667, Exit if result set is empty as any additional removal              of elements will have no effect.,1,0,0,1
8668," Output the content of the resulting set, if not in STORE mode",0,1,0,1
8669, If we have a target key where to store the resulting set          create this key with the result set inside,1,0,0,1
8670," Every stream item inside the listpack, has a flags field that is used to  mark the entry as deleted, or having the same field as the ""master""  entry at the start of the listpack>",1,0,0,1
8671, No special flags.,1,1,0,1
8672, Entry is delted.,0,0,0,0
8673,Skip it.,0,1,0,1
8674, Same fields as master entry.,1,1,0,1
8675, -----------------------------------------------------------------------  Low level stream encoding: a radix tree of listpacks.,1,0,0,1
8676, Create a new stream data structure.,1,1,0,1
8677, Created on demand to save memory when not used.,0,1,0,1
8678," Free a stream, including the listpacks stored inside the radix tree.",1,0,0,1
8679, Generate the next stream item ID given the previous one.,1,1,0,1
8680,"If the current  milliseconds Unix time is greater than the previous one, just use this  as time part and start with sequence part of zero.",1,0,0,1
8681,Otherwise we use the  previous time (and never go backward) and increment the sequence.,1,0,0,1
8682, This is just a wrapper for lpAppend() to directly use a 64 bit integer  instead of a string.,1,0,0,1
8683, This is just a wrapper for lpReplace() to directly use a 64 bit integer  instead of a string to replace the current element.,1,0,0,1
8684,"The function returns  the new listpack as return value, and also updates the current cursor  by updating 'pos'.",1,0,0,1
8685," This is a wrapper function for lpGet() to directly get an integer value  from the listpack (that may store numbers as a string), converting  the string if needed.",1,0,0,1
8686, The following code path should never be used for how listpacks work:      they should always be able to store an int64_t value in integer      encoded form.,1,0,0,1
8687,However the implementation may change.,0,0,0,0
8688, Debugging function to log the full content of a listpack.,1,0,0,1
8689,Useful  for development and debugging.,1,0,0,1
8690," Convert the specified stream entry ID as a 128 bit big endian number, so  that the IDs can be sorted lexicographically.",1,0,0,1
8691, This is the reverse of streamEncodeID(): the decoded ID will be stored  in the 'id' structure passed by reference.,0,0,0,0
8692,The buffer 'buf' must point  to a 128 bit big-endian encoded ID.,0,0,0,0
8693, Compare two stream IDs.,0,1,0,1
8694,"Return -1 if a < b, 0 if a == b, 1 if a > b.",0,1,0,1
8695, The ms part is the same.,1,1,0,1
8696,Check the sequence part.,0,1,0,1
8697, Everything is the same: IDs are equal.,1,1,0,1
8698, Adds a new item into the stream 's' having the specified number of  field-value pairs as specified in 'numfields' and stored into 'argv'.,1,0,0,1
8699,Returns the new entry ID populating the 'added_id' structure.,1,0,0,1
8700,"If 'use_id' is not NULL, the ID is not auto-generated by the function,  but instead the passed ID is uesd to add the new entry.",1,0,0,1
8701,In this case  adding the entry may fail as specified later in this comment.,1,0,0,1
8702,"The function returns C_OK if the item was added, this is always true  if the ID was generated by the function.",1,0,0,1
8703,"However the function may return  C_ERR if an ID was given via 'use_id', but adding it failed since the  current top ID is greater or equal.",1,0,0,1
8704," If an ID was given, check that it's greater than the last entry ID      or return an error.",1,0,0,1
8705, Add the new entry.,1,1,0,1
8706, Total bytes in the tail listpack.,1,0,0,1
8707, Tail listpack pointer.,0,0,0,0
8708, Get a reference to the tail node listpack.,0,0,0,0
8709, Generate the new entry ID.,1,1,0,1
8710," We have to add the key into the radix tree in lexicographic order,      to do so we consider the ID as a single 128 bit number written in      big endian, so that the most significant bytes are the first ones.",1,0,0,1
8711, Key in the radix tree containing the listpack.,1,0,0,1
8712, ID of the master entry in the listpack.,0,0,0,0
8713, Create a new listpack and radix tree node if needed.,1,0,0,1
8714,"Note that when      a new listpack is created, we populate it with a ""master entry"".",1,0,0,1
8715,This      is just a set of fields that is taken as refernce in order to compress      the stream entries that we'll add inside the listpack.,0,0,0,0
8716,"Note that while we use the first added entry fields to create      the master entry, the first added entry is NOT represented in the master      entry, which is a stand alone object.",1,0,0,1
8717,"But of course, the first entry      will compress well because it's used as reference.",1,0,0,1
8718,"The master entry is composed like in the following example:           +-------+---------+------------+---------+-- or --+---------+---------+-+      | count | deleted | num-fields | field_1 | field_2 | ... | field_N |0|      +-------+---------+------------+---------+-- or --+---------+---------+-+           count and deleted just represent respectively the total number of      entires inside the listpack that are valid, and marked as deleted      (delted flag in the entry flags set).",1,0,0,1
8719,So the total number of items      actually inside the listpack (both deleted and not) is count+deleted.,1,0,0,1
8720,"The real entries will be encoded with an ID that is just the      millisecond and sequence difference compared to the key stored at      the radix tree node containing the listpack (delta encoding), and      if the fields of the entry are the same as the master enty fields, the      entry flags will specify this fact and the entry fields and number      of fields will be omitted (see later in the code of this function).",1,0,0,1
8721,"The ""0"" entry at the end is the same as the 'lp-count' entry in the      regular stream entries (see below), and marks the fact that there are      no more entires, when we scan the stream from right to left.",1,0,0,1
8722, Create the listpack having the master entry ID and fields.,0,0,0,0
8723," One item, the one we are adding.",0,1,0,1
8724, Zero deleted so far.,1,1,0,1
8725, Master entry zero terminator.,0,1,0,1
8726," The first entry we insert, has obviously the same fields of the          master entry.",1,0,0,1
8727, Read the master ID from the radix tree key.,1,0,0,1
8728, Update count and skip the deleted fields.,0,1,0,1
8729, seek delted.,0,0,0,0
8730, seek master entry num fields.,0,0,0,0
8731," Check if the entry we are adding, have the same fields          as the master entry.",1,0,0,1
8732, Stop if there is a mismatch.,0,1,0,1
8733, All fields are the same!,1,1,0,1
8734,We can compress the field names              setting a single bit in the flags.,1,0,0,1
8735, Populate the listpack with the new entry.,1,0,0,1
8736,"We use the following      encoding:           +-----+--------+----------+-------+-------+- or -+-------+-------+--------+      |flags|entry-id|num-fields|field-1|value-1|...|field-N|value-N|lp-count|      +-----+--------+----------+-------+-------+- or -+-------+-------+--------+           However if the SAMEFIELD flag is set, we have just to populate      the entry with the values, so it becomes:           +-----+--------+-------+- or -+-------+--------+      |flags|entry-id|value-1|...|value-N|lp-count|      +-----+--------+-------+- or -+-------+--------+           The entry-id field is actually two separated fields: the ms      and seq difference compared to the master entry.",1,0,0,1
8737,"The lp-count field is a number that states the number of listpack pieces      that compose the entry, so that it's possible to travel the entry      in reverse order: we can just start from the end of the listpack, read      the entry, and jump back N times to seek the ""flags"" field to read      the stream full entry.",1,0,0,1
8738, Compute and store the lp-count field.,0,0,0,0
8739, Add the 3 fixed fields flags + ms-diff + seq-diff.,1,1,0,1
8740," If the item is not compressed, it also has the fields other than          the values, and an additional num-fileds field.",1,0,0,1
8741, Insert back into the tree in order to update the listpack pointer.,0,0,0,0
8742," Trim the stream 's' to have no more than maxlen elements, and return the  number of elements removed from the stream.",1,0,0,1
8743,"The 'approx' option, if non-zero,  specifies that the trimming must be performed in a approximated way in  order to maximize performances.",0,0,0,0
8744,"This means that the stream may contain  more elements than 'maxlen', and elements are only removed if we can remove  a whole node of the radix tree.",1,0,0,1
8745,The elements are removed from the head  of the stream (older elements).,1,0,0,1
8746,The function may return zero if:   1) The stream is already shorter or equal to the specified max length.,1,0,0,1
8747,"2) The 'approx' option is true and the head node had not enough elements     to be deleted, leaving the stream with a number of elements >= maxlen.",1,0,0,1
8748," Check if we can remove the whole node, and still have at          least maxlen elements.",1,0,0,1
8749," If we cannot remove a whole element, and approx is true,          stop here.",1,0,0,1
8750," Otherwise, we have to mark single entries inside the listpack          as deleted.",1,0,0,1
8751,We start by updating the entries or deleted counters.,0,1,0,1
8752, Seek deleted field.,0,1,0,1
8753, Seek num-of-fields in the master entry.,0,0,0,0
8754, Skip all the master fields.,0,1,0,1
8755, Seek the first field.,1,1,0,1
8756, Skip all master fields.,0,1,0,1
8757, Skip the zero master entry terminator.,0,1,0,1
8758, 'p' is now pointing to the first entry inside the listpack.,1,0,0,1
8759,"We have to run entry after entry, marking entries as deleted          if they are already not deleted.",0,0,0,0
8760, Mark the entry as deleted.,0,1,0,1
8761, Enough entries deleted.,1,1,0,1
8762, Skip ID ms delta.,0,1,0,1
8763, Skip ID seq delta.,0,1,0,1
8764, Seek num-fields or values (if compressed).,0,0,0,0
8765, Skip the whole entry.,1,1,0,1
8766, Skip the final lp-count field.,1,0,0,1
8767, Here we should perform garbage collection in case at this point          there are too many entries deleted inside the listpack.,1,0,0,1
8768, TODO: perform a garbage collection.,0,1,0,1
8769, Update the listpack with the new pointer.,1,0,0,1
8770," If we are here, there was enough to delete in the current                  node, so no need to go to the next node.",1,0,0,1
8771," Initialize the stream iterator, so that we can call iterating functions  to get the next items.",0,0,0,0
8772,This requires a corresponding streamIteratorStop()  at the end.,0,0,0,0
8773,The 'rev' parameter controls the direction.,0,1,0,1
8774,"If it's zero the  iteration is from the start to the end element (inclusive), otherwise  if rev is non-zero, the iteration is reversed.",0,0,0,0
8775,"Once the iterator is initalized, we iterate like this:    streamIterator myiterator;   streamIteratorStart(&myiterator,...);   int64_t numfields;   while(streamIteratorGetID(&myiterator,&ID,&numfields)) {       while(numfields--) {           unsigned char key, value;           size_t key_len, value_len;           streamIteratorGetField(&myiterator,&key,&value,&key_len,&value_len);            ... do what you want with key and value ...       }   }   streamIteratorStop(&myiterator);",1,0,0,1
8776, Intialize the iterator and translates the iteration start or stop      elements into a 128 big big-endian number.,1,0,0,1
8777, Seek the correct node in the radix tree.,0,0,0,0
8778, There is no current listpack right now.,1,0,0,1
8779, Current listpack cursor.,1,0,0,1
8780," Direction, if non-zero reversed, from end to start.",0,1,0,1
8781," Return 1 and store the current item ID at 'id' if there are still  elements within the iteration range, otherwise return 0 in order to  signal the iteration terminated.",1,0,0,1
8782, Will stop when element > stop_key or end of radix tree.,0,0,0,0
8783," If the current listpack is set to NULL, this is the start of the          iteration or the previous listpack was completely iterated.",1,0,0,1
8784,Go to the next node.,0,1,0,1
8785, Get the master ID.,0,1,0,1
8786, Get the master fields count.,0,1,0,1
8787, Seek items count,0,1,0,1
8788, Seek deleted count.,0,1,0,1
8789, Seek num fields.,0,0,0,0
8790, Seek first field.,1,1,0,1
8791, Skip master fileds to seek the first entry.,1,0,0,1
8792, We are now pointing the zero term of the master entry.,0,1,0,1
8793,"If              we are iterating in reverse order, we need to seek the              end of the listpack.",0,0,0,0
8794," If we are itereating in the reverse order, and this is not              the first entry emitted for this listpack, then we already              emitted the current entry, and have to go back to the previous              one.",1,0,0,1
8795, Seek lp-count of prev entry.,0,0,0,0
8796," For every radix tree node, iterate the corresponding listpack,          returning elements when they are within range.",0,0,0,0
8797," If we are going forward, skip the previous entry                  lp-count field (or in case of the master entry, the zero                  term field)",1,0,0,1
8798," If we are going backward, read the number of elements this                  entry is composed of, and jump backward N times to seek                  its start.",0,0,0,0
8799, We reached the master entry.,0,1,0,1
8800, Get the flags entry.,0,0,0,0
8801, Seek ID.,0,1,0,1
8802, Get the ID: it is encoded as difference between the master              ID and this entry ID.,0,0,0,0
8803, The number of entries is here or not depending on the              flags.,0,0,0,0
8804," If current >= start, and the entry is not marked as              deleted, emit it.",1,0,0,1
8805, We are already out of range.,0,1,0,1
8806, Valid item returned.,0,1,0,1
8807, We are already out of range.,0,1,0,1
8808, Valid item returned.,0,1,0,1
8809," If we do not emit, we have to discard if we are going              forward, or seek the previous entry if we are going              backward.",1,0,0,1
8810, flag + id ms or seq diff + numfields.,0,0,0,0
8811, End of listpack reached.,0,0,0,0
8812,Try the next or prev radix tree node.,0,0,0,0
8813, Get the field and value of the current item we are iterating.,1,1,0,1
8814,"This should  be called immediately after streamIteratorGetID(), and for each field  according to the number of fields returned by streamIteratorGetID().",0,0,0,0
8815,"The function populates the field and value pointers and the corresponding  lengths by reference, that are valid until the next iterator call, assuming  no one touches the stream meanwhile.",0,0,0,0
8816, Stop the stream iterator.,0,1,0,1
8817,"The only cleanup we need is to free the rax  itereator, since the stream iterator itself is supposed to be stack  allocated.",1,0,0,1
8818," Emit a reply in the client output buffer by formatting a Stream ID  in the standard <ms>-<seq> format, using the simple string protocol  of REPL.",1,0,0,1
8819," Similar to the above function, but just creates an object, usually useful  for replication purposes to create arguments.",1,0,0,1
8820," As a result of an explicit XCLAIM or XREADGROUP command, new entries  are created in the pending list of the stream and consumers.",1,0,0,1
8821,We need  to propagate this changes in the form of XCLAIM commands.,0,0,0,0
8822, We need to generate an XCLAIM that will work in a idempotent fashion:           XCLAIM <key> <group> <consumer> 0 <id> TIME <milliseconds-unix-time>             RETRYCOUNT <count> FORCE JUSTID.,0,0,0,0
8823,"Note that JUSTID is useful in order to avoid that XCLAIM will do      useless work in the slave side, trying to fetch the stream item.",1,0,0,1
8824, Send the specified range to the client 'c'.,0,1,0,1
8825,"The range the client will  receive is between start and end inclusive, if 'count' is non zero, no more  than 'count' elemnets are sent.",1,0,0,1
8826,The 'end' pointer can be NULL to mean that  we want all the elements from 'start' till the end of the stream.,1,0,0,1
8827,"If 'rev'  is non zero, elements are produced in reversed order from end to start.",0,0,0,0
8828,"If group and consumer are not NULL, the function performs additional work:  1.",0,0,0,0
8829,It updates the last delivered ID in the group in case we are     sending IDs greater than the current last ID.,1,0,0,1
8830,"If the requested IDs are already assigned to some other consumer, the     function will not return it to the client.",1,0,0,1
8831,An entry in the pending list will be created for every entry delivered     for the first time to this consumer.,1,0,0,1
8832,"The behavior may be modified passing non-zero flags:   STREAM_RWR_NOACK: Do not craete PEL entries, that is, the point ""3"" above                    is not performed.",1,0,0,1
8833,"STREAM_RWR_RAWENTRIES: Do not emit array boundaries, but just the entries,                         and return the number of entries emitted as usually.",1,0,0,1
8834,This is used when the function is just used in order                         to emit data and there is some higher level logic.,1,0,0,1
8835,"The final argument 'spi' (stream propagatino info pointer) is a structure  filled with information needed to propagte the command execution to AOF  and slaves, in the case a consumer group was passed: we need to generate  XCLAIM commands to create the pending list into AOF or slaves in that case.",1,0,0,1
8836,"If 'spi' is set to NULL no propagation will happen even if the group was  given, but currently such a feature is never used by the code base that  will always pass 'spi' and propagate when a group is passed.",1,0,0,1
8837,Note that this function is recursive in certian cases.,0,0,0,0
8838,"When it's called  with a non NULL group and consumer argument, it may call  streamReplyWithRangeFromConsumerPEL() in order to get entries from the  consumer pending entires list.",0,0,0,0
8839,However such a function will then call  streamReplyWithRange() in order to emit single entries (found in the  PEL by ID) to the client.,1,0,0,1
8840,This is the use case for the STREAM_RWR_RAWENTRIES  flag.,0,0,0,0
8841, Do not create entries in the PEL.,0,1,0,1
8842," Do not emit protocol for array                                           boundaries, just the entries.",0,0,0,0
8843," If a group was passed, we check if the request is about messages      never delivered so far (normally this happens when "">"" ID is passed).",1,0,0,1
8844,"If instead the client is asking for some history, we serve it      using a different function, so that we return entries solely      from its own PEL.",1,0,0,1
8845,This ensures each consumer will always and only      see the history of messages delivered to it and not yet confirmed      as delivered.,1,0,0,1
8846, Update the group last_id if needed.,0,0,0,0
8847, Emit a two elements array for each item.,0,1,0,1
8848,"The first is          the ID, the second is an array of field-value pairs.",1,0,0,1
8849, Emit the field-value pairs.,0,1,0,1
8850," If a group is passed, we need to create an entry in the          PEL (pending entries list) of this group and this consumer.",0,0,0,0
8851,"Note that we are sure about the fact the message is not already          associated with some other consumer, because if we reached this          loop the IDs the user is requesting are greater than any message          delivered for this group.",1,0,0,1
8852, Make sure entry was inserted.,1,1,0,1
8853, Propagate as XCLAIM.,0,1,0,1
8854," This is an helper function for streamReplyWithRange() when called with  group and consumer arguments, but with a range that is referring to already  delivered messages.",0,0,0,0
8855,"In this case we just emit messages that are already  in the history of the conusmer, fetching the IDs from its PEL.",0,0,0,0
8856,Note that this function does not have a 'rev' argument because it's not  possible to iterate in reverse using a group.,1,0,0,1
8857,Basically this function  is only called as a result of the XREADGROUP command.,1,0,0,1
8858,This function is more expensive because it needs to inspect the PEL and then  seek into the radix tree of the messages in order to emit the full message  to the client.,1,0,0,1
8859,"However clients only reach this code path when they are  fetching the history of already retrieved messages, which is rare.",1,0,0,1
8860, Note that we may have a not acknowledged entry in the PEL              about a message that's no longer here because was removed              by the user by other means.,1,0,0,1
8861,In that case we signal it emitting              the ID but then a NULL entry for the fields.,0,0,0,0
8862, -----------------------------------------------------------------------  Stream commands implementation  -----------------------------------------------------------------------,0,0,0,0
8863, Look the stream at 'key' and return the corresponding stream object.,1,1,0,1
8864,The function creates a key setting it to an empty stream if needed.,1,1,0,1
8865, Helper function to convert a string to an unsigned long long value.,1,0,0,1
8866,"The function attempts to use the faster string2ll() function inside  Redis: if it fails, strtoull() is used instead.",1,0,0,1
8867,The function returns  1 if the conversion happened successfully or 0 if the number is  invalid or out of range.,1,0,0,1
8868, Negative values are out of range.,1,1,0,1
8869, strtoull() failed.,1,0,0,1
8870, Conversion done!,0,1,0,1
8871," Parse a stream ID in the format given by clients to Redis, that is  <ms>.<seq>, and converts it into a streamID structure.",0,0,0,0
8872,"If  the specified ID is invalid C_ERR is returned and an error is reported  to the client, otherwise C_OK is returned.",0,0,0,0
8873,"The ID may be in incomplete  form, just stating the milliseconds time part of the stream.",0,0,0,0
8874,In such a case  the missing part is set according to the value of 'missing_seq' parameter.,1,0,0,1
8875,"The IDs ""-"" and ""+"" specify respectively the minimum and maximum IDs  that can be represented.",1,0,0,1
8876,"If 'c' is set to NULL, no reply is sent to the client.",0,1,0,1
8877," Handle the ""-"" and ""+"" special cases.",1,0,0,1
8878, Parse <ms>.<seq> form.,0,1,0,1
8879, XADD key [MAXLEN <count>] <ID or > [field value] [field value] ...,1,1,0,1
8880," Was an ID different than """" specified?",1,0,0,1
8881, 0 means no maximum length.,0,1,0,1
8882," If 1 only delete whole radix tree nodes, so                               the maxium length is not applied verbatim.",1,0,0,1
8883," Index of the count in MAXLEN, for rewriting.",0,1,0,1
8884, Parse options.,0,1,0,1
8885," This is the first argument position where we could                  find an option, or the ID.",1,0,0,1
8886, Number of additional arguments.,0,1,0,1
8887, This is just a fast path for the common case of auto-ID              creation.,1,0,0,1
8888, Check for the form MAXLEN ~ <count>.,0,1,0,1
8889, If we are here is a syntax error or a valid ID.,0,1,0,1
8890, Check arity.,0,0,0,0
8891, Lookup the stream at key.,1,0,0,1
8892, Append using the low level function and return the ID.,1,1,0,1
8893, Remove older elements if MAXLEN was specified.,1,1,0,1
8894," If no trimming was performed, for instance because approximated              trimming length was specified, rewrite the MAXLEN argument              as zero, so that the command is propagated without trimming.",0,0,0,0
8895, Let's rewrite the ID argument with the one actually generated for      AOF or replication propagation.,1,0,0,1
8896, We need to signal to blocked clients that there is new data on this      stream.,1,0,0,1
8897, XRANGE or XREVRANGE actual implementation.,1,1,0,1
8898, Parse the COUNT option if any.,0,1,0,1
8899, Consume additional arg.,0,0,0,0
8900, Return the specified range to the user.,0,1,0,1
8901, XRANGE key start end [COUNT <n>],1,1,0,1
8902, XREVRANGE key end start [COUNT <n>],1,1,0,1
8903, XLEN,0,1,0,1
8904," XREAD [BLOCK <milliseconds>] [COUNT <count>] STREAMS key_1 key_2 ... key_N        ID_1 ID_2 ... ID_N   This function also implements the XREAD-GROUP command, which is like XREAD  but accepting the [GROUP group-name consumer-name] additional option.",0,0,0,0
8905,"This is useful because while XREAD is a read command and can be called  on slaves, XREAD-GROUP is not.",1,0,0,1
8906," -1 means, no BLOCK argument given.",0,1,0,1
8907, True if NOACK option was specified.,1,1,0,1
8908, XREAD or XREADGROUP?,0,1,0,1
8909, Parse arguments.,0,1,0,1
8910, We have two arguments for each stream.,0,1,0,1
8911, STREAMS option is mandatory.,0,1,0,1
8912, If the user specified XREADGROUP then it must also      provide the GROUP option.,0,0,0,0
8913, Parse the IDs and resolve the group name.,0,1,0,1
8914," Specifying ""$"" as last-known-id means that the client wants to be          served with just the messages that will arrive into the stream          starting from now.",1,0,0,1
8915," If a group was specified, than we need to be sure that the          key and group actually exist.",1,0,0,1
8916, Try to serve the client synchronously.,0,1,0,1
8917, ID must be greater than this.,1,1,0,1
8918," streamReplyWithRange() handles the 'start' ID as inclusive,              so start from the next ID, since we want only messages with              IDs greater than start.",1,0,0,1
8919, uint64_t can't overflow in this context.,0,0,0,0
8920, Emit the two elements sub-array consisting of the name              of the stream and the data we extracted from it.,0,0,0,0
8921, We replied synchronously!,0,1,0,1
8922,Set the top array len and return to caller.,1,0,0,1
8923, Block if needed.,0,1,0,1
8924, If we are inside a MULTI or EXEC and the list is empty the only thing          we can do is treating it as a timeout (even with timeout 0).,1,0,0,1
8925," If no COUNT is given and we block, set a relatively small count:          in case the ID provided is too low, we do not want the server to          block just to serve this client a huge stream of messages.",1,0,0,1
8926," If this is a XREADGROUP + GROUP we need to remember for which          group and consumer name we are blocking, so later when one of the          keys receive more data, we can call streamReplyWithRange() passing          the right arguments.",1,0,0,1
8927," No BLOCK option, nor any stream we can serve.",0,1,0,1
8928,Reply as with a      timeout happened.,0,0,0,0
8929, Continue to cleanup...,0,1,0,1
8930, Cleanup.,0,1,0,1
8931, The command is propagated (in the READGROUP form) as a side effect      of calling lower level APIs.,0,0,0,0
8932,So stop any implicit propagation.,0,1,0,1
8933, -----------------------------------------------------------------------  Low level implementation of consumer groups  -----------------------------------------------------------------------,1,0,0,1
8934, Create a NACK entry setting the delivery count to 1 and the delivery  time to the current time.,1,0,0,1
8935,The NACK consumer will be set to the one  specified as argument of the function.,0,0,0,0
8936, Free a NACK entry.,1,1,0,1
8937, Free a consumer and associated data structures.,1,1,0,1
8938,"Note that this function  will not reassign the pending messages associated with this consumer  nor will delete them from the stream, so when this function is called  to delete a consumer, and not when the whole stream is destroyed, the caller  should do some work before.",1,0,0,1
8939, No value free callback: the PEL entries are shared                         between the consumer and the main stream PEL.,1,0,0,1
8940," Create a new consumer group in the context of the stream 's', having the  specified name and last server ID.",1,0,0,1
8941,"If a consumer group with the same name  already existed NULL is returned, otherwise the pointer to the consumer  group is returned.",1,0,0,1
8942, Free a consumer group and all its associated data.,1,1,0,1
8943," Lookup the consumer group in the specified stream and returns its  pointer, otherwise if there is no such group, NULL is returned.",1,0,0,1
8944," Lookup the consumer with the specified name in the group 'cg': if the  consumer does not exist it is automatically created as a side effect  of calling this function, otherwise its last seen time is updated and  the existing consumer reference returned.",1,0,0,1
8945, Delete the consumer specified in the consumer group 'cg'.,0,1,0,1
8946,"The consumer  may have pending messages: they are removed from the PEL, and the number  of pending messages ""lost"" is returned.",0,0,0,0
8947," Iterate all the consumer pending messages, deleting every corresponding      entry from the global entry.",0,0,0,0
8948, Deallocate the consumer.,0,0,0,0
8949, -----------------------------------------------------------------------  Consumer groups commands  -----------------------------------------------------------------------,0,0,0,0
8950, XGROUP CREATE <key> <groupname> <id or $>  XGROUP SETID <key> <id or $>  XGROUP DELGROUP <key> <groupname>  XGROUP DELCONSUMER <key> <groupname> <consumername>,0,0,0,0
8951, Subcommand name.,0,0,0,0
8952," Lookup the key now, this is common for all the subcommands but HELP.",1,0,0,1
8953, Certain subcommands require the group to exist.,1,0,0,1
8954, Dispatch the different subcommands.,1,0,0,1
8955, Delete the consumer and returns the number of pending messages          that were yet associated with such a consumer.,1,0,0,1
8956, XACK <key> <group> <id> <id> ... <id>   Acknowledge a message as processed.,0,0,0,0
8957,"In practical terms we just check the  pendine entries list (PEL) of the group, and delete the PEL entry both from  the group and the consumer (pending messages are referenced in both places).",0,0,0,0
8958,"Return value of the command is the number of messages successfully  acknowledged, that is, the IDs we were actually able to resolve in the PEL.",1,0,0,1
8959, Type error.,0,1,0,1
8960, No key or group?,1,1,0,1
8961,Nothing to ack.,0,0,0,0
8962," Lookup the ID in the group PEL: it will have a reference to the          NACK structure that will have a reference to the consumer, so that          we are able to remove the entry from both PELs.",1,0,0,1
8963," XPENDING <key> <group> [<start> <stop> <count>] [<consumer>]   If start and stop are omitted, the command just outputs information about  the amount of pending messages for the key or group pair, together with  the minimum and maxium ID of pending messages.",1,0,0,1
8964,"If start and stop are provided instead, the pending messages are returned  with informations about the current owner, number of deliveries and last  delivery time and so forth.",1,0,0,1
8965, Without the range just outputs general                                    informations about the PEL.,1,0,0,1
8966," Start and stop, and the consumer, can be omitted.",0,1,0,1
8967," Parse start or end or count arguments ASAP if needed, in order to report      syntax errors before any other error.",1,0,0,1
8968, Lookup the key and the group inside the stream.,1,0,0,1
8969, XPENDING <key> <group> variant.,0,1,0,1
8970, Total number of messages in the PEL.,1,1,0,1
8971, First and last IDs.,1,1,0,1
8972, Start.,0,1,0,1
8973, End.,0,1,0,1
8974, Clients.,0,1,0,1
8975, Start.,0,1,0,1
8976, End.,0,1,0,1
8977, Consumers with pending messages.,0,1,0,1
8978, XPENDING <key> <group> <start> <stop> <count> [<consumer>] variant.,0,1,0,1
8979," If a consumer name was mentioned but it does not exist, we can          just return an empty array.",1,0,0,1
8980, Entry ID.,0,1,0,1
8981, Consumer name.,0,1,0,1
8982, Milliseconds elapsed since last delivery.,1,1,0,1
8983, Number of deliveries.,0,1,0,1
8984, XCLAIM <key> <group> <consumer> <min-idle-time> <ID-1> <ID-2>         [IDLE <milliseconds>] [TIME <mstime>] [RETRYCOUNT <count>]         [FORCE] [JUSTID]   Gets ownership of one or multiple messages in the Pending Entries List  of a given stream consumer group.,0,0,0,0
8985,"If the message ID (among the specified ones) exists, and its idle  time greater or equal to <min-idle-time>, then the message new owner  becomes the specified <consumer>.",1,0,0,1
8986,"If the minimum idle time specified  is zero, messages are claimed regardless of their idle time.",0,0,0,0
8987,"All the messages that cannot be found inside the pending entires list  are ignored, but in case the FORCE option is used.",0,0,0,0
8988,In that case we  create the NACK (representing a not yet acknowledged message) entry in  the consumer group PEL.,0,0,0,0
8989,This command creates the consumer as side effect if it does not yet  exists.,0,0,0,0
8990,"Moreover the command reset the idle time of the message to 0,  even if by using the IDLE or TIME options, the user can control the  new idle time.",1,0,0,1
8991,The options at the end can be used in order to specify more attributes  to set in the representation of the pending message:   1.,1,0,0,1
8992,IDLE <ms>:       Set the idle time (last time it was delivered) of the message.,1,0,0,1
8993,"If IDLE is not specified, an IDLE of 0 is assumed, that is,       the time count is reset because the message has now a new       owner trying to process it.",1,0,0,1
8994,"TIME <ms-unix-time>:       This is the same as IDLE but instead of a relative amount of       milliseconds, it sets the idle time to a specific unix time       (in milliseconds).",1,0,0,1
8995,This is useful in order to rewrite the AOF       file generating XCLAIM commands.,1,0,0,1
8996,RETRYCOUNT <count>:       Set the retry counter to the specified value.,0,0,0,0
8997,This counter is       incremented every time a message is delivered again.,0,0,0,0
8998,"Normally       XCLAIM does not alter this counter, which is just served to clients       when the XPENDING command is called: this way clients can detect       anomalies, like messages that are never processed for some reason       after a big number of delivery attempts.",1,0,0,1
8999,FORCE:       Creates the pending message entry in the PEL even if certain       specified IDs are not already in the PEL assigned to a different       client.,1,0,0,1
9000,"However the message must be exist in the stream, otherwise       the IDs of non existing messages are ignored.",0,0,0,0
9001,"JUSTID:       Return just an array of IDs of messages successfully claimed,       without returning the actual message.",1,0,0,1
9002,"The command returns an array of messages that the user  successfully claimed, so that the caller is able to understand  what messages it is now in charge of.",1,0,0,1
9003, Minimum idle time argument.,0,1,0,1
9004, -1 means RETRYCOUNT option not given.,0,1,0,1
9005, -1 means IDLE or TIME options not given.,0,1,0,1
9006, Type error.,0,1,0,1
9007, No key or group?,1,1,0,1
9008,Send an error given that the group creation      is mandatory.,0,0,0,0
9009," Start parsing the IDs, so that we abort ASAP if there is a syntax      error: the return value of this command cannot be an error in case      the client successfully claimed some message, so it should be      executed in a ""all or nothing"" fashion.",1,0,0,1
9010, Next time we iterate the IDs we now the range.,0,1,0,1
9011," If we stopped because some IDs cannot be parsed, perhaps they      are trailing options.",0,0,0,0
9012, Number of additional arguments.,0,1,0,1
9013," If a delivery time was passed, either with IDLE or TIME, we          do some sanity check on it, and set the deliverytime to now          (which is a sane choice usually) if the value is bogus.",1,0,0,1
9014,"To raise an error here is not wise because clients may compute          the idle time doing some math startin from their local time,          and this is not a good excuse to fail in case, for instance,          the computed time is a bit in the future from our POV.",1,0,0,1
9015," If no IDLE or TIME option was passed, we want the last delivery          time to be now, so that the idle time of the message will be          zero.",1,0,0,1
9016, Do the actual claiming.,1,1,0,1
9017, Lookup the ID in the group PEL.,0,0,0,0
9018," If FORCE is passed, let's check if at least the entry          exists in the Stream.",1,0,0,1
9019,"In such case, we'll crate a new          entry in the PEL from scratch, so that XCLAIM can also          be used to create entries in the PEL.",1,0,0,1
9020,Useful for AOF          and replication of consumer groups.,1,0,0,1
9021, Item must exist for us to create a NACK for it.,0,1,0,1
9022, Create the NACK.,0,1,0,1
9023, We need to check if the minimum idle time requested              by the caller is satisfied by this entry.,1,0,0,1
9024, Remove the entry from the old consumer.,1,1,0,1
9025,Note that nack->consumer is NULL if we created the              NACK above because of the FORCE option.,1,0,0,1
9026, Update the consumer and idle time.,0,1,0,1
9027, Set the delivery attempts counter if given.,0,1,0,1
9028, Add the entry in the new cosnumer local PEL.,1,0,0,1
9029, Send the reply for this entry.,0,1,0,1
9030, Propagate this change.,0,1,0,1
9031, XINFO CONSUMERS key group  XINFO GROUPS <key>  XINFO STREAM <key>  XINFO <key> (alias of XINFO STREAM key)  XINFO HELP.,1,0,0,1
9032, HELP is special.,1,1,0,1
9033,Handle it ASAP.,0,1,0,1
9034," Handle the fact that no subcommand means ""STREAM"".",0,0,0,0
9035," Lookup the key now, this is common for all the subcommands but HELP.",1,0,0,1
9036, Dispatch the different subcommands.,1,0,0,1
9037, XINFO CONSUMERS <key> <group>.,0,1,0,1
9038, XINFO GROUPS <key>.,0,1,0,1
9039, XINFO STREAM <key> (or the alias XINFO <key>).,0,1,0,1
9040, To emit the first or last entry we us the streamReplyWithRange()          API.,1,0,0,1
9041," isnan(), isinf()",0,0,0,0
9042,-----------------------------------------------------------------------------  String Commands ----------------------------------------------------------------------------,0,0,0,0
9043, The setGenericCommand() function implements the SET operation with different  options and variants.,1,0,0,1
9044,"This function is called in order to implement the  following commands: SET, SETEX, PSETEX, SETNX.",1,0,0,1
9045,"'flags' changes the behavior of the command (NX or XX, see belove).",0,0,0,0
9046,'expire' represents an expire to set in form of a Redis object as passed  by the user.,0,0,0,0
9047,It is interpreted according to the specified 'unit'.,0,1,0,1
9048,"'ok_reply' and 'abort_reply' is what the function will reply to the client  if the operation is performed, or when it is not because of NX or  XX flags.",0,0,0,0
9049,"If ok_reply is NULL ""+OK"" is used.",1,0,0,1
9050,"If abort_reply is NULL, ""$-1"" is used.",0,0,0,0
9051, Set if key not exists.,1,1,0,1
9052, Set if key exists.,1,1,0,1
9053, Set if time in seconds is given,0,1,0,1
9054, Set if time in ms in given,0,1,0,1
9055, initialized to avoid any harmness warning,0,0,0,0
9056, SET key value [NX] [XX] [EX <seconds>] [PX <milliseconds>],1,1,0,1
9057, Return 0 when setting nothing on a non-existing string,0,1,0,1
9058, Return when the resulting string exceeds allowed size,0,1,0,1
9059," Key exists, check type",1,1,0,1
9060, Return existing string length when setting nothing,0,1,0,1
9061, Return when the resulting string exceeds allowed size,0,1,0,1
9062, Create a copy when the object is shared or encoded.,0,1,0,1
9063, Convert negative indexes,1,1,0,1
9064," Precondition: end >= 0 && end < strlen, so the only condition where      nothing can be returned is: start > end.",1,0,0,1
9065, Handle the NX flag.,0,1,0,1
9066,The MSETNX semantic is to return zero and don't      set nothing at all if at least one already key exists.,1,0,0,1
9067, Always replicate INCRBYFLOAT as a SET command with the final value      in order to make sure that differences in float precision or formatting      will not create differences in replicas or after an AOF restart.,1,0,0,1
9068, Create the key,1,1,0,1
9069," Key exists, check type",1,1,0,1
9070," ""append"" is an argument, so always an sds",0,0,0,0
9071, Append the value,0,1,0,1
9072,-----------------------------------------------------------------------------  Sorted set API ----------------------------------------------------------------------------,0,0,0,0
9073, ZSETs are ordered sets using two data structures to hold the same elements  in order to get O(log(N)) INSERT and REMOVE operations into a sorted  data structure.,1,0,0,1
9074,The elements are added to a hash table mapping Redis objects to scores.,0,0,0,0
9075,"At the same time the elements are added to a skip list mapping scores  to Redis objects (so objects are sorted by scores in this ""view"").",1,0,0,1
9076,Note that the SDS string representing the element is the same in both  the hash table and skiplist in order to save memory.,1,0,0,1
9077,What we do in order  to manage the shared SDS string more easily is to free the SDS string  only in zslFreeNode().,1,0,0,1
9078,The dictionary has no value free method set.,1,1,0,1
9079,"So we should always remove an element from the dictionary, and later from  the skiplist.",0,0,0,0
9080,"This skiplist implementation is almost a C translation of the original  algorithm described by William Pugh in ""Skip Lists: A Probabilistic  Alternative to Balanced Trees"", modified in three ways:  a) this implementation allows for repeated scores.",1,0,0,1
9081,b) the comparison is not just by key (our 'score') but by satellite data.,1,0,0,1
9082,"c) there is a back pointer, so it's a doubly linked list with the back  pointers being only at ""level 1"".",1,0,0,1
9083,"This allows to traverse the list  from tail to head, useful for ZREVRANGE.",1,0,0,1
9084,-----------------------------------------------------------------------------  Skiplist implementation of the low level API ----------------------------------------------------------------------------,1,0,0,1
9085, Create a skiplist node with the specified number of levels.,0,0,0,0
9086,The SDS string 'ele' is referenced by the node after the call.,0,0,0,0
9087, Create a new skiplist.,1,0,0,1
9088, Free the specified skiplist node.,1,0,0,1
9089,"The referenced SDS string representation  of the element is freed too, unless node->ele is set to NULL before calling  this function.",0,0,0,0
9090, Free a whole skiplist.,1,0,0,1
9091, Returns a random level for the new skiplist node we are going to create.,1,0,0,1
9092,"The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL  (both inclusive), with a powerlaw-alike distribution where higher  levels are less likely to be returned.",1,0,0,1
9093, Insert a new node in the skiplist.,1,0,0,1
9094,Assumes the element does not already  exist (up to the caller to enforce that).,0,0,0,0
9095,The skiplist takes ownership  of the passed SDS string 'ele'.,0,0,0,0
9096, store rank that is crossed to reach the insert position,1,0,0,1
9097," we assume the element is not already inside, since we allow duplicated      scores, reinserting the same element should never happen since the      caller of zslInsert() should test in the hash table if the element is      already inside or not.",1,0,0,1
9098, update span covered by update[i] as x is inserted here,0,0,0,0
9099, increment span for untouched levels,0,0,0,0
9100," Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank",0,0,0,0
9101, Delete an element with matching score or element from the skiplist.,0,0,0,0
9102,"The function returns 1 if the node was found and deleted, otherwise  0 is returned.",0,0,0,0
9103,"If 'node' is NULL the deleted node is freed by zslFreeNode(), otherwise  it is not freed (but just unlinked) and node is set to the node pointer,  so that it is possible for the caller to reuse the node (including the  referenced SDS string at node->ele).",1,0,0,1
9104," We may have multiple elements with the same score, what we need      is to find the element with both the right score and object.",1,0,0,1
9105, not found,0,0,0,0
9106, Returns if there is a part of the zset is in range.,0,0,0,0
9107, Test for ranges that will always be empty.,1,1,0,1
9108, Find the first node that is contained in the specified range.,1,1,0,1
9109,Returns NULL when no element is contained in the range.,0,1,0,1
9110," If everything is out of range, return early.",1,1,0,1
9111, Go forward while OUT of range.,0,1,0,1
9112," This is an inner range, so the next node cannot be NULL.",1,1,0,1
9113, Check if score <= max.,0,1,0,1
9114, Find the last node that is contained in the specified range.,1,1,0,1
9115,Returns NULL when no element is contained in the range.,0,1,0,1
9116," If everything is out of range, return early.",1,1,0,1
9117, Go forward while IN range.,0,1,0,1
9118," This is an inner range, so this node cannot be NULL.",1,1,0,1
9119, Check if score >= min.,0,1,0,1
9120, Delete all the elements with score between min and max from the skiplist.,0,0,0,0
9121,"Min and max are inclusive, so a score >= min || score <= max is deleted.",0,1,0,1
9122,"Note that this function takes the reference to the hash table view of the  sorted set, in order to remove the elements from the hash table too.",0,0,0,0
9123, Current node is the last with score < or <= min.,1,1,0,1
9124, Delete nodes while in range.,0,1,0,1
9125, Here is where x->ele is actually released.,1,0,0,1
9126, Current node is the last with score < or <= min.,1,1,0,1
9127, Delete nodes while in range.,0,1,0,1
9128, Here is where x->ele is actually released.,1,0,0,1
9129, Delete all the elements with rank between start and end from the skiplist.,1,0,0,1
9130,Start and end are inclusive.,0,1,0,1
9131,Note that start and end need to be 1-based,0,1,0,1
9132, Find the rank for an element by both score and key.,1,1,0,1
9133,"Returns 0 when the element cannot be found, rank otherwise.",1,1,0,1
9134,Note that the rank is 1-based due to the span of zsl->header to the  first element.,1,0,0,1
9135," x might be equal to zsl->header, so test if obj is non-NULL",1,0,0,1
9136, Finds an element by its rank.,1,1,0,1
9137,The rank argument needs to be 1-based.,1,1,0,1
9138, Populate the rangespec according to the objects min and max.,0,0,0,0
9139, Parse the min-max interval.,0,1,0,1
9140,"If one of the values is prefixed      by the ""("" character, it's considered ""open"".",1,0,0,1
9141,For instance      ZRANGEBYSCORE zset (1.5 (2.5 will match min < x < max      ZRANGEBYSCORE zset 1.5 2.5 will instead match min <= x <= max,0,0,0,0
9142, ------------------------ Lexicographic ranges ----------------------------,0,1,0,1
9143, Parse max or min argument of ZRANGEBYLEX.,0,1,0,1
9144,"(foo means foo (open interval)   [foo means foo (closed interval)   - means the min string possible   + means the max string possible     If the string is valid the dest pointer is set to the redis object   that will be used for the comparision, and ex will be set to 0 or 1   respectively if the item is exclusive or inclusive.",1,0,0,1
9145,C_OK will be   returned.,0,0,0,0
9146,"If the string is not a valid range C_ERR is returned, and the value   of dest and ex is undefined.",0,0,0,0
9147," Free a lex range structure, must be called only after zelParseLexRange()  populated the structure with success (C_OK returned).",1,0,0,1
9148, Populate the lex rangespec according to the objects min and max.,0,0,0,0
9149,Return C_OK on success.,1,1,0,1
9150,On error C_ERR is returned.,0,1,0,1
9151,"When OK is returned the structure must be freed with zslFreeLexRange(),  otherwise no release is needed.",1,0,0,1
9152, The range can't be valid if objects are integer encoded.,0,1,0,1
9153,Every item must start with ( or [.,0,0,0,0
9154, This is just a wrapper to sdscmp() that is able to  handle shared.minstring and shared.maxstring as the equivalent of  -inf and +inf for strings,1,0,0,1
9155, Returns if there is a part of the zset is in the lex range.,0,0,0,0
9156, Test for ranges that will always be empty.,1,1,0,1
9157, Find the first node that is contained in the specified lex range.,1,0,0,1
9158,Returns NULL when no element is contained in the range.,0,1,0,1
9159," If everything is out of range, return early.",1,1,0,1
9160, Go forward while OUT of range.,0,1,0,1
9161," This is an inner range, so the next node cannot be NULL.",1,1,0,1
9162, Check if score <= max.,0,1,0,1
9163, Find the last node that is contained in the specified range.,1,1,0,1
9164,Returns NULL when no element is contained in the range.,0,1,0,1
9165," If everything is out of range, return early.",1,1,0,1
9166, Go forward while IN range.,0,1,0,1
9167," This is an inner range, so this node cannot be NULL.",1,1,0,1
9168, Check if score >= min.,0,1,0,1
9169,-----------------------------------------------------------------------------  Ziplist-backed sorted set API ----------------------------------------------------------------------------,0,0,0,0
9170, Return a ziplist element as an SDS string.,0,0,0,0
9171, Compare element in sorted set with given element.,0,1,0,1
9172, Store string representation of long long in buf.,1,0,0,1
9173, Move to next entry based on the values in eptr and sptr.,0,0,0,0
9174,Both are set to  NULL when there is no next entry.,0,0,0,0
9175, No next entry.,0,0,0,0
9176, Move to the previous entry based on the values in eptr and sptr.,1,0,0,1
9177,Both are  set to NULL when there is no next entry.,0,0,0,0
9178, No previous entry.,1,1,0,1
9179, Returns if there is a part of the zset is in range.,0,0,0,0
9180,Should only be used  internally by zzlFirstInRange and zzlLastInRange.,1,0,0,1
9181, Test for ranges that will always be empty.,1,1,0,1
9182, Last score.,1,1,0,1
9183, Empty sorted set,1,1,0,1
9184, First score.,1,1,0,1
9185, Find pointer to the first element contained in the specified range.,1,1,0,1
9186,Returns NULL when no element is contained in the range.,0,1,0,1
9187," If everything is out of range, return early.",1,1,0,1
9188, Check if score <= max.,0,1,0,1
9189, Move to next element.,0,1,0,1
9190, Find pointer to the last element contained in the specified range.,1,1,0,1
9191,Returns NULL when no element is contained in the range.,0,1,0,1
9192," If everything is out of range, return early.",1,1,0,1
9193, Check if score >= min.,0,1,0,1
9194, Move to previous element by moving to the score of previous element.,1,1,0,1
9195,"When this returns NULL, we know there also is no element.",0,1,0,1
9196, Returns if there is a part of the zset is in range.,0,0,0,0
9197,Should only be used  internally by zzlFirstInRange and zzlLastInRange.,1,0,0,1
9198, Test for ranges that will always be empty.,1,1,0,1
9199, Last element.,1,1,0,1
9200, First element.,1,1,0,1
9201, Find pointer to the first element contained in the specified lex range.,1,0,0,1
9202,Returns NULL when no element is contained in the range.,0,1,0,1
9203," If everything is out of range, return early.",1,1,0,1
9204, Check if score <= max.,0,1,0,1
9205, Move to next element.,0,1,0,1
9206, This element score.,0,1,0,1
9207,Skip it.,0,1,0,1
9208, Next element.,0,1,0,1
9209, Find pointer to the last element contained in the specified lex range.,1,0,0,1
9210,Returns NULL when no element is contained in the range.,0,1,0,1
9211," If everything is out of range, return early.",1,1,0,1
9212, Check if score >= min.,0,1,0,1
9213, Move to previous element by moving to the score of previous element.,1,1,0,1
9214,"When this returns NULL, we know there also is no element.",0,1,0,1
9215," Matching element, pull out score.",0,1,0,1
9216, Move to next element.,0,1,0,1
9217," Delete (element,score) pair from ziplist.",0,0,0,0
9218,Use local copy of eptr because we  don't want to modify the one given as argument.,0,0,0,0
9219, TODO: add function to ziplist API to delete N elements from offset.,0,0,0,0
9220," Keep offset relative to zl, as it might be re-allocated.",0,0,0,0
9221, Insert score after the element.,0,1,0,1
9222," Insert (element,score) pair in ziplist.",0,0,0,0
9223,This function assumes the element is  not yet present in the list.,0,0,0,0
9224, First element with score larger than score for element to be              inserted.,1,0,0,1
9225,This means we should take its spot in the list to              maintain ordering.,0,0,0,0
9226, Ensure lexicographical ordering for elements.,0,1,0,1
9227, Move to next element.,0,1,0,1
9228, Push on tail of list when it was not yet inserted.,0,1,0,1
9229," When the tail of the ziplist is deleted, eptr will point to the sentinel      byte and ziplistNext will return NULL.",0,0,0,0
9230, Delete both the element and the score.,0,1,0,1
9231, No longer in range.,0,1,0,1
9232," When the tail of the ziplist is deleted, eptr will point to the sentinel      byte and ziplistNext will return NULL.",0,0,0,0
9233, Delete both the element and the score.,0,1,0,1
9234, No longer in range.,0,1,0,1
9235, Delete all the elements with rank between start and end from the skiplist.,1,0,0,1
9236,Start and end are inclusive.,0,1,0,1
9237,Note that start and end need to be 1-based,0,1,0,1
9238,-----------------------------------------------------------------------------  Common sorted set API ----------------------------------------------------------------------------,1,0,0,1
9239," Approach similar to zslFree(), since we want to free the skiplist at          the same time as creating the ziplist.",1,0,0,1
9240, Convert the sorted set object into a ziplist if it is not already a ziplist  and if the number of elements and the maximum element size is within the  expected ranges.,1,0,0,1
9241, Return (by reference) the score of the specified member of the sorted set  storing it into score.,0,0,0,0
9242,If the element does not exist C_ERR is returned  otherwise C_OK is returned and score is correctly populated.,0,0,0,0
9243,"If 'zobj' or 'member' is NULL, C_ERR is returned.",0,0,0,0
9244," Add a new element or update the score of an existing element in a sorted  set, regardless of its encoding.",1,0,0,1
9245,The set of flags change the command behavior.,0,1,0,1
9246,They are passed with an integer  pointer since the function will clear the flags and populate them with  other flags to indicate different conditions.,1,0,0,1
9247,The input flags are the following:   ZADD_INCR: Increment the current element score by 'score' instead of updating             the current element score.,1,0,0,1
9248,"If the element does not exist, we             assume 0 as previous score.",1,0,0,1
9249,ZADD_NX:   Perform the operation only if the element does not exist.,1,0,0,1
9250,ZADD_XX:   Perform the operation only if the element already exist.,1,0,0,1
9251,"When ZADD_INCR is used, the new score of the element is stored in  'newscore' if 'newscore' is not NULL.",1,0,0,1
9252,The returned flags are the following:   ZADD_NAN:     The resulting score is not a number.,1,0,0,1
9253,ZADD_ADDED:   The element was added (not present before the call).,0,0,0,0
9254,ZADD_UPDATED: The element score was updated.,0,1,0,1
9255,ZADD_NOP:     No operation was performed because of NX or XX.,0,0,0,0
9256,"Return value:   The function returns 1 on success, and sets the appropriate flags  ADDED or UPDATED to signal what happened during the operation (note that  none could be set if we re-added an element using the same score it used  to have, or in the case a zero increment is used).",1,0,0,1
9257,"The function returns 0 on erorr, currently only when the increment  produces a NAN condition, or when the 'score' value is NAN since the  start.",1,0,0,1
9258,The commad as a side effect of adding a new element may convert the sorted  set internal encoding from ziplist to hashtable+skiplist.,1,0,0,1
9259,"Memory managemnet of 'ele':   The function does not take ownership of the 'ele' SDS string, but copies  it if needed.",0,0,0,0
9260, Turn options into simple to check vars.,1,1,0,1
9261, We'll return our response flags.,0,1,0,1
9262, NaN as input is an error regardless of all the other parameters.,1,1,0,1
9263, Update the sorted set according to its encoding.,0,1,0,1
9264, NX?,0,1,0,1
9265,"Return, same element already exists.",1,1,0,1
9266, Prepare the score for the increment if needed.,0,1,0,1
9267, Remove and re-insert when score changed.,0,1,0,1
9268, Optimize: check if the element is too large or the list              becomes too long before executing zzlInsert.,1,0,0,1
9269, NX?,0,1,0,1
9270,"Return, same element already exists.",1,1,0,1
9271, Prepare the score for the increment if needed.,0,1,0,1
9272, Remove and re-insert when score changes.,0,1,0,1
9273," We reused the node->ele SDS string, free the node now                  since zslInsert created a new one.",1,0,0,1
9274," Note that we did not removed the original element from                  the hash table representing the sorted set, so we just                  update the score.",1,0,0,1
9275, Update score ptr.,0,0,0,0
9276, Never reached.,0,1,0,1
9277," Delete the element 'ele' from the sorted set, returning 1 if the element  existed and was deleted, 0 otherwise (the element was not there).",0,0,0,0
9278, Get the score in order to delete from the skiplist later.,0,0,0,0
9279, Delete from the hash table and later from the skiplist.,0,0,0,0
9280,"Note that the order is important: deleting from the skiplist              actually releases the SDS string representing the element,              which is shared between the skiplist and the hash table, so              we need to delete from the skiplist as the final step.",1,0,0,1
9281, Delete from skiplist.,0,0,0,0
9282, No such element found.,1,1,0,1
9283, Given a sorted set object returns the 0-based rank of the object or  -1 if the object does not exist.,1,0,0,1
9284,For rank we mean the position of the element in the sorted collection  of elements.,1,0,0,1
9285,"So the first element has rank 0, the second rank 1, and so  forth up to length-1 elements.",1,0,0,1
9286,"If 'reverse' is false, the rank is returned considering as first element  the one with the lowest score.",1,0,0,1
9287,Otherwise if 'reverse' is non-zero  the rank is computed considering as element with rank 0 the one with  the highest score.,1,0,0,1
9288, Existing elements always have a rank.,1,1,0,1
9289,-----------------------------------------------------------------------------  Sorted set commands ----------------------------------------------------------------------------,0,0,0,0
9290, This generic command implements both ZADD and ZINCRBY.,0,1,0,1
9291," The following vars are used in order to track what the command actually      did during the execution, to reply to the client and to trigger the      notification of keyspace change.",1,0,0,1
9292, Number of new elements added.,1,1,0,1
9293, Number of elements with updated score.,0,1,0,1
9294," Number of elements processed, may remain zero with                           options like XX.",0,0,0,0
9295, Parse options.,0,1,0,1
9296,At the end 'scoreidx' is set to the argument position      of the score of the first score-element pair.,1,0,0,1
9297, Turn options into simple to check vars.,1,1,0,1
9298," After the options, we expect to have an even number of args, since      we expect any number of score-element pairs.",0,0,0,0
9299, Now this holds the number of score-element pairs.,0,1,0,1
9300, Check for incompatible options.,0,1,0,1
9301," Start parsing all the scores, we need to emit any syntax error      before executing additions to the sorted set, as the command should      either execute fully or nothing at all.",0,0,0,0
9302, Lookup the key and create the sorted set if does not exist.,1,0,0,1
9303, No key + XX option: nothing to do.,1,1,0,1
9304, ZINCRBY or INCR option.,0,1,0,1
9305, ZADD.,0,1,0,1
9306," Implements ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZREMRANGEBYLEX commands.",0,1,0,1
9307, Step 1: Parse the range.,0,1,0,1
9308, Step 2: Lookup & range sanity checks if needed.,0,0,0,0
9309, Sanitize indexes.,0,1,0,1
9310," Invariant: start >= 0, so this test will be true when end < 0.",1,1,0,1
9311,The range is empty when start > end or start >= length.,1,1,0,1
9312, Step 3: Perform the range deletion operation.,0,1,0,1
9313, Step 4: Notifications and reply.,0,1,0,1
9314," Set, sorted set",0,1,0,1
9315, Set iterators.,0,1,0,1
9316, Sorted set iterators.,0,1,0,1
9317, Use dirty flags for pointers that need to be cleaned up in the next  iteration over the zsetopval.,1,0,0,1
9318,"The dirty flag for the long long value is  special, since long long values don't need cleanup.",1,0,0,1
9319,"Instead, it means that  we already checked that ""ell"" holds a long long, or tried to convert another  representation into a long long value.",1,0,0,1
9320,"When this was successful,  OPVAL_VALID_LL is set as well.",1,0,0,1
9321, Store value retrieved from the iterator.,0,1,0,1
9322, Private buffer.,1,1,0,1
9323, skip,0,0,0,0
9324, skip,0,0,0,0
9325, skip,0,0,0,0
9326, Check if the current value is valid.,1,1,0,1
9327,"If so, store it in the passed structure  and move to the next element.",0,0,0,0
9328,"If not valid, this means we have reached the  end of the structure and can abort.",0,0,0,0
9329, Move to next element.,0,1,0,1
9330, Move to next element.,0,1,0,1
9331," No need to check both, but better be explicit.",1,1,0,1
9332, Move to next element.,0,1,0,1
9333, Move to next element.,0,1,0,1
9334," The long long was already set, flag as valid.",1,0,0,1
9335, This is different from zuiSdsFromValue since returns a new SDS string  which is up to the caller to free.,1,0,0,1
9336, We have already one to return!,0,1,0,1
9337, Find value pointed to by val in the source pointer to by op.,0,1,0,1
9338,"When found,  return 1 and store its score in target.",0,0,0,0
9339,Return 0 otherwise.,0,1,0,1
9340, Score is already set by zzlFind.,0,0,0,0
9341, The result of adding two doubles is NaN when one variable          is +inf and the other is -inf.,1,0,0,1
9342,"When these numbers are added,          we maintain the convention of the result being 0.0.",0,0,0,0
9343, safety net,0,0,0,0
9344, hash function,0,0,0,0
9345, key dup,1,0,0,1
9346, val dup,0,0,0,0
9347, key compare,1,0,0,1
9348, key destructor,1,0,0,1
9349, val destructor,0,0,0,0
9350, expect setnum input keys to be given,0,0,0,0
9351, test if the expected number of keys would overflow,1,0,0,1
9352, read keys to be used for input,0,0,0,0
9353, Default all weights to 1.,0,1,0,1
9354, parse optional extra arguments,1,0,0,1
9355," sort sets from the smallest to largest, this will improve our      algorithm's performance",0,0,0,0
9356, Skip everything if the smallest input is empty.,1,1,0,1
9357," Precondition: as src[0] is non-empty and the inputs are ordered              by size, all src[i > 0] are non-empty too.",0,0,0,0
9358," It is not safe to access the zset we are                      iterating, so explicitly check for equal object.",1,0,0,1
9359, Only continue when present in every input.,1,1,0,1
9360, Our union is at least as large as the largest set.,1,1,0,1
9361,Resize the dictionary ASAP to avoid useless rehashing.,1,0,0,1
9362, Step 1: Create a dictionary of elements -> aggregated-scores          by iterating one sorted set after the other.,1,0,0,1
9363, Initialize value,0,1,0,1
9364, Search for this element in the accumulating dictionary.,0,1,0,1
9365," If we don't have it, we need to create a new entry.",1,1,0,1
9366," Remember the longest single element encountered,                      to understand if it's possible to convert to ziplist                      at the end.",1,0,0,1
9367, Update the element with its initial score.,0,1,0,1
9368, Update the score with the score of the new instance                      of the element found in the current sorted set.,1,0,0,1
9369,Here we access directly the dictEntry double                      value inside the union as it is a big speedup                      compared to using the getDouble or setDouble API.,1,0,0,1
9370, Step 2: convert the dictionary into the final sorted set.,1,1,0,1
9371," We now are aware of the final size of the resulting sorted set,          let's resize the dictionary embedded inside the sorted set to the          right size, in order to save rehashing time.",1,0,0,1
9372, Sanitize indexes.,0,1,0,1
9373," Invariant: start >= 0, so this test will be true when end < 0.",1,1,0,1
9374,The range is empty when start > end or start >= length.,1,1,0,1
9375, Return the result in form of a multi-bulk reply,0,0,0,0
9376," Check if starting point is trivial, before doing log(N) lookup.",1,0,0,1
9377," This command implements ZRANGEBYSCORE, ZREVRANGEBYSCORE.",0,1,0,1
9378, Parse the range arguments.,0,1,0,1
9379," Range is given as [max,min]",0,0,0,0
9380," Range is given as [min,max]",0,0,0,0
9381, Parse optional extra arguments.,1,1,0,1
9382,"Note that ZCOUNT will exactly have      4 arguments, so we'll never enter the following code path.",1,0,0,1
9383," Ok, lookup the key and get the range",1,0,0,1
9384," If reversed, get the last node in range as starting point.",1,1,0,1
9385," No ""first"" element in the specified interval.",1,0,0,1
9386, Get score pointer for the first element.,1,1,0,1
9387," We don't know in advance how many matching elements there are in the          list, so we push this object that will represent the multi-bulk          length in the output buffer, and will ""fix"" it later",1,0,0,1
9388," If there is an offset, just traverse the number of elements without          checking the score because that is done in the next loop.",0,0,0,0
9389, Abort when the node is no longer in range.,0,1,0,1
9390," We know the element exists, so ziplistGet should always succeed",0,0,0,0
9391, Move to next node,0,1,0,1
9392," If reversed, get the last node in range as starting point.",1,1,0,1
9393," No ""first"" element in the specified interval.",1,0,0,1
9394," We don't know in advance how many matching elements there are in the          list, so we push this object that will represent the multi-bulk          length in the output buffer, and will ""fix"" it later",1,0,0,1
9395," If there is an offset, just traverse the number of elements without          checking the score because that is done in the next loop.",0,0,0,0
9396, Abort when the node is no longer in range.,0,1,0,1
9397, Move to next node,0,1,0,1
9398, Parse the range arguments,0,1,0,1
9399, Lookup the sorted set,0,0,0,0
9400, Use the first element in range as the starting point,1,1,0,1
9401," No ""first"" element",1,0,0,1
9402, First element is in range,1,1,0,1
9403, Iterate over elements in range,0,1,0,1
9404, Abort when the node is no longer in range.,0,1,0,1
9405, Find first element in range,1,1,0,1
9406," Use rank of first element, if any, to determine preliminary count",1,1,0,1
9407, Find last element in range,1,1,0,1
9408," Use rank of last element, if any, to determine the actual count",1,1,0,1
9409, Parse the range arguments,0,1,0,1
9410, Lookup the sorted set,0,0,0,0
9411, Use the first element in range as the starting point,1,1,0,1
9412," No ""first"" element",1,0,0,1
9413, First element is in range,1,1,0,1
9414, Iterate over elements in range,0,1,0,1
9415, Abort when the node is no longer in range.,0,1,0,1
9416, Find first element in range,1,1,0,1
9417," Use rank of first element, if any, to determine preliminary count",1,1,0,1
9418, Find last element in range,1,1,0,1
9419," Use rank of last element, if any, to determine the actual count",1,1,0,1
9420," This command implements ZRANGEBYLEX, ZREVRANGEBYLEX.",0,1,0,1
9421, Parse the range arguments.,0,1,0,1
9422," Range is given as [max,min]",0,0,0,0
9423," Range is given as [min,max]",0,0,0,0
9424, Parse optional extra arguments.,1,1,0,1
9425,"Note that ZCOUNT will exactly have      4 arguments, so we'll never enter the following code path.",1,0,0,1
9426," Ok, lookup the key and get the range",1,0,0,1
9427," If reversed, get the last node in range as starting point.",1,1,0,1
9428," No ""first"" element in the specified interval.",1,0,0,1
9429, Get score pointer for the first element.,1,1,0,1
9430," We don't know in advance how many matching elements there are in the          list, so we push this object that will represent the multi-bulk          length in the output buffer, and will ""fix"" it later",1,0,0,1
9431," If there is an offset, just traverse the number of elements without          checking the score because that is done in the next loop.",0,0,0,0
9432, Abort when the node is no longer in range.,0,1,0,1
9433," We know the element exists, so ziplistGet should always              succeed.",0,0,0,0
9434, Move to next node,0,1,0,1
9435," If reversed, get the last node in range as starting point.",1,1,0,1
9436," No ""first"" element in the specified interval.",1,0,0,1
9437," We don't know in advance how many matching elements there are in the          list, so we push this object that will represent the multi-bulk          length in the output buffer, and will ""fix"" it later",1,0,0,1
9438," If there is an offset, just traverse the number of elements without          checking the score because that is done in the next loop.",0,0,0,0
9439, Abort when the node is no longer in range.,0,1,0,1
9440, Move to next node,0,1,0,1
9441, Glob-style pattern matching.,0,1,0,1
9442, match,0,0,0,0
9443, match,0,0,0,0
9444, no match,0,0,0,0
9445, no match,0,0,0,0
9446, no match,0,0,0,0
9447, fall through,0,0,0,0
9448, no match,0,0,0,0
9449, no match,0,0,0,0
9450," Convert a string representing an amount of memory into the number of  bytes, so for instance memtoll(""1Gb"") will return 1073741824 that is  (102410241024).",0,0,0,0
9451,"On parsing error, if err is not NULL, it's set to 1, otherwise it's  set to 0.",0,0,0,0
9452,"On error the function return value is 0, regardless of the  fact 'err' is NULL or not.",0,0,0,0
9453, unit multiplier,0,0,0,0
9454, Search the first non digit character.,1,1,0,1
9455," Copy the digits into a buffer, we'll use strtoll() to convert      the digit (without the unit) into a number.",0,0,0,0
9456, Return the number of digits of 'v' when converted to string in radix 10.,0,0,0,0
9457,See ll2string() for more information.,1,1,0,1
9458, Like digits10() but for signed values.,0,1,0,1
9459, Abs value of LLONG_MIN requires special handling.,1,1,0,1
9460, +1 for the minus.,1,1,0,1
9461, Convert a long long into a string.,1,0,0,1
9462,Returns the number of  characters needed to represent the number.,0,0,0,0
9463,"If the buffer is not big enough to store the string, 0 is returned.",1,1,0,1
9464,Based on the following article (that apparently does not provide a  novel approach but only publicizes an already used technique):   https: or  or www.facebook.com or notes or facebook-engineering or three-optimization-tips-for-c or 10151361643253920   Modified in order to handle signed integers since the original code was  designed for unsigned integers.,1,0,0,1
9465," The main loop works with 64bit unsigned integers for simplicity, so      we convert the number here and remember if it is negative.",1,0,0,1
9466, Check length.,0,1,0,1
9467, Null term.,0,1,0,1
9468, Handle last 1-2 digits.,1,1,0,1
9469, Add sign.,0,1,0,1
9470, Convert a string into a long long.,1,0,0,1
9471,"Returns 1 if the string could be parsed  into a (non-overflowing) long long, 0 otherwise.",1,0,0,1
9472,The value will be set to  the parsed value when appropriate.,1,0,0,1
9473,"Note that this function demands that the string strictly represents  a long long: no spaces or other characters before or after the string  representing the number are accepted, nor zeroes at the start if not  for the string ""0"" representing the zero number.",1,0,0,1
9474,"Because of its strictness, it is safe to use this function to check if  you can convert a string into a long long, and obtain back the string  from the number without any loss in the string representation.",1,0,0,1
9475, Special case: first and only digit is 0.,1,1,0,1
9476, Abort on only a negative sign.,1,1,0,1
9477," First digit should be 1-9, otherwise the string should just be 0.",1,1,0,1
9478, Overflow.,0,1,0,1
9479, Overflow.,0,1,0,1
9480, Return if not all bytes were used.,0,1,0,1
9481, Overflow.,0,1,0,1
9482, Overflow.,0,1,0,1
9483, Convert a string into a long.,1,1,0,1
9484,"Returns 1 if the string could be parsed into a  (non-overflowing) long, 0 otherwise.",1,0,0,1
9485,The value will be set to the parsed  value when appropriate.,1,0,0,1
9486, Convert a string into a double.,0,1,0,1
9487,"Returns 1 if the string could be parsed  into a (non-overflowing) double, 0 otherwise.",0,0,0,0
9488,The value will be set to  the parsed value when appropriate.,1,0,0,1
9489,Note that this function demands that the string strictly represents  a double: no spaces or other characters before or after the string  representing the number are accepted.,1,0,0,1
9490, Convert a double to a string representation.,0,1,0,1
9491,Returns the number of bytes  required.,0,0,0,0
9492,The representation should always be parsable by strtod(3).,0,0,0,0
9493,This function does not support human-friendly formatting like ld2string  does.,0,0,0,0
9494,It is intented mainly to be used inside t_zset.c when writing scores  into a ziplist representing a sorted set.,1,0,0,1
9495," See: http: or  or en.wikipedia.org or wiki or Signed_zero, ""Comparisons"".",0,0,0,0
9496, Check if the float is in a safe range to be casted into a          long long.,1,0,0,1
9497,We are assuming that long long is 64 bit here.,1,0,0,1
9498,Also we are assuming that there are no implementations around where          double has precision < 52 bit.,0,0,0,0
9499,Under this assumptions we test if a double is inside an interval          where casting to long long is safe.,1,0,0,1
9500,Then using two castings we          make sure the decimal part is zero.,1,0,0,1
9501,If all this is true we use          integer printing function that is much faster.,1,0,0,1
9502, Convert a long double into a string.,1,1,0,1
9503,"If humanfriendly is non-zero  it does not use exponential format and trims trailing zeroes at the end,  however this results in loss of precision.",0,0,0,0
9504,Otherwise exp format is used  and the output of snprintf() is not modified.,0,0,0,0
9505,The function returns the length of the string or zero if there was not  enough buffer room to store it.,1,0,0,1
9506, Libc in odd systems (Hi Solaris!),1,0,0,1
9507,"will format infinite in a          different way, so better to handle it in an explicit way.",1,0,0,1
9508, No room.,0,1,0,1
9509,"5 is ""-inf\0""",0,0,0,0
9510," We use 17 digits precision since with 128 bit floats that precision          after rounding is able to represent most small decimal numbers in a          way that is ""non surprising"" for the user (that is, most small          decimal numbers will be represented in a way that when converted          back into a string are exactly the same as what the user typed.)",1,0,0,1
9511, No room.,0,1,0,1
9512, Now remove trailing zeroes after the '.',0,1,0,1
9513, No room.,0,1,0,1
9514," Get random bytes, attempts to get an initial seed from  or dev or urandom and  the uses a one way hash function in counter mode to generate a random  stream.",1,0,0,1
9515,"However if  or dev or urandom is not available, a weaker seed is used.",1,0,0,1
9516,"This function is not thread safe, since the state is global.",1,1,0,1
9517, Global state.,0,1,0,1
9518," The SHA1 seed, from  or dev or urandom.",0,0,0,0
9519, The counter we hash with the seed.,0,1,0,1
9520," Initialize a seed and use SHA1 in counter mode, where we hash          the same seed with a progressive counter.",1,0,0,1
9521,"For the goals of this          function we just need non-colliding strings, there are no          cryptographic security needs.",0,0,0,0
9522," Revert to a weaker seed, and in this case reseed again              at every call.",0,0,0,0
9523," Generate the Redis ""Run ID"", a SHA1-sized random number that identifies a  given execution of Redis, so that if you are talking with an instance  having run_id == A, and you reconnect and it has run_id == B, you can be  sure that it is either a different instance or it was restarted.",1,0,0,1
9524," Given the filename, return the absolute path as an SDS string, or NULL  if it fails for some reason.",1,0,0,1
9525,"Note that ""filename"" may be an absolute path  already, this will be detected and handled correctly.",1,0,0,1
9526,"The function does not try to normalize everything, but only the obvious  case of one or more "".. or "" appearning at the start of ""filename""  relative path.",1,0,0,1
9527, Path is already absolute.,1,1,0,1
9528," If path is relative, join cwd and relative path.",0,0,0,0
9529," At this point we have the current path always ending with "" or "", and      the trimmed relative path.",1,0,0,1
9530,Try to normalize the obvious case of      trailing .. or  elements at the start of the path.,1,0,0,1
9531,"For every "".. or "" we find in the filename, we remove it and also remove      the last element of the cwd, unless the current cwd is "" or "".",1,0,0,1
9532, Finally glue the two parts together.,1,0,0,1
9533, Return true if the specified path is just a file basename without any  relative or absolute path.,1,0,0,1
9534,"This function just checks that no  or  or \  character exists inside the specified path, that's enough in the  environments where Redis runs.",1,0,0,1
9535, May not start with +.,0,1,0,1
9536, Leading space.,0,1,0,1
9537, Trailing space.,0,1,0,1
9538, May not start with 0.,0,1,0,1
9539, overflow,0,0,0,0
9540, overflow,0,0,0,0
9541, May not start with +.,0,1,0,1
9542, May not start with 0.,0,1,0,1
9543, overflow,0,0,0,0
9544, overflow,0,0,0,0
9545," Special ""end of ziplist"" entry.",1,0,0,1
9546," Max number of bytes of the previous entry, for                               the ""prevlen"" field prefixing each entry, to be                               represented with just a single byte.",1,0,0,1
9547,"Otherwise                               it is represented as FF AA BB CC DD, where                               AA BB CC DD are a 4 bytes unsigned integer                               representing the previous entry len.",1,0,0,1
9548, Different encoding or length possibilities,1,1,0,1
9549, 4 bit integer immediate encoding |1111xxxx| with xxxx between  0001 and 1101.,0,0,0,0
9550, Mask to extract the 4 bits value.,0,1,0,1
9551,To add                                   one is needed to reconstruct the value.,0,0,0,0
9552, Macro to determine if the entry is a string.,0,1,0,1
9553,"String entries never start  with ""11"" as most significant bits of the first byte.",1,0,0,1
9554, Utility macros.,0,1,0,1
9555, Return total bytes a ziplist is composed of.,1,0,0,1
9556, Return the offset of the last item inside the ziplist.,1,0,0,1
9557," Return the length of a ziplist, or UINT16_MAX if the length cannot be  determined without scanning the whole ziplist.",1,0,0,1
9558, The size of a ziplist header: two 32 bit integers for the total  bytes count and last item offset.,1,0,0,1
9559,One 16 bit integer for the number  of items field.,0,0,0,0
9560," Size of the ""end of ziplist"" entry.",0,0,0,0
9561,Just one byte.,0,1,0,1
9562, Return the pointer to the first entry of a ziplist.,1,0,0,1
9563," Return the pointer to the last entry of a ziplist, using the  last entry offset inside the ziplist header.",1,0,0,1
9564," Return the pointer to the last byte of a ziplist, which is, the  end of ziplist FF entry.",1,0,0,1
9565, Increment the number of items field in the ziplist header.,0,0,0,0
9566,"Note that this  macro should never overflow the unsigned 16 bit integer, since entires are  always pushed one at a time.",0,0,0,0
9567,When UINT16_MAX is reached we want the count  to stay there to signal that a full scan is needed to get the number of  items inside the ziplist.,1,0,0,1
9568, We use this function to receive information about a ziplist entry.,0,0,0,0
9569,"Note that this is not how the data is actually encoded, is just what we  get filled by a function in order to operate more easily.",1,0,0,1
9570, Bytes used to encode the previos entry len,0,0,0,0
9571, Previous entry len.,1,0,0,1
9572, Bytes used to encode this entry type or len.,0,0,0,0
9573,"For example strings have a 1, 2 or 5 bytes                                    header.",0,0,0,0
9574,Integers always use a single byte.,1,1,0,1
9575, Bytes used to represent the actual entry.,1,1,0,1
9576,"For strings this is just the string length                                    while for integers it is 1, 2, 3, 4, 8 or                                    0 (for 4 bit immediate) depending on the                                    number range.",0,0,0,0
9577, prevrawlensize + lensize.,0,0,0,0
9578, Set to ZIP_STR_ or ZIP_INT_ depending on                                    the entry encoding.,0,0,0,0
9579,However for 4 bits                                    immediate integers this can assume a range                                    of values and must be range-checked.,0,0,0,0
9580," Pointer to the very start of the entry, that                                    is, this points to prev-entry-len field.",1,0,0,1
9581, Extract the encoding from the byte pointed by 'ptr' and set it into  'encoding' field of the zlentry structure.,0,0,0,0
9582, Return bytes needed to store integer encoded by 'encoding'.,0,1,0,1
9583, 4 bit immediate,0,0,0,0
9584, Write the encoidng header of the entry in 'p'.,0,0,0,0
9585,If p is NULL it just returns  the amount of bytes required to encode such a length.,1,0,0,1
9586,Arguments:   'encoding' is the encoding we are using for the entry.,0,0,0,0
9587,It could be  ZIP_INT_ or ZIP_STR_ or between ZIP_INT_IMM_MIN and ZIP_INT_IMM_MAX  for single-byte small immediate integers.,1,0,0,1
9588,'rawlen' is only used for ZIP_STR_ encodings and is the length of the  srting that this entry represents.,1,0,0,1
9589,The function returns the number of bytes used by the encoding or length  header stored in 'p'.,0,0,0,0
9590," Although encoding is given it may not be set for strings,          so we determine it here using the raw length.",1,0,0,1
9591," Implies integer encoding, so length is always 1.",0,1,0,1
9592, Store this length at p.,0,1,0,1
9593," Decode the entry encoding type and data length (string length for strings,  number of bytes used for the integer for integer entries) encoded in 'ptr'.",0,0,0,0
9594,"The 'encoding' variable will hold the entry encoding, the 'lensize'  variable will hold the number of bytes required to encode the entry  length, and the 'len' variable will hold the entry length.",0,0,0,0
9595," Encode the length of the previous entry and write it to ""p"".",1,0,0,1
9596,This only  uses the larger encoding (required in __ziplistCascadeUpdate).,1,0,0,1
9597," Encode the length of the previous entry and write it to ""p"".",1,0,0,1
9598,"Return the  number of bytes needed to encode this length if ""p"" is NULL.",0,0,0,0
9599, Return the number of bytes used to encode the length of the previous  entry.,1,0,0,1
9600,The length is returned by setting the var 'prevlensize'.,0,0,0,0
9601," Return the length of the previous element, and the number of bytes that  are used in order to encode the previous element length.",1,0,0,1
9602,'ptr' must point to the prevlen prefix of an entry (that encodes the  length of the previos entry in order to navigate the elements backward).,0,0,0,0
9603,"The length of the previous entry is stored in 'prevlen', the number of  bytes needed to encode the previous entry length are stored in  'prevlensize'.",1,0,0,1
9604," Given a pointer 'p' to the prevlen info that prefixes an entry, this  function returns the difference in number of bytes needed to encode  the prevlen if the previous entry changes of size.",1,0,0,1
9605,So if A is the number of bytes used right now to encode the 'prevlen'  field.,1,0,0,1
9606,And B is the number of bytes that are needed in order to encode the  'prevlen' if the previous element will be updated to one of size 'len'.,1,0,0,1
9607,"Then the function returns B - A   So the function returns a positive number if more space is needed,  a negative number if less space is needed, or zero if the same space  is needed.",1,0,0,1
9608, Return the total number of bytes used by the entry pointed to by 'p'.,1,1,0,1
9609, Check if string pointed to by 'entry' can be encoded as an integer.,0,1,0,1
9610,Stores the integer value in 'v' and its encoding in 'encoding'.,0,0,0,0
9611," Great, the string can be encoded.",1,1,0,1
9612,Check what's the smallest          of our encoding types that can hold this value.,0,0,0,0
9613," Store integer 'value' at 'p', encoded as 'encoding'",0,1,0,1
9614," Nothing to do, the value is stored in the encoding itself.",0,1,0,1
9615, Read integer encoded as 'encoding' from 'p',0,1,0,1
9616, Return a struct with all information about an entry.,0,0,0,0
9617, Create a new empty ziplist.,1,0,0,1
9618, Resize the ziplist.,0,0,0,0
9619," When an entry is inserted, we need to set the prevlen field of the next  entry to equal the length of the inserted entry.",1,0,0,1
9620,It can occur that this  length cannot be encoded in 1 byte and the next entry needs to be grow  a bit larger to hold the 5-byte encoded prevlen.,1,0,0,1
9621,"This can be done for free,  because this only happens when an entry is already being inserted (which  causes a realloc and memmove).",1,0,0,1
9622,"However, encoding the prevlen may require  that this entry is grown as well.",0,0,0,0
9623,"This effect may cascade throughout  the ziplist when there are consecutive entries with a size close to  ZIP_BIG_PREVLEN, so we need to check that the prevlen can be encoded in  every consecutive entry.",0,0,0,0
9624,"Note that this effect can also happen in reverse, where the bytes required  to encode the prevlen field can shrink.",0,0,0,0
9625,"This effect is deliberately ignored,  because it can cause a ""flapping"" effect where a chain prevlen fields is  first grown and then shrunk again after consecutive inserts.",1,0,0,1
9626,"Rather, the  field is allowed to stay larger than necessary, because a large prevlen  field implies the ziplist is holding large entries anyway.",1,0,0,1
9627,"The pointer ""p"" points to the first entry that does NOT need to be  updated, i.e.",1,0,0,1
9628,consecutive fields MAY need an update.,0,0,0,0
9629, Abort if there is no next entry.,0,0,0,0
9630," Abort when ""prevlen"" has not changed.",0,0,0,0
9631," The ""prevlen"" field of ""next"" needs more bytes to hold              the raw length of ""cur"".",1,0,0,1
9632, Current pointer and offset for next element.,1,1,0,1
9633, Update tail offset when next element is not the tail element.,0,1,0,1
9634, Move the tail to the back.,0,1,0,1
9635, Advance the cursor,0,1,0,1
9636," This would result in shrinking, which we want to avoid.",0,1,0,1
9637,"So, set ""rawlen"" in the available bytes.",1,0,0,1
9638," Stop here, as the raw length of ""next"" has not changed.",1,0,0,1
9639," Delete ""num"" entries, starting at ""p"".",1,0,0,1
9640,Returns pointer to the ziplist.,0,0,0,0
9641, Bytes taken by the element(s) to delete.,0,1,0,1
9642, Storing `prevrawlen` in this entry may increase or decrease the              number of bytes required compare to the current `prevrawlen`.,1,0,0,1
9643,"There always is room to store this, because it was previously              stored by an entry that is now being deleted.",1,0,0,1
9644," Note that there is always space when p jumps backward: if              the new previous entry is large, one of the deleted elements              had a 5 bytes prevlen header, so there is for sure at least              5 bytes free and we need just 4.",1,0,0,1
9645, Update offset for tail,0,1,0,1
9646," When the tail contains more than one entry, we need to take              ""nextdiff"" in account as well.",1,0,0,1
9647,"Otherwise, a change in the              size of prevlen doesn't have an effect on the tail offset.",0,0,0,0
9648, Move tail to the front of the ziplist,0,0,0,0
9649, The entire tail was deleted.,1,1,0,1
9650,No need to move memory.,0,1,0,1
9651, Resize and update length,0,0,0,0
9652," When nextdiff != 0, the raw length of the next entry has changed, so          we need to cascade the update throughout the ziplist",1,0,0,1
9653," Insert item at ""p"".",0,0,0,0
9654, initialized to avoid warning.,0,0,0,0
9655,Using a value                                    that is easy to see if for some reason                                    we use it uninitialized.,1,0,0,1
9656, Find out prevlen for the entry that is inserted.,0,0,0,0
9657, See if the entry can be encoded,0,1,0,1
9658, 'encoding' is set to the appropriate integer encoding,1,0,0,1
9659," 'encoding' is untouched, however zipStoreEntryEncoding will use the          string length to figure out how to encode it.",0,0,0,0
9660, We need space for both the length of the previous entry and      the length of the payload.,1,0,0,1
9661," When the insert position is not equal to the tail, we need to      make sure that the next entry can hold this entry's length in      its prevlen field.",1,0,0,1
9662, Store offset because a realloc may change the address of zl.,0,0,0,0
9663, Apply memory move when necessary and update tail offset.,1,1,0,1
9664, Subtract one because of the ZIP_END bytes,0,1,0,1
9665, Encode this entry's raw length in the next entry.,1,1,0,1
9666, Update offset for tail,0,1,0,1
9667," When the tail contains more than one entry, we need to take          ""nextdiff"" in account as well.",1,0,0,1
9668,"Otherwise, a change in the          size of prevlen doesn't have an effect on the tail offset.",0,0,0,0
9669, This element will be the new tail.,1,1,0,1
9670," When nextdiff != 0, the raw length of the next entry has changed, so      we need to cascade the update throughout the ziplist",1,0,0,1
9671, Write the entry,0,1,0,1
9672, Merge ziplists 'first' and 'second' by appending 'second' to 'first'.,1,0,0,1
9673,NOTE: The larger ziplist is reallocated to contain the new merged ziplist.,1,0,0,1
9674,Either 'first' or 'second' can be used for the result.,1,1,0,1
9675,The parameter not  used will be free'd and set to NULL.,1,0,0,1
9676,"After calling this function, the input parameters are no longer valid since  they are changed and free'd in-place.",1,0,0,1
9677,The result ziplist is the contents of 'first' followed by 'second'.,1,0,0,1
9678,On failure: returns NULL if the merge is impossible.,1,0,0,1
9679,"On success: returns the merged ziplist (which is expanded version of either  'first' or 'second', also frees the other unused input ziplist, and sets the  input ziplist argument equal to newly reallocated ziplist return value.",1,0,0,1
9680," If any params are null, we can't merge, so NULL.",0,0,0,0
9681, Can't merge same list into itself.,1,1,0,1
9682, Pick the largest ziplist so we can resize easily in-place.,1,0,0,1
9683,We must also track if we are now appending or prepending to      the target ziplist.,0,0,0,0
9684," retain first, append second to first.",1,0,0,1
9685," else, retain second, prepend first to second.",1,0,0,1
9686, Calculate final bytes (subtract one pair of metadata),1,1,0,1
9687, Combined zl length should be limited within UINT16_MAX,1,0,0,1
9688, Save offset positions before we start ripping memory apart.,0,1,0,1
9689, Extend target to new zlbytes then append or prepend source.,1,0,0,1
9690, append == appending to target,0,0,0,0
9691," Copy source after target (copying over original [END]):            [TARGET - END, SOURCE - HEADER]",1,0,0,1
9692, !append == prepending to target,0,0,0,0
9693," Move target contents exactly size of (source - [END]),          then copy source into vacataed space (source - [END]):            [SOURCE - END, TARGET - HEADER]",1,0,0,1
9694, Update header metadata.,0,1,0,1
9695, New tail offset is:        + N bytes of first ziplist        - 1 byte for [END] of first ziplist        + M bytes for the offset of the original tail of the second ziplist        - J bytes for HEADER because second_offset keeps no header.,1,0,0,1
9696, __ziplistCascadeUpdate just fixes the prev length values until it finds a      correct prev length value (then it assumes the rest of the list is okay).,1,0,0,1
9697,We tell CascadeUpdate to start at the first ziplist's tail element to fix      the merge seam.,1,0,0,1
9698, Now free and NULL out what we didn't realloc,1,0,0,1
9699, Returns an offset to use for iterating with ziplistNext.,0,0,0,0
9700,"When the given  index is negative, the list is traversed back to front.",1,0,0,1
9701,"When the list  doesn't contain an element at the provided index, NULL is returned.",0,0,0,0
9702, Return pointer to next entry in ziplist.,0,0,0,0
9703,"zl is the pointer to the ziplist  p is the pointer to the current element   The element after 'p' is returned, otherwise NULL if we are at the end.",1,0,0,1
9704," ""p"" could be equal to ZIP_END, caused by ziplistDelete,      and we should return NULL.",1,0,0,1
9705,"Otherwise, we should return NULL      when the next element is ZIP_END (there is no next entry).",0,0,0,0
9706, Return pointer to previous entry in ziplist.,1,0,0,1
9707, Iterating backwards from ZIP_END should return the tail.,0,1,0,1
9708,"When ""p"" is      equal to the first element of the list, we're already at the head,      and should return NULL.",1,0,0,1
9709, Get entry pointed to by 'p' and store in either 'sstr' or 'sval' depending  on the encoding of the entry.,0,0,0,0
9710,'sstr' is always set to NULL to be able  to find out whether the string pointer or the integer value was set.,1,0,0,1
9711,"Return 0 if 'p' points to the end of the ziplist, 1 otherwise.",0,0,0,0
9712," Insert an entry at ""p"".",0,0,0,0
9713," Delete a single entry from the ziplist, pointed to by p.  Also update p in place, to be able to iterate over the  ziplist, while deleting entries.",1,0,0,1
9714," Store pointer to current element in p, because ziplistDelete will      do a realloc which might result in a different ""zl""-pointer.",1,0,0,1
9715,"When the delete direction is back to front, we might delete the last      entry and end up with ""p"" pointing to ZIP_END, so check this.",1,0,0,1
9716, Delete a range of entries from the ziplist.,0,0,0,0
9717, Compare entry pointer to by 'p' with 'sstr' of length 'slen'.,0,0,0,0
9718, Return 1 if equal.,1,1,0,1
9719, Raw compare,1,1,0,1
9720, Try to compare encoded values.,0,1,0,1
9721,Don't compare encoding because          different implementations may encoded integers differently.,1,0,0,1
9722, Find pointer to the entry equal to the specified entry.,1,1,0,1
9723,Skip 'skip' entries  between every comparison.,0,0,0,0
9724,Returns NULL when the field could not be found.,0,1,0,1
9725, Compare current entry with specified entry,1,1,0,1
9726, Find out if the searched field can be encoded.,0,1,0,1
9727,"Note that                  we do it only the first time, once done vencoding is set                  to non-zero and vll is set to the integer value.",1,0,0,1
9728, If the entry can't be encoded we set it to                          UCHAR_MAX so that we don't retry again the next                          time.,0,0,0,0
9729, Must be non-zero by now,0,1,0,1
9730," Compare current entry with specified entry, do it only                  if vencoding != UCHAR_MAX because if there is no encoding                  possible for the field it can't be a valid integer.",1,0,0,1
9731, Reset skip count,0,1,0,1
9732, Skip entry,0,1,0,1
9733, Move to next entry,0,1,0,1
9734, Return length of ziplist.,0,0,0,0
9735, Re-store length if small enough,1,1,0,1
9736, Return ziplist blob size in bytes.,0,0,0,0
9737, Do num times a push+pop from pos,0,0,0,0
9738," If an argument is given, use it as the random seed.",1,1,0,1
9739, Pop values again and compare their value.,0,1,0,1
9740, Deleting entry 1 will increase `prevrawlensize` for entry 2,0,0,0,0
9741," create list gives us: [hello, foo, quux, 1024]",1,0,0,1
9742," Merge two empty ziplists, get empty result back.",1,0,0,1
9743," merge gives us: [hello, foo, quux, 1024, hello, foo, quux, 1024]",1,0,0,1
9744, Hold temp vars from ziplist,0,0,0,0
9745, Create lists,0,1,0,1
9746, Add to ziplist,0,0,0,0
9747, Add to reference list,0,1,0,1
9748," Naive way to get elements, but similar to the stresser                  executed from the Tcl test suite.",1,0,0,1
9749," Memory layout of a zipmap, for the map ""foo"" => ""bar"", ""hello"" => ""world"":   <zmlen><len>""foo""<len><free>""bar""<len>""hello""<len><free>""world""   <zmlen> is 1 byte length that holds the current size of the zipmap.",1,0,0,1
9750,"When the zipmap length is greater than or equal to 254, this value  is not used and the zipmap needs to be traversed to find out the length.",1,0,0,1
9751,<len> is the length of the following string (key or value).,1,0,0,1
9752,<len> lengths are encoded in a single value or in a 5 bytes value.,1,0,0,1
9753,"If the first byte value (as an unsigned 8 bit value) is between 0 and  253, it's a single-byte length.",1,0,0,1
9754,If it is 254 then a four bytes unsigned  integer follows (in the host byte ordering).,0,0,0,0
9755,A value of 255 is used to  signal the end of the hash.,0,0,0,0
9756,"<free> is the number of free unused bytes after the string, resulting  from modification of values associated to a key.",1,0,0,1
9757,"For instance if ""foo""  is set to ""bar"", and later ""foo"" will be set to ""hi"", it will have a  free byte to use if the value will enlarge again later, or even in  order to add a key or value pair if it fits.",1,0,0,1
9758,"<free> is always an unsigned 8 bit number, because if after an  update operation there are more than a few free bytes, the zipmap will be  reallocated to make sure it is as small as possible.",1,0,0,1
9759,"The most compact representation of the above two elements hash is actually:   ""\x02\x03foo\x03\x00bar\x05hello\x05\x00world\xff""   Note that because keys and values are prefixed length ""objects"",  the lookup will take O(N) where N is the number of elements  in the zipmap and not the number of bytes needed to represent the zipmap.",1,0,0,1
9760,This lowers the constant times considerably.,1,1,0,1
9761," The following defines the max value for the <free> field described in the  comments above, that is, the max number of trailing bytes in a value.",1,0,0,1
9762," The following macro returns the number of bytes needed to encode the length  for the integer value _l, that is, 1 byte for lengths < ZIPMAP_BIGLEN and  5 bytes for all the other lengths.",1,0,0,1
9763, Create a new empty zipmap.,1,0,0,1
9764, Length,0,1,0,1
9765, Decode the encoded length pointed by 'p',0,1,0,1
9766, Encode the length 'l' writing it in 'p'.,0,1,0,1
9767,If p is NULL it just returns  the amount of bytes required to encode such a length.,1,0,0,1
9768," Search for a matching key, returning a pointer to the entry inside the  zipmap.",1,0,0,1
9769,Returns NULL if the key is not found.,1,1,0,1
9770,"If NULL is returned, and totlen is not NULL, it is set to the entire  size of the zimap, so that the calling function will be able to  reallocate the original zipmap to make room for more entries.",1,0,0,1
9771, Match or skip the key,1,1,0,1
9772, Only return when the user doesn't care              for the total length of the zipmap.,1,0,0,1
9773, Skip the value as well,0,1,0,1
9774, +1 to skip the free byte,1,1,0,1
9775, Return the total amount used by a key (encoded length + payload),1,1,0,1
9776, Return the total amount used by a value  (encoded length + single byte free count + payload),1,0,0,1
9777," If 'p' points to a key, this function returns the total amount of  bytes used to store this entry (entry = key + associated value + trailing  free space if any).",1,0,0,1
9778," Set key to value, creating the key if it does not already exist.",1,1,0,1
9779,"If 'update' is not NULL, update is set to 1 if the key was  already preset, otherwise to 0.",1,0,0,1
9780, Key not found: enlarge,1,1,0,1
9781, Increase zipmap length (this is an insert),0,0,0,0
9782, Key found.,1,1,0,1
9783,Is there enough space for the new value?,1,1,0,1
9784, Compute the total length:,1,1,0,1
9785," Store the offset of this key within the current zipmap, so              it can be resized.",1,0,0,1
9786,"Then, move the tail backwards so this              pair fits at the current position.",1,0,0,1
9787, The +1 in the number of bytes to be moved is caused by the              end-of-zipmap byte.,0,0,0,0
9788,Note: the original zmlen is used.,1,0,0,1
9789, We now have a suitable block where the key or value entry can      be written.,1,0,0,1
9790,"If there is too much free space, move the tail      of the zipmap a few bytes to the front and shrink the zipmap,      as we want zipmaps to be very space efficient.",1,0,0,1
9791," First, move the tail <empty> bytes to the front, then resize          the zipmap to be <empty> bytes smaller.",1,0,0,1
9792, Just write the key + value and we are done.,1,1,0,1
9793, Key:,1,1,0,1
9794, Value:,0,1,0,1
9795, Remove the specified key.,1,1,0,1
9796,"If 'deleted' is not NULL the pointed integer is  set to 0 if the key was not found, to 1 if it was found and deleted.",1,0,0,1
9797, Decrease zipmap length,0,0,0,0
9798, Call before iterating through elements via zipmapNext(),0,0,0,0
9799, This function is used to iterate through all the zipmap elements.,0,0,0,0
9800,In the first call the first argument is the pointer to the zipmap + 1.,1,0,0,1
9801,In the next calls what zipmapNext returns is used as first argument.,1,0,0,1
9802,"Example:   unsigned char i = zipmapRewind(my_zipmap);  while((i = zipmapNext(i,&key,&klen,&value,&vlen)) != NULL) {      printf(""%d bytes key at $p\n"", klen, key);      printf(""%d bytes value at $p\n"", vlen, value);  }",1,0,0,1
9803, Search a key and retrieve the pointer and len of the associated value.,1,0,0,1
9804,"If the key is found the function returns 1, otherwise 0.",1,1,0,1
9805," Return 1 if the key exists, otherwise 0 is returned.",1,1,0,1
9806, Return the number of entries inside a zipmap,0,0,0,0
9807, Re-store length if small enough,1,1,0,1
9808," Return the raw size in bytes of a zipmap, so that we can serialize  the zipmap on disk (or everywhere is needed) just writing the returned  amount of bytes of the C array starting at the zipmap pointer.",1,0,0,1
9809, This function provide us access to the original libc free().,1,0,0,1
9810,This is useful  for instance to free results obtained by backtrace_symbols().,1,0,0,1
9811,We need  to define this function before including zmalloc.h that may shadow the  free implementation if we use jemalloc or another non standard allocator.,1,0,0,1
9812, Explicitly override malloc or free etc when using tcmalloc.,1,0,0,1
9813, Allocation and free functions that bypass the thread cache  and go straight to the allocator arena bins.,1,0,0,1
9814,Currently implemented only for jemalloc.,1,0,0,1
9815,Used for online defragmentation.,0,0,0,0
9816," Provide zmalloc_size() for systems where this function is not provided by  malloc itself, given that in that case we store a header with this  information as the first bytes of every allocation.",1,0,0,1
9817, Assume at least that all the allocations are padded at sizeof(long) by      the underlying allocator.,1,0,0,1
9818, Get the RSS information in an OS-specific way.,0,1,0,1
9819,WARNING: the function zmalloc_get_rss() is not designed to be fast  and may not be called in the busy loops where Redis tries to release  memory expiring or swapping out objects.,1,0,0,1
9820,"For this kind of ""fast RSS reporting"" usages use instead the  function RedisEstimateRSS() that is a much faster (and less precise)  version of the function.",1,0,0,1
9821, RSS is the 24th field in  or proc or <pid> or stat,0,0,0,0
9822, If we can't get the RSS in an OS-specific way for this system just      return the memory usage we estimated in zmalloc()..           Fragmentation will appear to be always 1 (no fragmentation)      of course...,0,0,0,0
9823, Update the statistics cached by mallctl.,0,0,0,0
9824," Unlike RSS, this does not include RSS from shared libraries and other non      heap mappings.",1,0,0,1
9825," Unlike resident, this doesn't not include the pages jemalloc reserves      for re-use (purge will clean that).",1,0,0,1
9826," Unlike zmalloc_used_memory, this matches the stats.resident by taking      into account all allocations done by this process (not only zmalloc).",1,0,0,1
9827, Get the sum of the specified field (converted form kb to bytes) in   or proc or self or smaps.,0,0,0,0
9828,"The field must be specified with trailing "":"" as it  apperas in the smaps output.",0,0,0,0
9829,"If a pid is specified, the information is extracted for such a pid,  otherwise if pid is -1 the information is reported is about the  current process.",1,0,0,1
9830,"Example: zmalloc_get_smap_bytes_by_field(""Rss:"",-1);",0,0,0,0
9831, Returns the size of physical memory (RAM) in bytes.,1,1,0,1
9832,"It looks ugly, but this is the cleanest way to achive cross platform results.",1,0,0,1
9833,Cleaned up from:   http: or  or nadeausoftware.com or articles or 2012 or 09 or c_c_tip_how_get_physical_memory_size_system   Note that this function:  1) Was released under the following CC attribution license:     http: or  or creativecommons.org or licenses or by or 3.0 or deed.en_US.,1,0,0,1
9834,2) Was originally implemented by David Robert Nadeau.,1,0,0,1
9835,3) Was modified for Redis by Matt Stancliff.,0,0,0,0
9836,4) This note exists in order to comply with the original license.,1,1,0,1
9837, OSX.,0,1,0,1
9838," NetBSD, OpenBSD.",0,1,0,1
9839, 64-bit,0,1,0,1
9840, Failed?,1,1,0,1
9841," FreeBSD, Linux, OpenBSD, and Solaris.",0,0,0,0
9842," DragonFly BSD, FreeBSD, NetBSD, OpenBSD, and OSX.",0,1,0,1
9843, FreeBSD.,0,1,0,1
9844, Others.,0,1,0,1
9845, 32-bit,0,1,0,1
9846, Failed?,1,1,0,1
9847, Unknown method to get the data.,1,1,0,1
9848, Unknown OS.,1,1,0,1